<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qybit&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ab3e80cccd375287a4f40b2a02dc6cd6</icon>
  <subtitle>Talk is cheap, show me your code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qybit.gitee.io/"/>
  <updated>2021-10-01T07:55:27.789Z</updated>
  <id>https://qybit.gitee.io/</id>
  
  <author>
    <name>qybit</name>
    <email>2601970213@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EQ-34-在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://qybit.gitee.io/2021/10/01/34/"/>
    <id>https://qybit.gitee.io/2021/10/01/34/</id>
    <published>2021-10-01T06:58:54.000Z</published>
    <updated>2021-10-01T07:55:27.789Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>找了一道极其具有代表性的题目来复习一下二分查找算法，在有序数组里找重复元素的第一个和最后一个位置。</p><p>先看看我们一般情况下简单的二分算法是怎么样的。这里的需求是，在有序数组中查找元素 $x$。</p><p>一般情况下，我们会定义区间 $[l, r]$ ，每一次划分时我们取 $[l, mid-1]$，或者 $[mid + 1, 1]$ 。当 $mid$ 命中时，我们即刻返回 $mid$ 。当 $l == r$ 说明，有序数组里没有我们要找的元素，我们返回 $-1$；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">nums_, x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums_.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums_[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums_[mid] &gt; x) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">5</span>; </span><br><span class="line"><span class="built_in">console</span>.log(search(nums, target)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="YXC-算法模板"><a href="#YXC-算法模板" class="headerlink" title="YXC 算法模板"></a>YXC 算法模板</h2><p><a href="https://www.acwing.com/user/myspace/index/1/">@闫学灿</a> 的算法模板非常的简单整洁，他为我们总结了两套通用的<a href="https://www.acwing.com/blog/content/31/">二分查找算法模板</a></p><p>根据 YXC 的算法思路：假设目标值存在闭区间 $[l, r]$，每一次将区间缩小一半，当 <code>l=r</code>时，我们就找到了目标值。</p><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><p>当我们将区间 $[l,r]$ 划分成 $[l, mid]$ 和 $[mid + 1, r]$，其更新操作是 <code>r=mid</code> 或者 <code>l=mid+1</code>，计算 <code>mid</code> 时不需要加1。</p><p>算法模板表示为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把上面自己的算法，改造成适用于 YXC 版算法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">nums_, x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums_.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums_[mid] &gt;= x) &#123; <span class="comment">// 注意这里的区间选择，[l, mid] 新的区间里必须包含 x，否则算法将会出现错误</span></span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums_[l] != x) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">9</span>; </span><br><span class="line"><span class="built_in">console</span>.log(search(nums, target)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>注意：二分算法的思路非常简单，即当数组整体呈现单调性即可。但是在具体的问题中，如何正确的分配区间是一个致命的问题，你在实际代码很容易就会写成死循环，或者算法期望错误。</p><p>我们不参考 版本2，因为版本2需要 $\lceil mid \rceil$ ，我们可能会搞混淆所以不考虑版本2。</p><h1 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们设置 $p1, p2$ 分别为对应元素的左端点和右端点，$L$  和  $R$ 设置为数组的起点和末位。这道题的思路就是：先查找第一个等于 $target$ 的位置，然后再查找第一个大于 $target$ 元素的位置减一。</p><ol><li><p>先找到左边界值的位置，每一次划分时，我们都取 $[l, mid]$ 区间。这与我们上面的二分算法是一致的</p><p> <img src="https://pic.imgdb.cn/item/6156ba5c2ab3f51d91386e19.jpg"></p></li><li><p>我们设置第二次 二分查找 的闭区间为 $[p1, R]$，我们可以查找第一个大于 $target$ 的位置 $p3$，这样最右边的元素位置 $p2 = p3-1$ </p><p> <img src="https://pic.imgdb.cn/item/6156bdea2ab3f51d913e99b6.jpg"></p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        p1 = l;</span><br><span class="line">        r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;p1, p2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(log \ n)$，其中 $n$ 表示为数组的长度。我们一共进行两次二分查找，其中一次二分查找的时间复杂度为 $O(log \ n)$，即 $O(2 \times log \ n) = O(log \ n)$。</p><p>空间复杂度：$O(1)$，我们只使用了常量空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="二分查找" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>EQ-3-无重复字符的最长字串</title>
    <link href="https://qybit.gitee.io/2021/09/29/3/"/>
    <id>https://qybit.gitee.io/2021/09/29/3/</id>
    <published>2021-09-29T12:21:28.000Z</published>
    <updated>2021-09-29T12:37:04.469Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们定义两个指针 $l$ 和 $r$ ，分别表示最长不重复子串的左端点和右端点。</p><p>对于每一个子串，我们都尽可能的扩大子串的范围，每一次都将指针 $r$ 向右移动一位。并且记录字符串 $s[l…r]$ 中所有存在的字符，而当我们固定左右指针时，此时想移动右指针就存在两种情况：</p><ol><li>我们定义右指针指定的元素为 $c = s[r]$，对于此时的双指针</li><li>字符 $c$ 不在字符串 $s[l…r]$ 中，我们的左指针不动，右指针向右移动一位；</li><li>字符 $c$ 存在于字符串 $s[l…r]$ 中，此时我们固定右指针 $r$ 不动，移动左指针 $l$ 向右直到字符 $c \notin s[l…r]$ 时 ，我们就消除了重复字符，此时移动右指针向右移动一位。   </li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[r ++];</span><br><span class="line">            <span class="keyword">while</span> (st.find(c) != st.end()) &#123;</span><br><span class="line">                st.erase(s[l ++]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.insert(c);</span><br><span class="line">            res = max(res, (<span class="keyword">int</span>)st.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n)$，其中 $n$ 表示字符串的长度，我们的左右指针最多只会遍历一次字符串，相当于 $O(2 \times n)= O(n)$，常熟可忽略。</p><p>空间复杂度：$O(|\sum|)$，其中 $\sum$ 为最长子串的数量，我们需要记录最长子串的所有字符。其中字符表示 ASCII 值，所以 $\sum_{max} = 128$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;3. 无重复字符的最长子串&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：双指针&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="https://qybit.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>async/await原理学习笔记</title>
    <link href="https://qybit.gitee.io/2021/09/29/async-await-source/"/>
    <id>https://qybit.gitee.io/2021/09/29/async-await-source/</id>
    <published>2021-09-29T02:10:24.000Z</published>
    <updated>2021-09-29T11:33:07.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="1、JS-是单线程"><a href="#1、JS-是单线程" class="headerlink" title="1、JS 是单线程"></a>1、JS 是单线程</h3><p>首先，JavaScript 的一大特色就是单线程语言，这种设计使得 JavaScript 在同一时刻只做一件事；作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，避免了复杂性，比如假设 JavaScript 有两个线程，那么在同一时刻进行添加和删除节点操作，为浏览器分辨以哪个线程为主带来了困难，所以单线程是它作为脚本语言的优势，也是核心所在。</p><h3 id="2、同步任务和异步任务"><a href="#2、同步任务和异步任务" class="headerlink" title="2、同步任务和异步任务"></a>2、同步任务和异步任务</h3><p>单线程也就意味所有的任务都需要排队，前一个任务结束后下一个任务才会执行，为了提高 CPU 的利用率，就把任务分为了同步任务和异步任务。同步任务会在主线程栈顺序执行，而异步任务则会先进入任务队列中。在主线程上会形成一个执行栈，等执行栈中所有任务执行完毕后，会到异步任务队列中查看有哪些事件，此时异步任务结束等待状态，进入执行栈中，开始执行。</p><h2 id="JS-异步编程方法"><a href="#JS-异步编程方法" class="headerlink" title="JS 异步编程方法"></a>JS 异步编程方法</h2><p>需求描述：假设我有一个 <code>db1.json</code> 存放用户的个人信息，有一个 <code>db2.json</code> 存放用户的订单信息。现在我要查找该用户的全部订单信息，我应该怎么做？</p><blockquote><p>首先我需要先根据前台的信息查找到用户的个人信息后，再去查找用户的订单信息。</p></blockquote><p>那么在业务代码上是如何体现的呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">&#x27;/db/db1.json&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err; <span class="comment">// error </span></span><br><span class="line"> <span class="comment">// success</span></span><br><span class="line">    readFile(<span class="string">&#x27;/db/db2.json&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// do something </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以很明显的看到，我们的业务代码在不停的嵌套着这种回调函数风格，假如我在获取到 <code>bd1.json</code> 之后还有其他的事情，比如查看用户是不是满足打折优惠、满减和附赠优惠卷等活动时，那这个嵌套的深度将会 $\infty$ 大。</p><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><ol><li><p>嵌套深度过大，代码难以阅读和维护，造成 “回调地狱”。</p></li><li><p>异步任务具有 “滞后性”，即它略过异步任务代码，直接执行同步代码。造成 undefined 错误。</p><p> 相信有很多用过 jQuery 的小伙伴，那么对于下面这种错误代码，应该都非常的熟悉</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://xxx.com/api/xxx&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: <span class="number">12</span>,  </span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        res = data; <span class="comment">// 上下文找不到该变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><p> 原因此时很简单，因为 ajax 本身是一个异步任务，因此在执行时 ajax 函数的上下文已经发生了改变。因此找不到 res 变量，又由于 JS 会提升变量因此 res = undefined。</p><p> 解决办法：async: false，将 ajax 改为 同步任务</p></li><li><p>执行上下文发生改变。</p></li></ol><h2 id="Promise-链式调用解决-回调地狱"><a href="#Promise-链式调用解决-回调地狱" class="headerlink" title="Promise 链式调用解决 回调地狱"></a>Promise 链式调用解决 回调地狱</h2><p>我们改造异步编程中的代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       readFile(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// do something </span></span><br><span class="line">            resolve(data);</span><br><span class="line">    &#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 链式调用</span></span><br><span class="line">readFilePromise(<span class="string">&#x27;/db1.json&#x27;</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">&#x27;/db2.json&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(); <span class="comment">// .....</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这样的代码可能看起来逻辑上是足够清晰了，但是我又不想嵌套这么多层的 <code>then</code>，而且每一层 <code>then</code> 里我还要返回一个 Promise ，才能保证调用链的正常执行。</p><h2 id="解决-回调地狱-的终极方法"><a href="#解决-回调地狱-的终极方法" class="headerlink" title="解决 回调地狱 的终极方法"></a>解决 回调地狱 的终极方法</h2><h3 id="async-await-关键字"><a href="#async-await-关键字" class="headerlink" title="async/await 关键字"></a>async/await 关键字</h3><p>可以通过 <code>async/await</code> 一对关键字，注意是一对，使用 <code>await</code> 时必须要先声明 <code>async</code> 。我们可以通过 <code>await</code> 阻塞同步任务，使得异步任务完成后再继续进行同步任务。</p><p>具体可看代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       readFile(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// do something </span></span><br><span class="line">            resolve(data);</span><br><span class="line">    &#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">;(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFilePromise(<span class="string">&#x27;/db1.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFilePromise(<span class="string">&#x27;/db2.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样我们的异步任务代码就可以完美的嵌入到同步任务代码中了</p><h2 id="深挖原理"><a href="#深挖原理" class="headerlink" title="深挖原理"></a>深挖原理</h2><p>我们从最经典的异步任务 <code>setTimeout</code> 举例，把它改写成同步任务</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">await</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="comment">// 分别输出</span></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// p3</span></span><br></pre></td></tr></table></figure><ul><li><p>async 和 await 处理异步任务都是基于 Promise 的，await 后面需要跟一个返回 Promise 对象的函数。</p></li><li><p>如果 await 后跟的是一个普通函数，await 会将其 Promise 化。</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> otherTest();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">otherTest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherTest&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出 test start -&gt; otherTest -&gt; after test -&gt; test end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为其相当于变成了</span></span><br><span class="line"><span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test start&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        otherTest();</span><br><span class="line">    &#125;);</span><br><span class="line">    p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;test end&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>async/await是语法糖，用 async 标记的函数，在其内部遇到 await 标记的逻辑时，会被阻塞不执行后续的逻辑，等 await 内部的逻辑处理完毕后，再继续走await后面的逻辑，这个方式，其实就是 ES6 定义的 generator 函数。即 async 与 await 将标记的函数转换成了生成器。</p></li></ul><h3 id="手动实现一个-async-函数"><a href="#手动实现一个-async-函数" class="headerlink" title="手动实现一个 async 函数"></a>手动实现一个 async 函数</h3><p>将 函数 <code>p</code> 变成一个 generator 函数，其中遇到 await 的地方就改成 yield</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">p</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">yield</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续运行 p()，得到一个迭代器，调用  next()，我们需要手动调用这个 next 函数才会继续执行 函数p，所以我们需要一个自动执行的入口函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            next(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)(p);</span><br></pre></td></tr></table></figure><p>该函数会自动调用，我们执行了生成器 p 得到迭代器 gen，通过递归 next ，将 gen 自动执行到底（当 done =true 时，每次调用迭代器都会返回 <code>&#123;value: &#39;xxx&#39;, done: boolean&#125;</code> ）。</p><p>而当 yield 后面表达式返回 Promise 时，通过迭代器的 next 方法放到 Promise 的 then 中执行，使得 yield 后面的逻辑要等待 p1 完成后才能继续进行，即达到同步的效果。</p><p>可见 async/await 是通过将函数变为一个生成器函数，并使用自动执行函数来执行他，在执行过程中，有意地让生成的迭代器放到 Promise 的 then 中，即异步完成后才执行，从而达到的同步效果。</p><p>完整的流程</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">        res(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">p</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">yield</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            next(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)(p);</span><br></pre></td></tr></table></figure><ul><li>首先自动执行函数，执行生成器 p 得到迭代器 gen</li><li>调用 next 函数，执行 gen.next，此时执行器执行到 p 函数的 yield p1()，返回了一个 Promise，该 Promise 在 1s 后打印 p1 后并返回 p2</li><li>在此之前，自动执行函数，在该 Promise 的回调中传入了 next 方法</li><li>则 1s 后，打印 p1，返回 p2，执行 next(p2)</li><li>迭代器继续执行 yield p1 后面的逻辑，并且把 p2 赋值给了 <code>p2</code></li><li>打印 p2，p3</li><li>async / await 的实现原比我们实现的 demo 要复杂，但是核心逻辑就是 generator 结合自动执行函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;1、JS-是单线程&quot;&gt;&lt;a href=&quot;#1、JS-是单线程&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="前端" scheme="https://qybit.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="https://qybit.gitee.io/categories/%E5%89%8D%E7%AB%AF/JS/"/>
    
    
      <category term="前端" scheme="https://qybit.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="https://qybit.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>EQ-437-路径总和III</title>
    <link href="https://qybit.gitee.io/2021/09/28/437/"/>
    <id>https://qybit.gitee.io/2021/09/28/437/</id>
    <published>2021-09-28T10:13:24.000Z</published>
    <updated>2021-09-28T10:47:08.789Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p><h1 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以遍历出所有的可能情况，对于某个节点 $node$ 我们穷举出所有可能的路径，只要满足和为 $target$ 我们就认为找到了一条路径。</p><p>对于任意一个节点 $node$，我们都需要计算其子节点存在的可能路径，一共有 $n$ 个节点，因为时间复杂度为 $O(n^2)$。观察数据范围节点范围最大是 $1000$，因此可行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        getSum(root, <span class="number">0</span>, targetSum);</span><br><span class="line">        pathSum(root -&gt; left, targetSum);</span><br><span class="line">        pathSum(root -&gt; right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> cur, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        cur += root -&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        getSum(root -&gt; left, cur, target);</span><br><span class="line">        getSum(root -&gt; right, cur, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n^2)$，其中 $n$ 为二叉树节点的数量，对于某一个节点，我们要遍历其所有子节点，时间复杂度为 $O(n)$。一共有 $n$ 个节点，因此时间复杂度为 $O(n^2)$。</p><p>空间复杂度：$O(n)$，递归消耗的栈空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/path-sum-iii/&quot;&gt;437. 路径总和 III&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：深度优先搜索&quot;&gt;&lt;a href=&quot;#方法一：深度优先搜索&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="二叉树" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="https://qybit.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>EQ-2-两数相加</title>
    <link href="https://qybit.gitee.io/2021/09/27/2/"/>
    <id>https://qybit.gitee.io/2021/09/27/2/</id>
    <published>2021-09-27T10:21:40.000Z</published>
    <updated>2021-09-27T10:49:08.195Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></p><h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>由于两个链表都是<strong>逆序</strong>存储数字的位数，因此我们对于每一个相同位置的数字可以直接相加。</p><p>我们可以同时遍历链表，逐位计算每一位的和，并与当前进位的值和相加。如果当前位的数字分别为 $n1$ 和 $n2$ ，进位值 $carry$，那么当前位的和即表示为 $n1 + n2 + carry$，答案链表对应位置的数字即 $(n1 + n2 + carry) ; mod ; 10$，新的进位为 $\lfloor \frac{n1+n2+carry}{10} \rfloor$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        res -&gt; next = cur;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1 -&gt; val;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2 -&gt; val;</span><br><span class="line">            <span class="keyword">int</span> s = n1 + n2 + carry;</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            carry = s / <span class="number">10</span>;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1 -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(max(n, m))$，其中 $n$ 表示为链表1的长度，$m$ 表示为链表2的长度。我们会遍历两个链表的全部位置，且每个位置的处理时间为 $O(1)$。</p><p>空间复杂度：$O(max(n, m))$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot;&gt;2. 两数相加&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：模拟&quot;&gt;&lt;a href=&quot;#方法一：模拟&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="链表" scheme="https://qybit.gitee.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>EQ-371-两整数之和</title>
    <link href="https://qybit.gitee.io/2021/09/26/371/"/>
    <id>https://qybit.gitee.io/2021/09/26/371/</id>
    <published>2021-09-26T01:33:01.000Z</published>
    <updated>2021-09-26T02:16:26.953Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></p><h1 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>有符号整数在计算机中通常以补码的形式存储和表示，补码具有以下特征：</p><ol><li>正整数的补码与原码一致；负整数的补码为其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1</li><li>可以将减法运算转化为补码的加法运算来实现</li><li>补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算</li></ol><p>摘至：<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">百度百科-补码</a></p><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>首先，题目不允许使用运算符 <code>+</code> 和 <code>-</code> 。因此我们可以使用位运算代替这两种运算符的方式，观察一下我们在做补码加法时有如下四种情况</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span>;(进位)</span><br></pre></td></tr></table></figure><p>对于整数 $a$ 和 $b$，我们可以总结出：</p><ol><li>在不考虑进位的情况下，我们得到<strong>无进位加法结果</strong> $a \bigoplus b$。</li><li> 而所有需要进位的位为 $a \&amp; b$ ，<strong>进位结果</strong>可以表示为 $a \&amp; b &lt;&lt; 1$</li></ol><p>我们要求得 $a + b$ ，就表示为 <strong>无进位结果</strong> 和 <strong>进位结果</strong> 之和。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(log(C))$，令 $C$ 为有符号整数的位数，题目数据范围为 $32$ 位整数，因此 $C$ 最大可取值 $32$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-two-integers/&quot;&gt;371. 两整数之和&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：位运算&quot;&gt;&lt;a href=&quot;#方法一：位运算&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="位运算" scheme="https://qybit.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>EQ-583-两个字符串的删除操作</title>
    <link href="https://qybit.gitee.io/2021/09/25/583/"/>
    <id>https://qybit.gitee.io/2021/09/25/583/</id>
    <published>2021-09-25T09:51:56.000Z</published>
    <updated>2021-09-26T01:54:02.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>题目链接：<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p><a id="more"></a><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以设置 $f[i][j]$ 表示使得 $word1$ 前 $i$ 个字符 和  $word2$ 前 $j$ 个字符相等时的最小操作次数。</p><ol><li><p>对于 $0 \le i \lt word1.length$ 和 $ 0 \le j \lt word2.length$ 存在时，且我们是可以判断字符串 $word1[0…i-1]$ 和 字符串 $word2[0…j-1]$ 一定相等，那么对于 $word1$ 中第 $i$ 个字符 和 $word2$ 中第 $j$ 个字符有以下情况：</p><ol><li><p>$word1[i] = word2[j]$ ：</p><p> 我们不需要任何操作，因此 我们可以继承前 $i-1$ 个 和  前 $j -1$ 个字符相等时的最小操作次数。即 $f[i][j]=f[i-1][j-1]$</p></li><li><p>$word1[i] \neq word2[j]$：</p><ul><li>​    我们选择删除 $word1$ 中第 $i$ 个字符，假设此时字符串 $word1[0…i-1]$ 与字符串 $word2[0…j]$ 相等，那么需要的操作次数为 $f[i][j] = f[i-1][j] + 1$ </li><li>同理我们选择删除 $word2$ 中的第 $j$ 个字符，假设此时字符串 $word2[0…j-1]$ 与字符串 $word1[0…i]$ 相等，那么需要的操作次数为 $f[i][j]=f[i][j-1]+1$</li><li>我们选择同时删除 $word1$ 中的第 $i$ 个字符和 $word2$ 中的第 $j$ 个字符，那么此时需要的操作次数为 $f[i][j]=f[i-1][j-1]+2$</li><li>综合上述三种操作时，我们取最小值</li></ul></li></ol></li><li><p>状态转移方程定义<br> $$<br> f[i][j] =<br> \begin{cases}<br> f[i - 1][j - 1]&amp;, word1[i] = word2[j] \\<br> min({ f[i-1][j] + 1, f[i][j-1]+1, f[i-1][j-1]+2 })&amp;, word1[i] \ne word2[j]<br> \end{cases}<br> $$</p></li><li><p>初始化 $f$ 数组，我们的边界值实际上是当 $word1$ 或 $word2$ 为空字符串时</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i; <span class="comment">// word2 为空字符串时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j; <span class="comment">// word1 为空字符串时、</span></span><br></pre></td></tr></table></figure></li><li><p>以 <code>word1=sea</code> 和 <code>word2=eat</code> 举例，展示 $f$ 数组的状态</p><p> <img src="https://pic.imgdb.cn/item/614f04932ab3f51d91e2c486.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(&#123;f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>, f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p> 时间复杂度：$O(m \times n)$，其中 $m$ 为 $word1.length$，$n$ 为 $word2.length$ 。</p><p> 空间复杂度：$O(m \times n)$。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/delete-operation-for-two-strings/&quot;&gt;583. 两个字符串的删除操作&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="动态规划" scheme="https://qybit.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>第 239 场周赛</title>
    <link href="https://qybit.gitee.io/2021/05/06/259/"/>
    <id>https://qybit.gitee.io/2021/05/06/259/</id>
    <published>2021-05-06T02:07:38.000Z</published>
    <updated>2021-09-23T13:18:44.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></li><li> <a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></li></ul><h1 id="T1：到目标元素的最小距离"><a href="#T1：到目标元素的最小距离" class="headerlink" title="T1：到目标元素的最小距离"></a>T1：<a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题目模拟一遍即可。</p><p>我们使用 $int32$ 的最大值$INT_MAX$ ，当 $nums[i] = target$ 时，保证 $abs(i - start)$ 的值最小即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ans =  min(ans, <span class="built_in">abs</span>(i - start)); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><p>空间复杂度：$O(1)$。</p><h1 id="T2：将字符串拆分为递减的连续值"><a href="#T2：将字符串拆分为递减的连续值" class="headerlink" title="T2：将字符串拆分为递减的连续值"></a>T2：<a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></h1><p>注意到：当我们确定了第一个数之后，后面的数也就随之确定下来了。因此我们在搜索的过程中，是可以避免过多的冗余计算。</p><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>具体做法</p><ul><li>对于每一次递归：<ul><li>我们需要记录的状态如下：$idx$ 表示当前字符串的位置，$prev$ 表示上一个数的大小，$cnt$ 表示当前连续降序数字的数量。</li><li>我们尝试去确定第一个数，从下标 $0$ 开始增加这个数。枚举每一个可能的数（不包括全部的字符串），因为连续的字符串至少存在两个。</li><li>对于已经确定的上一个数，我们总是想要寻找下一个数，因此需要记录<strong>当前数</strong> $cur$ 的大小，当且仅当 $cur = prev - 1$ 时，我们才会继续寻找下一个数。</li><li>当我们搜索到字符串的末尾时，只有存在两个连续数字时才符合要求，此时可以返回 $True$。</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 字符串的长度是 20 位，一定会爆 int32</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitString</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        s = str;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, ULL prev, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            <span class="comment">// 连续的数字，至少要存在两个</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ULL cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; n; i ++) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 当前数已经大于上一个数，此时直接退出即可。</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; prev - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span> || prev - cur == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>, cur, cnt + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(2^n)$，其中 $n$ 为字符串的长度且最大为 $20$。</p><p>空间复杂度：$O(n)$，递归消耗的栈内存。</p><h2 id="方法二：枚举"><a href="#方法二：枚举" class="headerlink" title="方法二：枚举"></a>方法二：枚举</h2><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于字符串 $s$，我们可以枚举出所有可能的字串。</p><p>按照递归的思路去改写我们的代码</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第一个整数不能是自身</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            start = start * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">            preVal = start</span><br><span class="line">            curVal = <span class="number">0</span></span><br><span class="line">            curIdx = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> preVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">all</span>(s[k] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(curIdx, n)):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                curVal = curVal * <span class="number">10</span> + <span class="built_in">int</span>(s[j])</span><br><span class="line">                <span class="comment"># 枚举的下一个字串超过前一个整数</span></span><br><span class="line">                <span class="keyword">if</span> curVal &gt; preVal - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> preVal - curVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == n - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    preVal = curVal</span><br><span class="line">                    curVal = <span class="number">0</span></span><br><span class="line">                    curIdx = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="T3：邻位交换的最小次数"><a href="#T3：邻位交换的最小次数" class="headerlink" title="T3：邻位交换的最小次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>先找到当前字符串的第 $k$ 个排列（我们称之为<strong>妙数</strong>）</li><li>原字符串 $s$ 与 妙数 $num$ 进行对比，如果在下标 $i$ 的位置不相同：<ol><li>我们在 妙数 的下标 $i$ 之后寻找一个下标 $j$ 使得 $s[i] = num[j]$ ，再将 $j$ 对应的元素相邻的交换到 $i$ 的位置。</li><li>每一次交换都是我们的最小交换次数</li></ol></li></ol><p>寻找下一个排序与 <a href="https://leetcode-cn.com/problems/next-permutation/">力扣31. 下一个排列</a> 相同。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i] &gt;= s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] &lt;= s[i]) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin() + i + <span class="number">1</span>, s.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = num;</span><br><span class="line">        <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">            nextPermutation(num);</span><br><span class="line">            <span class="comment">// c++ 内置的实现，同理</span></span><br><span class="line">            <span class="comment">// next_permutation(num.begin(), num.end());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != s[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; num[j] != s[i]) &#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                    swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">                    ans ++;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N \times K + N^2)$，其中 $N$ 为字符串的长度，$K$ 为给定的整数。</p><ul><li>我们先做 $K$ 次寻找下一个妙数，每一次寻找妙数的时间复杂度为 $O(N)$。</li><li>我们再寻找原字符串到达妙数的最小交换次数，最坏的情况下对于每一个元素我们要访问 $N$ 次，因此时间复杂度为 $O(N^2)$</li></ul><p>空间复杂度：$O(N)$，其中 $N$ 为字符串的长度。我们需要存储原字符串。</p><h1 id="T4：包含每个查询的最小区间"><a href="#T4：包含每个查询的最小区间" class="headerlink" title="T4：包含每个查询的最小区间"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></h1><h2 id="思路：离线算法"><a href="#思路：离线算法" class="headerlink" title="思路：离线算法"></a>思路：离线算法</h2><p>我们将区间的左端点和右端点以及查询视作 事件，然后对其按照左端点、查询和右端点进行排序：</p><ul><li>如果当前事件为左端点，我们将区间长度加入 有序集合 中</li><li>如果当前事件为查询，我们取出 有序集合 的最小值</li><li>如果当前事件为右端点，我们将当前区间的长度从 有序集合 中移除</li></ul><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="comment">// 0 表示左端点</span></span><br><span class="line">        <span class="comment">// 1 表示询问</span></span><br><span class="line">        <span class="comment">// 2 表示右端点</span></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="comment">// 事件的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="comment">// if type = 0: 区间右端点的位置</span></span><br><span class="line">        <span class="comment">// if type = 1: 询问在原数组的位置</span></span><br><span class="line">        <span class="comment">// if type = 2: 区间左端点的位置</span></span><br><span class="line">        <span class="keyword">int</span> para;</span><br><span class="line"><span class="comment">// 如果位置相同，优先按照左端点</span></span><br><span class="line">        <span class="comment">// 按照左端点、询问、右端点的优先级排序</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Event&amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == t.pos) <span class="keyword">return</span> type &lt; t.type;</span><br><span class="line">            <span class="keyword">return</span> pos &lt; t.pos; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size(), m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Event&gt; events;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="comment">// 查询事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">1</span>, queries[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">            <span class="comment">// 左端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">0</span>, interval[<span class="number">0</span>], interval[<span class="number">1</span>]&#125;);</span><br><span class="line"><span class="comment">// 右端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">2</span>, interval[<span class="number">1</span>], interval[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(events.begin(), events.end());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; seg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event : events) &#123;</span><br><span class="line">            <span class="comment">// 当前事件为左端点，把区间长度插入到 有序集合</span></span><br><span class="line">            <span class="keyword">if</span> (event.type == <span class="number">0</span>) &#123;</span><br><span class="line">                seg.insert(event.para - event.pos + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 查询事件</span></span><br><span class="line">                <span class="keyword">if</span> (seg.size()) &#123;</span><br><span class="line">                    <span class="comment">// 不为空的话，就取出最小值</span></span><br><span class="line">                    ans[event.para] = *seg.begin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 右端点，此时的小区间不必再查询，我们直接移除即可</span></span><br><span class="line">                <span class="keyword">int</span> len = event.pos - event.para + <span class="number">1</span>;</span><br><span class="line">                seg.erase(seg.find(len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O((m+n)log(m+n))$，其中 $m$ 为区间数组 $intervals$ 的长度，$n$ 为查询数组 $queries$ 的长度。我们将其合并成一个 事件 数组，容量大小为 $2m + n = O(m + n)$。然后进行了排序操作，因此时间复杂度为 $O((m + n)log(m+n))$。</p><p>空间复杂度：$O(m+n)$，我们需要存储所有的事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/&quot;&gt;到目标元素的最小距离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯" scheme="https://qybit.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>第 237 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/19/w237/"/>
    <id>https://qybit.gitee.io/2021/04/19/w237/</id>
    <published>2021-04-19T01:49:11.000Z</published>
    <updated>2021-09-26T02:16:09.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/"> 判断句子是否为全字母句</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></li><li> <a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></li><li> <a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></li></ul><h1 id="T1：判断句子是否为全字母句"><a href="#T1：判断句子是否为全字母句" class="headerlink" title="T1：判断句子是否为全字母句"></a>T1：<a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>全字母句就是一个字符串包含字母表中的 $26$ 个字母。我们只需要开一个 $26$ 长度的数组记录一下字母的出现次数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfPangram</span><span class="params">(<span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : sentence) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : f) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度，我们需要扫描一遍字符串。</p><p>空间复杂度：$O(1)$。这里我们只使用了常数级别的数组空间。</p><h1 id="T2：雪糕的最大数量"><a href="#T2：雪糕的最大数量" class="headerlink" title="T2：雪糕的最大数量"></a>T2：<a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们的现金是固定的，而且我们可以按照任意的顺序去购买雪糕。</p><p>而且我们可以选择的仅有 $n$ 支雪糕，对于第 $i$ 支雪糕，我们要尽可能的选择定价更小的雪糕。只有我们每次都选择定价更小的雪糕，这样才可以买更多的雪糕。</p><p>所以我们可以对雪糕的定价进行排序，使得我们每次选择价格较小的雪糕。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        sort(costs.begin(), costs.end());</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cost : costs) &#123;</span><br><span class="line">            s += cost;</span><br><span class="line">            <span class="keyword">if</span> (s &lt;= coins) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p><p>空间复杂度：$O(1)$。</p><h1 id="T3：单线程-CPU"><a href="#T3：单线程-CPU" class="headerlink" title="T3：单线程 CPU"></a>T3：<a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</p><ul><li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态</li><li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 <strong>执行时间最短</strong> 的任务开始执行。</li><li>如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li><li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li><li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li></ul><p>具体实现：</p><ul><li>我们需要自定义一个数据结构来增强 $Task$，增加一个数组的下标</li><li>对于 $Task$ 数组，我们需要找出最早入队执行的任务，因此对 $Task$ 数组按照入队时间排序</li><li>我们还需要一个数据结构来模拟 CPU，可以使用 堆 实现<ul><li>对于堆中的任务，我们总是选择执行时间最短的任务开始执行</li><li>如果有多个执行时间相同的任务，我们选择下标最小的任务</li></ul></li><li>当 CPU空闲 / 堆为空 时，直接把开始执行小于等于时间戳的任务顺序入队</li><li>每次都执行一个任务，统计时间戳的累计时间</li><li>当我们把任务都入队时，即表示 CPU 可以按照顺序把任务执行完毕</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> ep;</span><br><span class="line">        <span class="keyword">int</span> pt;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            id = a;</span><br><span class="line">            ep = b;</span><br><span class="line">            pt = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getOrder(<span class="keyword">int</span>[][] t) &#123;</span><br><span class="line">        List&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = t.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> Task(i, t[i][<span class="number">0</span>], t[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按入队时间升序排序</span></span><br><span class="line">        Collections.sort(tasks, (t1, t2) -&gt; t1.ep - t2.ep);</span><br><span class="line">        PriorityQueue&lt;Task&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行时间相同，id 升序</span></span><br><span class="line">            <span class="keyword">if</span> (t1.pt == t2.pt) &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.id - t2.id;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行时间升序</span></span><br><span class="line">            <span class="keyword">return</span> t1.pt - t2.pt;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 时间戳</span></span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 把小于等于当前时间戳的任务都入队</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                heap.offer(tasks.get(i ++));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CPU 空闲</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty()) &#123;</span><br><span class="line">                now = (<span class="keyword">long</span>)tasks.get(i).ep;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                    heap.offer(tasks.get(i ++));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行一个任务</span></span><br><span class="line">            Task task = heap.poll();</span><br><span class="line">            ans[p ++] = task.id;</span><br><span class="line">            now += task.pt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有任务都进入 待执行状态，顺序执行即可</span></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            ans[p ++] = heap.poll().id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 表示任务的数量。</p><ul><li>我们对任务按照入队时间进行排序，时间复杂度 $O(NlgN)$。</li><li>在最坏的情况下，所有的任务都会进入 堆 中，此时堆的调整次数为 $N$ 次，每次调整的时间复杂度为 $O(lgN)$。因此时间复杂度为 $O(NlgN)$。</li></ul><p>空间复杂度：$O(N)$。最坏的情况下，我们建堆的空间和任务数量一致。</p><h1 id="T4：所有数对按位与结果的异或和"><a href="#T4：所有数对按位与结果的异或和" class="headerlink" title="T4：所有数对按位与结果的异或和"></a>T4：<a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>从 $arr1$ 中任意取一个数 $a$，从 $arr2$ 中任意取两个数 $b_1, b_2$，则有：<br>$$<br>\begin{align}<br>(a &amp; b_1) \bigoplus (a &amp; b_2) = &amp; [(a | \lnot b_1)&amp;(\lnot a | b_2)] | [(a | b_1) &amp; (\lnot a | \lnot b_2)] \\<br> = &amp; (\lnot a &amp; \lnot b_1 &amp; b_2) | (a &amp; b_1 &amp; \lnot b_2) \\<br> = &amp; a &amp; [(\lnot b_1 &amp; b_2) | (b_1 &amp; \lnot b_2)] \\<br> = &amp; a &amp; (b_1 \bigoplus b_2)<br>\end{align}<br>$$<br>推广到 $arr2$ 中的所有数 $0 \le i \le m$<br>$$<br>[(a &amp; b_1) \bigoplus (a &amp; b_2) \bigoplus (a &amp; b_3) … (a &amp; b_m)] = [a &amp; (b_1 \bigoplus b_2 \bigoplus b_3 \bigoplus … \bigoplus b_m)]<br>$$<br>同理，推广到 $arr1$ 中的所有的数 $0 \le i \le n$<br>$$<br>\begin{align}<br>[(a_1 &amp; b_1) \bigoplus (a_2 &amp; b_2) \bigoplus (a_3 &amp; b_3) \bigoplus … \bigoplus (a_i &amp; b_j)] = &amp; [[a_1 &amp; (b_1  \bigoplus … \bigoplus b_j)]  \bigoplus … \bigoplus [a_i &amp; (b_1  \bigoplus … \bigoplus b_j)]] \\<br>= &amp; [a_1 \bigoplus a_2 \bigoplus … \bigoplus a_i] &amp; [b_1 \bigoplus b_2 \bigoplus …\bigoplus b_j]<br>\end{align}<br>$$<br>因此，我们只需要分别计算 $s_1 = \sum_{i=0}^n xor(a[i])$ 和 $s_2 = \sum_{j=0}^m xor(b[j])$。再计算  $s_1 &amp; s_2$ 即为本题的答案。 </p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr1) s1 ^= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr2) s2 ^= n;</span><br><span class="line">        <span class="keyword">return</span> s1 &amp; s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n + m)$，其中 $n$ 和 $m$ 分别为数组 $arr1$ 和 $arr2$ 的长度。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/&quot;&gt; 判断句子是否为全字母句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="数组" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/%E5%A0%86/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/%E5%A0%86/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/tags/%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>第 236 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/12/w236/"/>
    <id>https://qybit.gitee.io/2021/04/12/w236/</id>
    <published>2021-04-12T07:23:07.000Z</published>
    <updated>2021-09-23T13:18:44.003Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></li><li> <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></li><li> <a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></li></ul><h1 id="T1：数组元素积的符号"><a href="#T1：数组元素积的符号" class="headerlink" title="T1：数组元素积的符号"></a>T1：<a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力即可，但是不建议直接对数组进行乘法操作，可能会爆 $int$ 甚至是 $64$ 位的整形。</p><p>我们只需要统计 负数 的存在个数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySign</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mask := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            mask ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mask % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。我们至多只会对数组扫描一遍。</p><p>空间复杂度：$O(1)$</p><h1 id="T2：找出游戏的获胜者"><a href="#T2：找出游戏的获胜者" class="headerlink" title="T2：找出游戏的获胜者"></a>T2：<a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一个裸的约瑟夫环问题。由于数据范围不大，所以直接模拟也是可行的</p><p>具体证明本文不再赘述，请参考博客：<a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环问题公式推导</a></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheWinner</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = (p + k) % i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为小伙伴的数量。</p><p>空间复杂度：$O(1)$</p><h1 id="T3：最少侧跳次数"><a href="#T3：最少侧跳次数" class="headerlink" title="T3：最少侧跳次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></h1><h2 id="方法一：BFS-求最短路"><a href="#方法一：BFS-求最短路" class="headerlink" title="方法一：BFS 求最短路"></a>方法一：BFS 求最短路</h2><h3 id="问题转换"><a href="#问题转换" class="headerlink" title="问题转换"></a>问题转换</h3><p>我们可以把赛道想象成一个 $3 \times n$ 的一个矩阵，我们从 $(2, 0)$ 点出发，问到达最后一列所需要的最短步长？</p><p>当然，我们这里的步长是指到达当前点 $(x, y)$ 时，我们跳跃的最小步数。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们在每次选择下一次的 ”落脚点“ 时，总是贪心的选择最少跳跃次数的点。因此，我们可以当作一个迪杰斯特拉的最短路算法。</p><p>注意点：我们在构建矩阵时，为了更好的判断障碍物，我们将会构建 $4 \times n$ 的矩阵。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, x, y;</span><br><span class="line">    <span class="comment">// 重载运算符 &lt;，表示构建小根堆。每次弹出堆的都是 d 最小的一个</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pos&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; p.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSideJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Pos&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> col = obstacles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> d = p.d;</span><br><span class="line">            <span class="comment">// 到达最后一列</span></span><br><span class="line">            <span class="keyword">if</span> (p.y == col - <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p.x + dx[i], y = p.y + dy[i];</span><br><span class="line">                <span class="comment">// 越界检查</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 下一个点是障碍物</span></span><br><span class="line">                <span class="keyword">if</span> (obstacles[y] == x) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dx[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果跳了，就消耗一步</span></span><br><span class="line">                    cost = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d + cost &lt; dist[x][y]) &#123;</span><br><span class="line">                    dist[x][y] = d + cost;</span><br><span class="line">                    pq.push(&#123;dist[x][y], x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(4 \times N)$，其中 $N$ 为障碍物的长度。</p><ul><li>我们在最坏的情况下，可能要对整个矩阵进行扫描。</li></ul><p>空间复杂度：$O(4 \times N)$，我们需要存储所有可能的点。</p><h1 id="T4：求出-MK-平均值"><a href="#T4：求出-MK-平均值" class="headerlink" title="T4：求出 MK 平均值"></a>T4：<a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>$Python$ 可以偷税暴力过</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, m: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.m = m</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addElement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.nums.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMKAverage</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &lt; self.m:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        last = self.nums[-self.m :]</span><br><span class="line">        last.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(mean(last[self.k : -self.k]))</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^2)$，其中 $calculateMKAverage$ 方法会调用 $10^5$ 次。每一次操作的数组最大长度也是 $10^5$。因此时间复杂度为 $O(N^2)$</p><p>空间复杂度：$O(N)$，我们要存储原数组和临时数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/&quot;&gt;数组元素积的符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https://l
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="BFS" scheme="https://qybit.gitee.io/tags/BFS/"/>
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="DP" scheme="https://qybit.gitee.io/tags/DP/"/>
    
      <category term="设计" scheme="https://qybit.gitee.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/tags/%E5%A0%86/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="队列" scheme="https://qybit.gitee.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实践-豆瓣TOP250</title>
    <link href="https://qybit.gitee.io/2021/04/07/doubantop250/"/>
    <id>https://qybit.gitee.io/2021/04/07/doubantop250/</id>
    <published>2021-04-07T13:33:06.000Z</published>
    <updated>2021-09-23T13:18:43.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集中 学习+复习 Go 语言有一个多星期了，也该写点东西了。</p><p>说下使用的 Go 语言的感受吧，直观上来说。Go 刚上手是比较反人类的，比如变量名和变量类型的位置是反着的，已经函数和方法的返回值的位置就更加的奇怪了。但是，总体的上手难度不是很大。相反，我认为这些也是 Go 的一大特色吧 (笑)。总体的学习门槛是比较低的，而且 Go 身上也有很多 C/C++ 的影子 (比如指针类型，还有结构体)。最让我感到意外的就是，Go 语言中的接口的设计，真正的做到了低耦合。因为只要任意一个结构体或者类型实现了接口中的方法后，就算是真正意义上的实现了一个接口。而当我们从代码里 “拿走” 这个接口时，是不会影响到实现了该接口的结构体或者类型，因为那只是它们的方法而已。</p><p>你可能会疑惑，为什么要从爬虫开始实践？</p><p>我认为兴趣是最好的老师，我不喜欢死板的去写 ”xxx通讯录管理系统“ 或者 ”xxx管理系统“ 之类的无聊 demo。我是兴趣驱动，我更愿意从爬虫入手去学习。</p><p>本来打算拿我的看家本领 Senlium 呢，结果到官网一查还不支持 Go。</p><p>好的，说的有点多了，下面开始我们的 Go 语言爬虫实践吧。</p><p>项目地址：<a href="https://github.com/qybit/doubantop250">项目地址</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>开发环境</p><ul><li>go version go1.16.2 windows/amd64</li><li>goland</li><li>第三方库 goquery（一个类似jQuery可以操作DOM的库）</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>结构体</li><li>函数 / 方法</li><li>http</li><li>懂得 DOM 编程，至少会 JavaScript 中的 DOM 部分</li><li>正则表达式</li><li> 异常处理</li><li>json</li><li>io 处理</li></ul><h2 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h2><p>我们的工作目录长这样👇。Movie 应该写成 movie 的，写 Java 写顺手了 (笑)。</p><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/doubantop250_0.png"></p><h2 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h2><p>作为一只合格的网络爬虫，我们必须要可以发起基本的 http 请求获得网页数据。</p><p>正规的网站，一般最基础的防御就是通过 User-Agent / Agent 字段的校验，来检测是不是真人用户操作。我们只需要在请求头中加入这一字段，把自己 “伪装” 成真人用户，具体内容可以在浏览器查看。这里不在赘述。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用获取的响应内容，构建-DOM-树"><a href="#使用获取的响应内容，构建-DOM-树" class="headerlink" title="使用获取的响应内容，构建 DOM 树"></a>使用获取的响应内容，构建 DOM 树</h2><p>这一步，我们将会使用 goquery 库，它会帮助我们把网络请求的响应内容解析成一颗 DOM 树。并提供和 JavaScript 和 jQuery 类似的 API 供我们访问某个节点。</p><p>这里的 content 实际上就是 响应的Body 部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析单个页面的所有电影内容"><a href="#解析单个页面的所有电影内容" class="headerlink" title="解析单个页面的所有电影内容"></a>解析单个页面的所有电影内容</h2><p>我们拿到上面生成的 goquery.Document 对象， goquery 提供的选择器的功能和 jQuery 几乎一模一样。所以有过 jQuery 使用经验的话，上手 goquery 是非常容易的。这里的稍微麻烦点的就是我们处理字符串的时候。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">movie := &amp;entity.Movie&#123;</span><br><span class="line">Title:    title,</span><br><span class="line">Subtitle: subtitle,</span><br><span class="line">Other:    other,</span><br><span class="line">Cover:    cover,</span><br><span class="line">Desc:     desc,</span><br><span class="line">Year:     year,</span><br><span class="line">Area:     area,</span><br><span class="line">Tag:      tag,</span><br><span class="line">Star:     star,</span><br><span class="line">Comment:  comment,</span><br><span class="line">Quote:    quote,</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>这里将会调用上面的所有方法，然后根据用户输入的信息，进行决策。</p><p>比如从哪一页开始获取，以及是否需要持久化等</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   content, err := fetchSinglePageContent(URL, start)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   dom, err := generatorDomTree(content)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   books, err := parseSinglePage(dom)</span><br><span class="line">   <span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">      fmt.Println(book)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      data, _ := json.Marshal(books)</span><br><span class="line">      err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/toubantop250.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module qybit.com/doubantop250</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require github.com/PuerkitoBio/goquery v1<span class="number">.6</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="entiy-包"><a href="#entiy-包" class="headerlink" title="entiy 包"></a>entiy 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span> <span class="string">`json:&quot;title&quot;`</span><span class="comment">// 中文名</span></span><br><span class="line">Subtitle <span class="keyword">string</span> <span class="string">`json:&quot;subtitle&quot;`</span><span class="comment">// 英文名</span></span><br><span class="line">Other    <span class="keyword">string</span> <span class="string">`json:&quot;other&quot;`</span><span class="comment">// 港澳台翻译名</span></span><br><span class="line">Cover    <span class="keyword">string</span> <span class="string">`json:&quot;cover&quot;`</span><span class="comment">// 电影封面</span></span><br><span class="line">Desc     <span class="keyword">string</span> <span class="string">`json:&quot;desc&quot;`</span><span class="comment">// 描述</span></span><br><span class="line">Year     <span class="keyword">string</span> <span class="string">`json:&quot;year&quot;`</span><span class="comment">// 上映年份</span></span><br><span class="line">Area     <span class="keyword">string</span> <span class="string">`json:&quot;area&quot;`</span><span class="comment">// 属于哪个国家</span></span><br><span class="line">Tag      <span class="keyword">string</span> <span class="string">`json:&quot;tag&quot;`</span><span class="comment">// 属于哪一类型的电影</span></span><br><span class="line">Star     <span class="keyword">string</span> <span class="string">`json:&quot;star&quot;`</span><span class="comment">// 评分</span></span><br><span class="line">Comment  <span class="keyword">string</span> <span class="string">`json:&quot;comment&quot;`</span><span class="comment">// 参与评分的人数</span></span><br><span class="line">Quote    <span class="keyword">string</span> <span class="string">`json:&quot;quote&quot;`</span><span class="comment">// 宣传标语</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spider-包"><a href="#spider-包" class="headerlink" title="spider 包"></a>spider 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spider</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/PuerkitoBio/goquery&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;qybit.com/doubantop250/entity&quot;</span></span><br><span class="line"><span class="string">&quot;regexp&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">URL          <span class="keyword">string</span> = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span></span><br><span class="line">DefaultCover <span class="keyword">string</span> = <span class="string">&quot;https://img.imgdb.cn/item/601fdca33ffa7d37b326de61.jpg&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">movie := &amp;entity.Movie&#123;</span><br><span class="line">Title:    title,</span><br><span class="line">Subtitle: subtitle,</span><br><span class="line">Other:    other,</span><br><span class="line">Cover:    cover,</span><br><span class="line">Desc:     desc,</span><br><span class="line">Year:     year,</span><br><span class="line">Area:     area,</span><br><span class="line">Tag:      tag,</span><br><span class="line">Star:     star,</span><br><span class="line">Comment:  comment,</span><br><span class="line">Quote:    quote,</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">content, err := fetchSinglePageContent(URL, start)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">dom, err := generatorDomTree(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">books, err := parseSinglePage(dom)</span><br><span class="line"><span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">fmt.Println(book)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">data, _ := json.Marshal(books)</span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> k <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= page; i++ &#123;</span><br><span class="line">parseOnePage(strconv.Itoa(k), i, ok)</span><br><span class="line">k += <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;qybit.com/doubantop250/spider&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;请输入要爬取的页数，最大10页：&quot;</span>)</span><br><span class="line">cin := bufio.NewScanner(os.Stdin)</span><br><span class="line">cin.Scan()</span><br><span class="line">page, err := strconv.Atoi(cin.Text())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;输入数据不合法，请按照要求输入！&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot;是否需要持久化？（请输入 yes/y 或者 no/n）&quot;</span>)</span><br><span class="line">cin.Scan()</span><br><span class="line">ok := cin.Text()</span><br><span class="line">isOk := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> ok == <span class="string">&quot;yes&quot;</span> || ok == <span class="string">&quot;y&quot;</span> &#123;</span><br><span class="line">isOk = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">spider.Run(page, isOk)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;集中 学习+复习 Go 语言有一个多星期了，也该写点东西了。&lt;/p&gt;
&lt;p&gt;说下使用的 Go 语言的感受吧，直观上来说。Go 刚上手是比较反
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
      <category term="Go" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/Go/"/>
    
    
      <category term="Go" scheme="https://qybit.gitee.io/tags/Go/"/>
    
      <category term="爬虫" scheme="https://qybit.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>第 235 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/05/259/"/>
    <id>https://qybit.gitee.io/2021/04/05/259/</id>
    <published>2021-04-05T06:00:31.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></li><li><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></li><li><a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></li></ul><h1 id="T1：截断句子"><a href="#T1：截断句子" class="headerlink" title="T1：截断句子"></a>T1：<a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></h1><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不同单词之间是按照空格隔开的，因此我们统计空格数量即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">truncateSentence</span><span class="params">(s <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cnt <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            cnt ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == k &#123;</span><br><span class="line">            <span class="keyword">return</span> s[:i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(\sum)$，其中 $\sum$ 为前 $k$ 个单词的长度。</p><p>空间复杂度：$O(1)$，我们只使用了常数的空间</p><h1 id="T2：查找用户活跃分钟数"><a href="#T2：查找用户活跃分钟数" class="headerlink" title="T2：查找用户活跃分钟数"></a>T2：<a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></h1><p>典型的阅读理解</p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先看看我们要返回的答案到底是什么。</p><p>$answer[j] (1 \le j \le k )$ 表示 <strong>用户活跃分钟数</strong>  等于 $j$ 的用户数。老谜语人了，其实说白了就是：<strong>一个用户总共的活跃分钟数恰好等于 $j$ 的人数</strong>。</p><p>另外，一个用户在同一个分钟可以活跃多次，也就是说我们还要处理去重。</p><p>我们的解决方法很简单，使用 哈希表 即可实现去重。</p><p>那么，还存在一个问题，如何知道一个用户一共活跃了多少次呢？</p><p>我们仍然可以使用 哈希表 来实现，那么这就是一个嵌套的 哈希表 结构，如果不熟练这样的写法的话，说明基础语法还有待加强。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findingUsersActiveMinutes</span><span class="params">(logs [][]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, log := <span class="keyword">range</span>(logs) &#123;</span><br><span class="line">        id, time := log[<span class="number">0</span>], log[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> _, ok := count[id]; !ok &#123;</span><br><span class="line">            count[id] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        count[id][time] = INF </span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> _, cnt := <span class="keyword">range</span>(count) &#123;</span><br><span class="line">        ans[<span class="built_in">len</span>(cnt) - <span class="number">1</span>] ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><ul><li>我们会遍历一次数组，收集所有用户的活跃信息</li><li>我们还会遍历一次哈希表，这个取决于存在的用户数量，用户数量最大不会超过数组长度。</li><li>因此我们的最终时间复杂度为 $O(2\times N) = O(N)$</li></ul><p>空间复杂度：$O(N)$，我们会存储所有用户的信息</p><h1 id="T3：绝对差值和"><a href="#T3：绝对差值和" class="headerlink" title="T3：绝对差值和"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></h1><h2 id="方法一：排序-二分查找"><a href="#方法一：排序-二分查找" class="headerlink" title="方法一：排序 + 二分查找"></a>方法一：排序 + 二分查找</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目定义：</p><p>绝对差值和：$\sum_{i=0}^n |nums1[i] - nums2[i]|$</p><p>再搞清楚我们的目的：我们可以选用 $nums1$ 中的任意一个元素替换 $nums1$ 中的至多一个元素，使得绝对值差和最小化。</p><p>具体做法：</p><ol><li>我们可以预先计算好未 <strong>替换</strong> 元素前的绝对值差</li><li>尝试 <strong>替换</strong> 操作，我们在 $nums1$ 中找到一个<strong>最逼近</strong> $nums2[i]$ 的一个元素<ol><li>快速查找的话，我们可以想到二分查找，因此需要对 $nums1$ 进行排序操作</li><li>对于 $nums2$ 中的每一个元素，都尝试查找元素值相近的一个下标 $p$</li><li>替换完毕后，计算 $nums1[p] - nums2[i]$ 的最小值，这样可以说明两个元素很相近</li><li>再计算出偏移量 $shrink$ ，使得 $shrink$ 的值最大化，这样可以使得 绝对值差和 最小。</li></ol></li><li>我们第一步已经计算好了 <strong>未替换</strong> 元素的绝对值差，第二步我们模拟了 <strong>替换</strong> 操作后，找出了偏移量最大的替换方案，直接减去即可。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>值得注意的是，在 $Go$ 中 $int$ 默认是 $64$ 位的，因此其他语言在实现的过程中，建议使用 $64$ 位的整型变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums1)</span><br><span class="line">    cnt := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">var</span> ans, shrink <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cnt[i] = abs(nums1[i] - nums2[i])</span><br><span class="line">        ans += cnt[i]</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(nums1)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cost := cnt[i]</span><br><span class="line">        <span class="keyword">var</span> delta <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// p 是nums1中对应元素大于等于 nums2[i] 的一个下标</span></span><br><span class="line">        p := lowerBound(nums1, nums2[i])</span><br><span class="line">        <span class="comment">// fmt.Println(p)</span></span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 可能越界。</span></span><br><span class="line">            <span class="keyword">if</span> p == n &#123;</span><br><span class="line">                p --</span><br><span class="line">            &#125;</span><br><span class="line">            delta = min(abs(nums1[p] - nums2[i]), abs(nums1[p - <span class="number">1</span>] - nums2[i])) </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delta = abs(nums1[p] - nums2[i])</span><br><span class="line">        &#125;</span><br><span class="line">        shrink = max(shrink, abs(cost - delta))</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= shrink</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找出大于等于 x 的下标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= x &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p><ul><li>我们遍历一次数组预计算出未替换前的绝对值差和，时间复杂度 $O(N)$</li><li>对数组进行排序操作，$Go$ 实现的排序为快速排序时间复杂度为 $O(NlgN)$</li><li>我们会遍历 $nums2$ 数组，对于$nums2$ 数组中的任意一个元素都尝试去 $nums1$ 中找出一个最逼近的元素，二分查找的时间复杂度为 $O(lgN)$，因此总的时间复杂度为 $O(NlgN)$</li></ul><p>空间复杂度：$O(N)$，我们要存储未替换前的绝对值差。</p><h1 id="T4：序列中不同最大公约数的数目"><a href="#T4：序列中不同最大公约数的数目" class="headerlink" title="T4：序列中不同最大公约数的数目"></a>T4：<a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></h1><h2 id="方法一：数学"><a href="#方法一：数学" class="headerlink" title="方法一：数学"></a>方法一：数学</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们不必去找这个子序列，然后计算出最大公约数 $g$，我们直接枚举最大公约数 $g$ 去构造这个子序列。</p><p>假设一个数组存在最大公约数 $g$ ，那么数组中的任意一个元素都是最大公约数 $g$ 的倍数。</p><p>我们在构造这个子序列的过程中，选择的最大公约数 $g$ 的倍数必须存在于数组中，否则就不能称之为子序列。</p><p>具体做法：</p><ul><li>首先确定最大公约数 $g$ 的范围，设 $m$ 为数组 $nums$ 的最大值。那么 $1 \le g \le m$</li><li>我们假设最大公约数 $x (1 \le x \le m)$ ，然后枚举出所有不大于 $m$ 且存在与数组 $nums$ 中的所有 $x$ 的倍数 $y$ 。当且仅当所有 $y$ 的最大公约数等于 $x$ 时，说明我们找到一个可行的 子序列。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> vis []<span class="keyword">bool</span> = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> y := x; y &lt;= m; y += x &#123;</span><br><span class="line">        <span class="keyword">if</span> vis[y] &#123;</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span> &#123;</span><br><span class="line">                t = y</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = gcd(t, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局遍历存在干扰，使用之前必须重置</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    vis = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span>(nums) &#123;</span><br><span class="line">        m = max(m, v)</span><br><span class="line">        vis[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> check(i) &#123;</span><br><span class="line">            ans ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n^2)$，其中 $n$ 为数组 $nums$ 中的最大值。</p><p>空间复杂度：$O(n)$，其中 $n$ 为数组 $nums$ 中的最大值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/truncate-sentence/&quot;&gt;截断句子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/probl
      
    
    </summary>
    
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%91%A8%E8%B5%9B/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%91%A8%E8%B5%9B/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="二分" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="哈希" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Spring IoC 容器</title>
    <link href="https://qybit.gitee.io/2021/04/03/Spring-IoC/"/>
    <id>https://qybit.gitee.io/2021/04/03/Spring-IoC/</id>
    <published>2021-04-03T12:13:32.000Z</published>
    <updated>2021-09-23T13:18:44.001Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 中最重要的就是 IoC 和 AOP，我们平时使用 Spring 最多的就是 IoC，那么为啥不去深入了解一下其中的原理呢？本篇作为 Spring IoC 源码探究的文章之一，后续有机会的话将会更新 Spring MVC、MyBatis 等源码探究。</p><p>阅读本篇时，请打开 IDE 和我一起深入 IoC 容器内部的工作环境，了解 IoC 的实现细节。</p><p>本文的着重点在于 </p><ol><li><p>Bean 容器的创建；</p></li><li><p>Bean 的实例化和初始化 </p></li></ol><p>如有不足之处，欢迎讨论。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>基本的 Spring 5.3.1 运行环境</li><li>支持断点调试的 IDE</li><li>本文选择从 xml 配置文件启动</li></ol><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开始分析代码之前，先看一下基本的一个架构图</p><p><img src="https://img.imgdb.cn/item/5fd4cb8a3ffa7d37b3513ae3.png"></p><p>基本的启动代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserController controller = applicationContext.getBean(<span class="string">&quot;userController&quot;</span>, UserController.class);</span><br><span class="line">    controller.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件 （接口或者类，请任意定义一个即可）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.qybit.spring.controller.UserController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>从 <code> ApplicationContext applicationContext = new ClassPathXmlApplicationContext(...);</code> 可以发现，我们是从 xml 文件加载的，而且是可以传入多个配置文件。</p><h1 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h1><p>进入 ClassPathXmlApplicationContext 类中，发现定义为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">// 这是我们 Spring 启动的一个核心方法</span></span><br><span class="line">            <span class="comment">// 下面我们会深入其内部，逐个分析各个方法具体做了什么</span></span><br><span class="line">            refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext#refresh 方法，refresh 方法是构建 ApplicatinContext 的，当一个 IoC 容器成功创建后，我们还可以调用 refresh 方法销毁原来的 ApplicationContext，然后进行重建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保证构建当前 ApplicationContext 的完整性，不能有别的线程干扰</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 不是重点，不管它</span></span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备 refresh，记录启动时间，设置激活状态</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是将 配置文件 中定义的 bean 标签，解析成 BeanDefition，然后注册到 BeanFactory</span></span><br><span class="line">        <span class="comment">// 此时仅仅是对 Bean 的定义信息的一个保存，而不是实例化操作</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的类加载，添加 BeanPostProcessor</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">            <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 BeanPostProcessor 的实现类，</span></span><br><span class="line">            <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">            <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i18n 国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 AppplicationContext 事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 钩子函数</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册事件监听器，需要实现 ApplicationListener 接口</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有的 Singleton Bean  lazy-init 除外</span></span><br><span class="line">            <span class="comment">// 核心</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一步，广播事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 日志记录</span></span><br><span class="line">            <span class="comment">// 销毁已经创建的 Bean</span></span><br><span class="line">            <span class="comment">// 撤销状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐个介绍 refresh() 方法里的重要方法</p><h2 id="refresh-的准备工作"><a href="#refresh-的准备工作" class="headerlink" title="refresh 的准备工作"></a>refresh 的准备工作</h2><p>看看代码就可以知道做了哪些事情</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验配置文件</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Bean-容器，并注册-Bean"><a href="#创建-Bean-容器，并注册-Bean" class="headerlink" title="创建 Bean 容器，并注册 Bean"></a>创建 Bean 容器，并注册 Bean</h2><p>回到 refresh() 方法中的 obtainFreshBeanFactory() 方法。</p><p>这一步是初始化 Bean 容器，并注册保存 Bean 的信息。这也是本文重点讨论的一个方法。注意此步并没有实例化 Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果存在过 BeanFactory就先销毁，然后创建新的 BeanFactory，加载 Bean 定义，注册 Bean等</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回新创建的 BeanFactory</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext#refreshBeanFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 假设存在过 BeanFactory，先销毁</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 BeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 设置 序列化 ID</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 自定义 BeanFactory，设置：是否允许 Bean 重写，是否允许循环引用</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载 Bean 定义</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext#customizeBeanFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否允许 Bean 重写</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否允许循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractXmlApplicationContext#loadBeanDefinitions</p><p>加载 Bean 信息</p><p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还在当前类中，我们已经实例化了 Reader，接下来是要把 xml 文件转换成一颗 DOM 树，用于获取用户定义的 Bean。</p><p>// AbstractXmlApplicationContext</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 下面逐个记载所有的配置文件</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 走到下面这一步</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        count += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向下走</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Collections.addAll(actualResources, resources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 320</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ThreadLocal 存放文件资源</span></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正执行的方法</span></span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类 386 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 转换成 DOM 树</span></span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// 开始注册</span></span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        ....</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 508 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 真正执行的方法</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 94 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 128 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    .......</span><br><span class="line">        <span class="comment">// 钩子函数</span></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">    <span class="comment">// 从 根节点 开始解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 钩子函数</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过漫长的寻找，我们找到了 parseBeanDefinitions(root, this.delegate) 最终的解析方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">// 默认的</span></span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他的</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看默认中处理 <code>&lt;bean /&gt;</code> 标签的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前文件 305 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p><table><thead><tr><th>Property</th><th></th></tr></thead><tbody><tr><td>class</td><td>类的全限定名</td></tr><tr><td>name</td><td>可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td>scope</td><td>作用域</td></tr><tr><td>constructor arguments</td><td>指定构造参数</td></tr><tr><td>properties</td><td>设置属性的值</td></tr><tr><td>autowiring mode</td><td>no(默认值)、byName、byType、 constructor</td></tr><tr><td>lazy-initialization mode</td><td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td>initialization method</td><td>bean 属性设置完成后，会调用这个方法</td></tr><tr><td>destruction method</td><td>bean 销毁后的回调方法</td></tr></tbody></table><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>// BeanDefinitionParserDelegate 428</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">    <span class="comment">// 当然，如果不定义 name 属性的话，就是空的了</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                        beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                        !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们开始说说注册 Bean 吧。</p><h2 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h2><p>// BeanDefinitionReaderUtils 158</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">// 注册这个 Bean</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">            <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>// DefaultListableBeanFactory 976</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不支持重写，将会报错</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">              <span class="comment">// log </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               <span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">        <span class="comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">        <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line">            <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">            <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">            <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">            <span class="comment">//registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">            <span class="comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h2 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h2><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">        beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略实现下面接口的实现类</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationStartup.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “手动注册的类”</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理。</p><h2 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h2><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p><p>// AbstractApplicationContext.java 834</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">    <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 初始化 所有的非懒加载 beans</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                            getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理普通的 bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">    <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.beans.smart-initialize&quot;</span>)</span><br><span class="line">                .tag(<span class="string">&quot;beanName&quot;</span>, beanName);</span><br><span class="line">            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">            smartInitialize.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将会进入到 getBean(beanName); 方法里了。</p><h2 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个 beanName</span></span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经创建过了</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">// log...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是获取 bean,直接返回</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// 已经创建过相同的 bean ，说明陷入了循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否存在 BeanDefintion</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，检查 父容器</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 typeCheckOnly 为 false, 会被放入 alreadyCreated 集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">            .tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">            &#125;</span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">            <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">// 检查是否存在依赖循环</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 先注册依赖的 bean</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取到 bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 重要方法</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">// 执行创建</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查创建的类型</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是 createBean(beanName, mbd, args); 方法了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保 BeanDefintion 中的 class 已经被加载</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备方法重写</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 正式开始要创建 bean 了！！</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-bean"><a href="#创建-bean" class="headerlink" title="创建 bean"></a>创建 bean</h2><p>跨越千山万水，我们终于找到了 doCreateBean 这个方法。请持续保持 debug 状态，我们将继续深入方法内部。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 的包装类</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是 bean 包装类中的真正 实例bean</span></span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">// bean 的类型</span></span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要解决 循环依赖 问题，可以了解一下 三级缓存 机制</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 bean ，上面仅仅是 实例化，还没有对属性进行赋值等操作</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化 bean 后的回调函数，比如 init-method 方法的执行</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就看完了创建 bean 的部分，下面将会重点介绍一下 实例化bean 和 初始化bean 的部分。我们仅仅是稍微瞄一眼即可，再深层次的细节，本人能力有限也分析不动。</p><h2 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h2><p>这一步是将之前注册和保存的 beanDefintion 给实例化成对象的过程。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="comment">// 检查访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">    <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="comment">// 构造函数注入</span></span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无参构造函数</span></span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="comment">// 构造函数注入</span></span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挑个简单的无参构造函数构造实例来看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(</span><br><span class="line">                (PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>),</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化</span></span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 包装返回</span></span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的重点在于这一行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这是实例化的地方，我们进去看看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">        <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这一步走完，我们的bean就算完成了实例化。下面看看初始化的过程</p><h2 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h2><p>这一步会对 bean 的属性进行赋值，以及钩子函数(init-method)的执行等操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">            <span class="comment">// 如果没有实例化成功</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口 InstantiationAwareBeanPostProcessors 后，可以在这一步执行</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bean 实例的所有属性都在这</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">        <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过类型匹配</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">            <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值</span></span><br><span class="line">            PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                &#125;</span><br><span class="line">                pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line">        checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h2><p>属性注入完毕后，就开始执行各种回调函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">        <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring 在设计之初，就给我们留下了非常多的可扩展部分，比如 BeanFactoryPostProcessor 可以在注册 BeanDefintion 时，对 BeanDefintion 进行增强或者加入新的 Bean定于。以及 BeanPostProcessor 接口，可以在分别在实例化和初始化后进行执行相应的方法。<br>FactoryBean 在本文就不再继续讨论下去了，感兴趣的可以自行测试。<br>本文的不足之处在于限于个人能力，以及篇幅的限制，很多地方都没有深入展开的进行说明。这也算是给自己挖了个坑，后面有精力再补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring 中最重要的就是 IoC 和 AOP，我们平时使用 Spring 最多的就是 IoC，那么为啥不去深入了解一下其中的原理呢？本篇作为 Spring IoC 源码探究的文章之一，后续有机会的话将会更新 Spring MVC、MyBatis 等源码探究。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="Java" scheme="https://qybit.gitee.io/tags/Java/"/>
    
      <category term="IoC" scheme="https://qybit.gitee.io/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>第 234 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/03/259/"/>
    <id>https://qybit.gitee.io/2021/04/03/259/</id>
    <published>2021-04-03T02:56:21.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></li><li> <a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></li><li> <a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></li></ul><p>换电脑(原来的破电脑显示屏不亮了。)导致题解丢失，这是重写的一份。┭┮﹏┭┮</p><h1 id="T1：字符串中不同整数的数目"><a href="#T1：字符串中不同整数的数目" class="headerlink" title="T1：字符串中不同整数的数目"></a>T1：<a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接模拟截取数字部分即可，注意前导 $0$ 。</p><p>不可以转成数字 $int$ 或者 $long$ 等 64 位的整形数字，可能会爆掉。因此直接使用字符串即可。</p><p>$Go$ 语言中并不存在 $Set$ 集合，因此我们在使用 $Map$ 时，给 $Value$ 随便赋一个值即可。这里取得 $0x3f3f3f3f$ 意义为“无限大”。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isDigit</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDifferentIntegers</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    st := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> isDigit(word[i]) &#123;</span><br><span class="line">            <span class="keyword">var</span> num []<span class="keyword">byte</span></span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; word[i] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; isDigit(word[i]) &#123;</span><br><span class="line">                num = <span class="built_in">append</span>(num, word[i])</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            st[<span class="keyword">string</span>(num)] = INF</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(st)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。我们只会扫描一次字符串。</p><p>空间复杂度：$O(\sum)$ ，其中 $\sum$ 表示数字集的大小。</p><h1 id="T2：还原排列的最少操作步数"><a href="#T2：还原排列的最少操作步数" class="headerlink" title="T2：还原排列的最少操作步数"></a>T2：<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>纯模拟题</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reinitializePermutation</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    perm := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        perm[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> flag <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> flag &#123;</span><br><span class="line">        ans ++</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                arr[i] = perm[i / <span class="number">2</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i] = perm[n / <span class="number">2</span> + (i - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(arr) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            perm[i] = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(k \times N)$ ，其中 $k$ 为最小执行次数，$N$ 为数组的长度。</p><p>空间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><h1 id="T3：替换字符串中的括号内容"><a href="#T3：替换字符串中的括号内容" class="headerlink" title="T3：替换字符串中的括号内容"></a>T3：<a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不存在嵌套的括号，因此我们可以直接遍历字符串当遇到一个 $()$ 时，截取 $()$ 内的内容，然后到 $knowledge$ 数组里找到对应的 $Value$ 即可。</p><p>直接在 $knowledge$ 里查找 $Value$ 的时间复杂度是 $O(N)$ 的，$N$ 为 $knowledge$ 数组的长度。因此，我们可以要尽可能的优化这一步的时间复杂度操作。</p><p>不难想到使用 哈希表 来实现 $O(1)$ 查找。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(s <span class="keyword">string</span>, knowledge [][]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, kn := <span class="keyword">range</span>(knowledge) &#123;</span><br><span class="line">        hash[kn[<span class="number">0</span>]] = kn[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> j <span class="keyword">int</span> = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j &lt; n &amp;&amp; s[j] != <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">                j ++</span><br><span class="line">            &#125;</span><br><span class="line">            k := s[i + <span class="number">1</span>:j]</span><br><span class="line">            <span class="keyword">if</span> key, ok := hash[k]; ok &#123;</span><br><span class="line">                ans += key</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="string">&quot;?&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += <span class="keyword">string</span>(s[i])</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。</p><p>空间复杂度：$O(N)$，其中 $N$ 为 $knowledge$ 数组的长度。</p><h1 id="T4：好因子的最大数目"><a href="#T4：好因子的最大数目" class="headerlink" title="T4：好因子的最大数目"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></h1><p>非常复杂的一道题，了解结论的话很容易做。</p><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>我们需要构造一个数 $x$ ，它的质因子数量最大不会超过 $primeFactors$ 个。</p><p>好因子：我们必须从这个数 $x$ 的 $n$ 个不同质因子 $a_i(1 \le i \le n)$，并假设其数量分别对应为 $b_i(1 \le i \le n)$。</p><p>举例子：比如当 $x = 200$，$primeFactors = 5$ 时，</p><p>存在一个满足的条件的质因子数组：$[2,2,2,5,5]$ ，其中质因子一共有两种，分别是 $a_1=2$ 和 $a_2=5$ ，它们的数量分别为 $b_1=3$ 和 $b_2=2$。</p><p>根据题目定义，我们在构造<strong>好因子</strong>的过程中，对于每一个质因子 $a_i$ 就必须选择 $b_i$ 个。</p><p>对于质因子 $a_1=2$ 而言，我们必须要拿 $1 \le b_1 \le 3$ 个，对于质因子 $a_2=5$ 也是同理 $1 \le b_2 \le 2$。 </p><p>我们开始构造<strong>好因子</strong>：</p><p>$b_1= 1, b_2=1$ 时，好因子数量：$[10]$</p><p>$b_1=2, b_2=1$ 时，好因子数量：$[10,20]$</p><p>$….$</p><p>注意到，当 $b_1 = 3$ 和 $b_2 = 2$ ，我们可以构造出 $b_1 \times b_2 =6$ 个好因子。分别为 $[10, 20,40,50,100,200]$ 。</p><h3 id="整理一下"><a href="#整理一下" class="headerlink" title="整理一下"></a>整理一下</h3><p>对于 $n$ 个质因子 $a_i$ 及其数量 $b_i$：<br>$$<br>a_1, \ a_2, \ a_3, \ a_4, \ …, \ a_n<br>$$<br>对于质因子的数量 $b_i$：<br>$$<br>b_1 + b_2 + b_3 + b_4 + … + b_n = primeFactors<br>$$</p><p>对于 $x$ ：<br>$$<br>a_1^{b_1} \times a_2^ {b_2} \times a_3^{b_3} \times…\times a_n^{b^n} = x<br>$$<br>对于最大的 <strong>好因子</strong> 数量：<br>$$<br>b_1 \times b_2 \times b_3 \times … \times b_n = ans<br>$$</p><p>我们可以得出一个结论：<strong>把一个数分出更多的质因子数量，使得它们数量的乘积尽可能的大，这样我们就可以构造出更多的好因子。</strong></p><p>此时，请思考一个问题？</p><blockquote><p>我们应该选择哪一个 质因子 才可以使一个数划分出更多份？</p></blockquote><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p><strong>函数极值证明法</strong></p><p>我们假设 $f(x)$ 为一个正整数 $n$ 按照 $x$ 划分时的最大乘积，则有 $x$ 项  $\frac{n}{x}$。即 $f(x) = x ^\frac{n}{x}$。</p><p>目标是求 $f(x)$ 的最大值，我们可以将式子变形一下：<br>$$<br>f(x) = x^\frac{n}{x} = e^{\frac{n \times lnx}{x}}<br>$$<br>令 $g(t) = e ^t$ ，$h(x) = \frac{lnx}{n}$ ，那么 $f(x) = g(n \times h(x))$，由于 $g(t)$ 是单调递增的，$n \gt 0$，所以 $f(x)$ 与 $h(x)$ 单调性相同。</p><p>我们计算 $h(x)$ 的驻点，$h’(x) = \frac{1 - lnx}{x^2} = 0$，得到 $x = e$ 。</p><p>得到驻点 $x = e$，当 $0 \lt x \lt e$ 时， $h’(x) \gt 0$ ，所以在 $0 \lt x \lt e$ 时，$h(x)$ 是单调递增的。</p><p>当 $x \gt e$ 时，$h’(x) \lt 0$ ，所以在 $x \gt e$ 时，$h(x)$是单调递减的。由此可知 $x = e$ 为 $h(x)$ 和 $f(x)$ 的极大值点。由于 $f(x)$ 在定义域连续，因此 $x =e $ 为 $f(x)$ 的最大值点。</p><p>那么， $e = 2.71…$ 并不是一个正整数，因此我们还需要比较 $f(2)$ 和 $f(3)$ 的大小，直接计算 $f(2) / f(3)$ 的值即可。<br>$$<br>\frac{f(2)}{f(3)} = \frac{e^{\frac{nln2}{2}}}{e^{\frac{nln3}{3}}} = e ^ {\frac{nln2}{2} - \frac{nln3}{3}} = e ^ \frac{n \times ln8-ln9}{6}<br>$$<br>由于 $ln8 \lt ln9$，$n &gt; 0$ ，所以 $f(2) \lt f(3)$ 。因此当 $x = 3$ 时，$f(x)$ 可以取得最大值。</p><p>上述过程为正整数 $n$ 可以整除 $3$ 时，当不够整除时，我们还需要用 $2$ 来凑。</p><p>因此，我们对于 $n$ 和 $3$ 的余数进行讨论：</p><ul><li>当余数为0时，即$n = 3m (m \ge 2)$，将 $n$ 拆分成 $m$ 个 $3$</li><li>当余数为1时，即$n = 3m+1 (m \ge 1)$ ，由于$2\times2 \gt 3 \times 1$，所以将 $n$ 拆分成 $m - 1$ 个 $3$ 和 $2$ 个 $2$</li><li>当余数为2时，即$n=3m+2(m \ge 1)$，将 $n$ 拆分成 $m$ 个 $3$ 和 $1$ 个 $2$</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>上述证明，我们以及得知当一个正整数 $x$ 按照 $3$ 拆分，然后补充 $2$ 时，可以使得其数量的乘积最大。也就是可以构造更多的好因子数量。</p><p>那么，对于本题已经给出了质因子的数量，我们反向冲一下，就可以求出最大值 $x$ ，也就是本题的答案。</p><p>注意由于 $n$ 的范围相当的大，因此在快速幂的过程中需要边取模边运算，否则会爆数据范围。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_pow</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> y &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ret *= x</span><br><span class="line">            ret %= MOD</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x</span><br><span class="line">        x %= MOD</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % MOD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxNiceDivisors</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m, quot <span class="keyword">int</span> = n / <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> quot == <span class="number">0</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> quot == <span class="number">1</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m) * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(lgN)$，其中 $N$ 最大为 $10^9$ 。</p><p>空间复杂度：$O(1)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/&quot;&gt;字符串中不同整数的数目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a hre
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="哈希表" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动技术支持实习面经</title>
    <link href="https://qybit.gitee.io/2021/04/01/1024/"/>
    <id>https://qybit.gitee.io/2021/04/01/1024/</id>
    <published>2021-04-01T07:18:59.000Z</published>
    <updated>2021-09-23T13:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔试：-3-7"><a href="#笔试：-3-7" class="headerlink" title="笔试： 3.7"></a>笔试： 3.7</h2><p><strong>T1</strong>：给定一个数组，对于数组中的每一个元素为，打印出数组中下一个更大的数，如果没有下一个更大的数，则打印-1。<br><strong>思路</strong>：单调栈。由于数据范围很小，所以暴力即可。</p><p><strong>T2</strong>：N 个小朋友围成一圈，你可以调整任意两个小朋友的位置。使得相邻小朋友的最大身高差的值最小。<br><strong>思路</strong>：单调栈</p><p><strong>T3</strong>：你现在是一名图书管理员，你可以处理两种指令。<br>指令格式如下：</p><ol><li><p><code>1 x y</code> 表示可以将图书x和图书y放在同一个书架上。</p></li><li><p><code>2 x y</code> 表示图书x和图书y不能放在同一个书架。</p></li></ol><p>现存在一个用户，向你提供了 $N$ 条指令。并询问这些指令的执行情况。<br>输出格式：</p><ol><li>如果所有指令，都可以正常执行，输出 YES</li><li>如果不能全部执行，且不能执行的 2 号指令，恰好为 3 条，请输出 3</li><li>请输出不能执行的指令数量</li></ol><p><strong>思路</strong>：并查集模板题，如果用数组模拟的话，数据范围很大 $10^9$ 直接就报错了。我认为改用 $unorderd_map$ 后理论上和数组是一致的，但是实际操作时忘记初始化了(我是SB)。</p><p><strong>T4</strong>：变态版 <a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a> (可以查看<a href="https://qybit.gitee.io/2021/03/20/72/">我的题解</a>)。</p><p>本题是给定不定长的字符串，要求从任意一个节点出发，经过若干次操作后可以变化的最大步长。<br><strong>思路</strong>：BFS（求最大步长），DP（DP效率似乎不怎么好，我在牛客上看的反馈还没我BFS过的多）</p><h2 id="一面-3-23-60mins"><a href="#一面-3-23-60mins" class="headerlink" title="一面 3.23 60mins"></a>一面 3.23 60mins</h2><ol><li>自我介绍</li><li>用过哪些集合？</li><li>说说 ArrayList、HashSet 和 HashMap 的常用方法。</li><li>你刚刚说ArrayList的底层是数组，那么我们为什么不使用数组？</li><li>说说ArrayList的扩容机制？具体是如何扩容的？</li><li>ArrayList 和 HashSet 的区别？</li><li>你用 HashSet 都存放过哪些数据类型？你是如何写这个自定义对象的？</li><li>为什么要重写 hashcode 和 equals 方法？</li><li>我看你用的是 MySQL，MySQL 和 Redis的区别？，说说 MySQL 的存储引擎吧？它们有什么区别？</li><li>你知道事务吗？说说事务的四大特性？</li><li>说说事务的隔离级别？</li><li>你都用过哪些数据类型？char 和 varchar 的区别是什么？</li><li>Redis有哪些数据类型？</li><li>说说 Spring 的事务。</li><li>你使用 MyBatis 是怎么写 SQL 语句的？</li><li>你写的 mapper 文件里都用过哪些标签，是怎么写的？</li><li>定义的 mapper 接口中的方法是如何执行的？</li><li>做题：<ol><li>统计数字的出现次数；</li><li>反转链表</li></ol></li><li>说说 static 和 final 关键字</li><li>JAVA虚拟机的内存模型是怎样的？（不是JAVA程序的运行内存模型）</li><li>类是如何加载的？</li><li>说说栈内存和堆内存，什么是栈帧？</li><li>假如遇到深层次的递归函数，会发生什么事情？你是如何解决的？</li><li>你遇到过 OOM 吗？你是如何解决的？</li><li>反问环节</li></ol><h2 id="二面：3-26-25mins"><a href="#二面：3-26-25mins" class="headerlink" title="二面：3.26 25mins"></a>二面：3.26 25mins</h2><ol><li>  自我介绍</li><li>介绍岗位工作职责</li><li>介绍项目</li><li>描述项目细节</li><li>MVC 软件架构了解吗？</li><li>反馈说上一面表现不错</li><li>做题：<ol><li>给定一个按钮，点击修改其内容</li><li>使用调试工具，比如 Postman 调用 API</li><li>手撕快速排序</li><li>反转字符串，空间 $O(1)$</li></ol></li><li>  如果一个网页，打开很慢的话，说说可能的原因？</li><li>  get 和 post 请求的区别。</li><li>  说说 http 和 https 的区别。</li><li>  说说三次握手和四次挥手。</li><li>  写一个 sql 语句吧，查询表中 100 个 id 大于 10 的记录。</li><li>  今天的面试就到这里了，你已经通过了，等 HR 电话吧。</li><li>  反问环节</li></ol><h2 id="HR面：3-30-20mins"><a href="#HR面：3-30-20mins" class="headerlink" title="HR面：3.30 20mins"></a>HR面：3.30 20mins</h2><ol><li>   HR自我介绍（我以为是技术面）</li><li>询问成绩</li><li>介绍项目</li><li>你为什么选择前端专业？</li><li>我看你是前端专业，为什么要选择后端？</li><li>关于在留心科技实验室当前端组长的一些问题</li><li>你为什么选择上海和杭州这两个城市？</li><li>你从出生到现在感受到最为挫折的一次经历？</li><li>   你未来的规划是怎么样的？</li><li>   你为什么选择字节跳动？你有投递其它公司吗？</li><li>   什么时候可以来实习？你能实习多久？</li><li>   同学和老师对你的评价中最多的关键词</li><li>   反问环节</li></ol><h2 id="已-OC：4-1"><a href="#已-OC：4-1" class="headerlink" title="已 OC：4.1"></a>已 OC：4.1</h2><p>最后是催着 HR 小姐姐给发的offer。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;笔试：-3-7&quot;&gt;&lt;a href=&quot;#笔试：-3-7&quot; class=&quot;headerlink&quot; title=&quot;笔试： 3.7&quot;&gt;&lt;/a&gt;笔试： 3.7&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;T1&lt;/strong&gt;：给定一个数组，对于数组中的每一个元素为，打印出数组中下一个更
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="字节跳动" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>第 48 场双周赛</title>
    <link href="https://qybit.gitee.io/2021/03/21/259/"/>
    <id>https://qybit.gitee.io/2021/03/21/259/</id>
    <published>2021-03-21T02:58:00.000Z</published>
    <updated>2021-09-23T13:18:44.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></li><li> <a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></li><li> <a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/"> N 次操作后的最大分数和</a></li></ul><h1 id="T1：字符串中第二大的数字"><a href="#T1：字符串中第二大的数字" class="headerlink" title="T1：字符串中第二大的数字"></a>T1：<a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></h1><p>注意到，这里给出的混合字符串中的数字，仅仅是指 $0-9$ 之间的数字。</p><p>方法一：我们使用有序的 $set$ 集合，插入后取倒数第二个元素即可。</p><p>$Java$ 中使用 $TreeSet$ 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                st.insert(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = st.end();</span><br><span class="line">        it --, it --;</span><br><span class="line">        <span class="keyword">return</span> *(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。</p><p>空间复杂度：$O(1)$，其中 $set$ 集合，使用的空间最大仅为 $10$ 个元素。</p><h1 id="T2：设计一个验证系统"><a href="#T2：设计一个验证系统" class="headerlink" title="T2：设计一个验证系统"></a>T2：<a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目描述非常的长。实际上，我们只需要关注如下信息即可。</p><ul><li>$tokenId$ 具有唯一性，且数据级别是 $N$ ，那么我们的查找时间复杂度就尽可能的要满足 $O(1)$，不难想到哈希表</li><li>$token$ 的存活时间为 $currentTime + timeToLive$，我们在进行查询存活数量时，只需要检查当前时间是否小于存活时间即可</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// int[] life = &#123;live -&gt; dead&#125;</span></span><br><span class="line">    <span class="keyword">int</span> liveTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthenticationManager</span><span class="params">(<span class="keyword">int</span> timeToLive)</span> </span>&#123;</span><br><span class="line">        liveTime = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        map.put(tokenId, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;currentTime, currentTime + liveTime&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(tokenId)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] life = map.get(tokenId);</span><br><span class="line">        <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">            <span class="comment">// 还没死</span></span><br><span class="line">            life[<span class="number">0</span>] = currentTime;</span><br><span class="line">            life[<span class="number">1</span>] = currentTime + liveTime;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(tokenId, life);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, <span class="keyword">int</span>[]&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] life = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为 $Map$ 中所有 $tokenId$ 的数量</p><ul><li><code>AuthenticationManager#generate</code> 操作时间复杂度为 $O(1)$</li><li><code>AuthenticationManager#renew</code> 操作时间复杂度为 $O(1)$</li><li><code>AuthenticationManager#countUnexpiredTokens</code> 操作时间复杂度为 $O(N)$，我们需要遍历 $Map$ 集合。</li></ul><p>空间复杂度：$O(N)$</p><h1 id="T3：你能构造出连续值的最大数目"><a href="#T3：你能构造出连续值的最大数目" class="headerlink" title="T3：你能构造出连续值的最大数目"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></h1><h2 id="方法一：数学推导"><a href="#方法一：数学推导" class="headerlink" title="方法一：数学推导"></a>方法一：数学推导</h2><p>我们对数组进行排序，使得我们选择下一个元素时，尽可能的接近。</p><p>子问题：</p><p>假如连续整数为 $[0, 0]$ ，那么下一个元素必须满足为 $coins[0] \le 1$ ，才能保证整数连续。</p><p>归纳：</p><ul><li>对于连续整数 $[0, 1]$，那么 $coins[1] \le 2$ 使得整数为 $[0, 1 + coins[1]]$才能保证整数连续。</li><li>对于连续整数 $[0, x]$，那么 $coins[i] \le x + 1$ 使得整数为 $[0, x + coins[i]]$ 才能保证整数连续。</li></ul><p>证明：</p><p>假设前 $i$ 个元素已经构成连续整数 $[0, n]$ ，且下一个数为 $m$ 时：</p><p>若 $m &gt; n + 1$ 时，此时可以构成的整数分别为 $[0, n]$ ， $[m, m + n + 1]$ 。存在 $m \gt n + 1 \gt n$。则整数不连续。</p><p>因此要想整数连续递增，必须保证 $m \le n + 1$，使得整数连续为 $[0, n + m + 1]$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        sort(coins.begin(), coins.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + <span class="number">1</span> &lt; coin) <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">            now += coin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlogN)$，其中 $N$ 为数组长度。</p><p>空间复杂度：$O(logN)$</p><h1 id="T4：N-次操作后的最大分数和"><a href="#T4：N-次操作后的最大分数和" class="headerlink" title="T4：N 次操作后的最大分数和"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/">N 次操作后的最大分数和</a></h1><h2 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h2><p>首先看看题目是如何定义第 $i$ 次操作（$i$ 从 <strong>1</strong> 开始）：</p><ul><li>选择两个元素 $x$ 和 $y$</li><li>获得分数 $i \times gcd(x, y)$</li><li>删除 $x$ 和 $y$</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>我们也不必再关注 $nums$ 数组本身，因为我们的分数计算实际上是 $ i \times gcd(x,y)$，即与 $x$ 和 $y$ 的<strong>最大公约数和操作次数</strong>有关的。因此，我们可以<strong>预处理</strong> $nums$ 数组所有下标 $i$ 和 $j$ 的组合对应的最大公约数。</p><p>我们需要选择任意两个元素，也就是任意两个未使用过的下标，直到用完所有的操作次数。</p><p>那么，我们就可以尝试所有可能的起点，并使用一个 $path$ 数组记录我们选择元素对应的最大公约数。</p><p>当我们的操作数全部用完时，对选择的最大公约数进行排序处理（因为并没有限制操作的顺序），使得 <strong>较大的操作次数 * 较大的最大公约数</strong> 来获得最大的分数。</p><h3 id="具体实现如下："><a href="#具体实现如下：" class="headerlink" title="具体实现如下："></a>具体实现如下：</h3><p>对于任意一次操作 $i$ ，我们有：</p><ul><li>选择一个从未使用过的下标作为元素 $x$，对应下标为 $s$</li><li>再选择一个从未使用过的下标作为元素 $y$，对应下标为 $u$</li><li>我们将其对应的最大公约数 $g[s][u]$ 加入到 $path$ 数组</li><li>当我们的操作次数使用完毕时，此时 $path$ 数组中已经存在 $n / 2$ 个元素，我们获得分数的理念是 <strong>较大的操作次数 * 较大的最大公约数</strong> 。因此对 $path$ 进行备份，然后排序计算此轮获得的最大分数并更新<strong>历史最大值</strong>。</li><li>我们再回溯到选择元素 $y$ 的场景。此时我们将不再选择元素 $y$ ，将下标 $u$ 标记为未使用。如果没有元素可供选择时。</li><li>我们再次回溯到选择元素 $x$ 的场景。与选择元素 $y$ 同理。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1e9</span>; <span class="comment">// 历史最大值</span></span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">20</span>]; <span class="comment">// 标记数组</span></span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">// 预处理 最大公约数</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">// 数组长度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q, path; <span class="comment">// q 为 nums 备份，path 为选择路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = path;</span><br><span class="line">            sort(t.begin(), t.end());</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &gt;&gt; <span class="number">1</span>; i ++) &#123;</span><br><span class="line">                res += (i + <span class="number">1</span>) * t[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                s = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        used[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[u]) &#123;</span><br><span class="line">                used[u] = <span class="literal">true</span>;</span><br><span class="line">                path.push_back(g[s][u]);</span><br><span class="line">                dfs(cnt + <span class="number">1</span>);</span><br><span class="line">                used[u] = <span class="literal">false</span>;</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        used[s] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        n = nums.size();</span><br><span class="line">        q = nums;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                g[i][j] = g[j][i] = gcd(nums[i], nums[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q.begin(), q.end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N^2 + N!)$，其中 $N$ 为数组的长度。</p><ul><li>我们需要预处理 $nums$ 数组</li><li>回溯的时间复杂度大致是这个级别，推测出来的量级</li></ul><p>空间复杂度：$O(N^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/second-largest-digit-in-a-string/&quot;&gt;字符串中第二大的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="哈希表" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="回溯" scheme="https://qybit.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="设计" scheme="https://qybit.gitee.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="动态规划" scheme="https://qybit.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="递归" scheme="https://qybit.gitee.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>72. 编辑距离</title>
    <link href="https://qybit.gitee.io/2021/03/20/72/"/>
    <id>https://qybit.gitee.io/2021/03/20/72/</id>
    <published>2021-03-20T05:09:15.000Z</published>
    <updated>2021-09-23T13:18:43.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>我们要求 $word1$ 变成 $word2$ 的最少操作次数。</p><p>操作如下：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>基本指导思想，对于 $word1$ 中所有的下标，我们尝试所有可能的操作，期望可以达到 $word2$ 。但是这样的时间复杂度将会达到 指数级。因此是不可能通过本题的。但我们也可以使用记忆化的方式优化。</p><h2 id="方法一：DFS-剪枝"><a href="#方法一：DFS-剪枝" class="headerlink" title="方法一：DFS + 剪枝"></a>方法一：DFS + 剪枝</h2><p>使用两个指针分别为 $i$ 和 $j$ ，分别指向 $word1$ 和 $word2$ ，我们借助指针的移动来对 $word1$ 模拟上述的 $3$ 种操作。</p><p>这里我们可以假设 $word1[0, i-1]$ 的字符 和 $word2[0, j-1]$ 已经完全相等了，此时我们的指针分别指向 $word1$ 的第 $i$ 个字符 和 $word2$  和 第 $j$ 个字符。 对于下述的操作，我们始终是在 <strong>操作</strong> $word1$ 。</p><p>具体实现如下：</p><ul><li>当 $word1[i] = word2[j]$ 时，我们同时移动指针 $i$ 和 $j$ 向右一位。</li><li>当 $word1[i] \neq word2[j]$ 时：<ul><li>当我们选择 【删除】时，我们移动指针 $i$ 向右一位。这里实际上对于 $word1$ 而言是 【跳过】 当前字符，让 $word1$ 的下一个字符和 $word2$ 的第 $j$ 个字符得以匹配相等，而在 $word2$ 看来，我们好像是多了一个字符。因此对于 $word2$ 而言，$word2$ 是多了一个字符。</li><li>当我们选择 【插入】时，我们移动指针 $j$ 向右一位。实际上对于 $word2$ 而言是 【跳过】当前字符，让 $word2$ 的下一个字符和 $word1$ 的第 $i$ 个字符得以匹配相等。对于 $word2$ 同理，在 $j$ 的位置进行 $word2$  的 【删除】操作。</li><li>当我们选择 【替换】时，实际上是和 $word1[i] = word2[j]$ 情况一致的。我们把指针 $i$ 和 $j$ 同时向右移动一位。</li></ul></li><li>在指针 $i$ 和 $j$ 没有把 $word1$ 或者 $word2$ 扫描完毕之前，我们重复上述操作。</li><li>当任意一个指针到达字符串末尾时，即说明我们存在一个方案使得 $word1 = word2$，。因为对于任意一个 $i (0 \le i \le word1.length, j同理)$ ，我们都存在最多可以有 $3$ 种选择分支。因此，我们需要在 【删除】、【插入】和【替换】三种操作取最小值。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>由上述搜索的思路，我们可以发现。虽然我们可能的操作一共是 $6$ 种。但是对于 $word1$ 的【删除】操作，等效于对 $word2$ 进行【插入】操作。所以我们的最终操作方案实际上是 $3$ 种。</p><ul><li>$word1$ 的【插入】操作，等效于 $word2$ 的【删除】操作</li><li>$word1$ 的【删除】操作，等效于 $word2$ 的【插入】操作</li><li>$word1$ 的【替换】操作，等效于 $word2$ 的【替换】操作。</li></ul><p>公式化描述：</p><p>前提条件是，$word1[0, i-1]$ 和 $word2[0, j-1]$ 已经完全相等了。$f(i, j)$ 表示 $word1$ 的前 $i (0 \le i \le word1.length)$ 个字符转变成 $word2$ 前 $j(0 \le j \le word2.length)$ 个字符所需的最小操作次数。那么存在<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>PS：不相等时，加 $1$ 是因为我们选择了任意一个操作。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> word1, <span class="keyword">int</span> i, <span class="built_in">string</span> word2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= word1.size() || j &gt;= word2.size()) &#123;</span><br><span class="line">            mem[i][j] = word1.size() - i + word2.size() - j;</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">            mem[i][j] = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> increased = dfs(word1, i, word2, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> deleted = dfs(word1, i + <span class="number">1</span>, word2, j);</span><br><span class="line">        <span class="keyword">int</span> modify = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">        mem[i][j] = min(increased, min(deleted, modify)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">        <span class="keyword">return</span> dfs(word1, <span class="number">0</span>, word2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(3^{max{n, m}})$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p><ul><li>但是由于我们存在缓存数组，因此时间复杂度是远远小于这个级别的。具体的时间复杂度我也没有办法分析。</li></ul><p>空间复杂度：$O(n \times m)$，我们要缓存字符串所有可能状态的最小操作数。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>由上一步，我们通过 【自顶向下】的一顿分析，递推出来的式子。进行改造<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>我们需要注意的点，就是边界问题，也就是当 $i=0$ 或者 $j = 0$ 时，当任意一个字符串为空串时，我们的改变次数等于不为空的字符串的长度。</p><p>我们的动态规划转移公式仍然定义为： $f[i][j]$，表示 $word1[0,i]$ 与 $word2[0,j]$ 完全相等的最小操作次数。 </p><p>因此，动态规划的转移方程为：</p><ul><li>当 $word1[i] = word2[j]$ ，$f[i][j] = f[i-1][j-1]$，相等时，不需要任何操作。</li><li>当 $word1[i] \ne word2[j]$，$f[i][j] = min{f[i-1][j], f[i-1][j-1], f[i][j-1]} + 1$，我们从三种操作中，选择最小的一种进行一次操作。</li></ul><p>解释：</p><ul><li>$f[i-1][j]$ 表示将 $word1[0, i -1]$ 的第 $i$ 个字符【删除】后，使得 $word1[0,i] = word2[0, j]$</li><li>$f[i-1][j-1]$ 表示将 $word1[0,i-1]$ 的第 $i$ 个字符进行【修改】后，使得 $word1[0,i] = word2[0,j]$</li><li>$f[i][j-1]$ 表示在 $word1[0,i]$ 【插入】一个字符后，使得 $word1[0, i] = word2[0,j]$</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.size(), m = word2.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) </span><br><span class="line">            f[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) </span><br><span class="line">            f[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j], min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n \times m)$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p><p>空间复杂度：$O(n \times m)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;我们要求 $word1$ 变成 $word2$ 的最少操作次数。&lt;/p&gt;
&lt;p&gt;操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="DP" scheme="https://qybit.gitee.io/tags/DP/"/>
    
      <category term="DFS" scheme="https://qybit.gitee.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>第 232 场周赛</title>
    <link href="https://qybit.gitee.io/2021/03/15/w232/"/>
    <id>https://qybit.gitee.io/2021/03/15/w232/</id>
    <published>2021-03-15T02:56:07.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/">仅执行一次字符串交换能否使两个字符串相等</a></li><li> <a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">找出星型图的中心节点</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li></ul><h1 id="T1：仅执行一次字符串交换能否使两个字符串相等"><a href="#T1：仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="T1：仅执行一次字符串交换能否使两个字符串相等"></a>T1：<a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/">仅执行一次字符串交换能否使两个字符串相等</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于数据范围比较小，$1 \le s1.length, s2.length \le 100$，我们可以直接暴力的枚举字符串 $s1$ 或者 字符串 $s2$ 的交换字符的下标，然后再判断是否相等即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAlmostEqual</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="keyword">if</span> (s2.size() != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                swap(s1[i], s1[j]);</span><br><span class="line">                <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                swap(s1[i], s1[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^3)$ ，其中 $N$ 为字符串 $s1$ 或者 $s2$ 的长度。</p><ul><li>字符串的下标交换方式一共存在 $N^2$ 种，我们每一次交换都需要判断字符串 $s1$ 和 $s2$ 是否相等。</li><li>判断字符串是否相等，只能遍历两字符串。因此时间复杂度一共为 $O(N^3)$。</li></ul><p>空间复杂度：$O(1)$</p><h1 id="T2：找出星型图的中心节点"><a href="#T2：找出星型图的中心节点" class="headerlink" title="T2：找出星型图的中心节点"></a>T2：<a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">找出星型图的中心节点</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一：dfs"><a href="#方法一：dfs" class="headerlink" title="方法一：dfs"></a>方法一：dfs</h3><p>直接对给定的边，建图进行 dfs，遍历。</p><p>从某一个节点出发，找到一个可以到达所有的节点的点。</p><p>时间复杂度为 $O(N^2)$，空间复杂度为 $O(N^2)$</p><h3 id="方法二：建图优化"><a href="#方法二：建图优化" class="headerlink" title="方法二：建图优化"></a>方法二：建图优化</h3><p>我们不必去写繁杂的 dfs 代码，建图的过程中我们可以选择 <strong>邻接矩阵</strong>，存储图。然后遍历每一行，判断该行与其他列，是否都存在边。</p><p>时间复杂度为 $O(N^2)$，空间复杂度为 $O(N^2)$</p><h3 id="方法三：统计每个点的度数"><a href="#方法三：统计每个点的度数" class="headerlink" title="方法三：统计每个点的度数"></a>方法三：统计每个点的度数</h3><p>我们甚至都不必去存储所有的图的节点信息，我们可以注意到<strong>星型图</strong>的中心节点，是与所有的点都存在边，当我们找到<strong>某个点的度数等于边数</strong>时，即表示该点为中心节点。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCenter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.size() + <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deg</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>];</span><br><span class="line">            deg[a] ++, deg[b] ++;</span><br><span class="line">            <span class="keyword">if</span> (deg[a] == n) <span class="keyword">return</span> a;</span><br><span class="line">            <span class="keyword">if</span> (deg[b] == n) <span class="keyword">return</span> b; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == edges.size()) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N)$，其中 $N$ 为点的数量。</p><p>空间复杂度：$O(N)$。</p><h1 id="T3：最大平均通过率"><a href="#T3：最大平均通过率" class="headerlink" title="T3：最大平均通过率"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></h1><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>对于某一个班级 $calsses[i] = [x_i, y_i]$ 而言，其原本的通过率为 $\frac{x}{y}$。那么我们加入一个保证能够过线学生后，存在<br>$$<br>\theta =  \frac{x + 1}{y + 1} - \frac{x}{y}，\theta (0 \lt \theta \lt1) \ 表示添加学生后，通过率增长幅度<br>$$<br>当我们在该班级继续加入学生后，存在<br>$$<br>\theta_1 = \frac{x_2 + 1}{y_2 + 1} - \frac{x_1}{y_1}， \<br>\theta_2 = \frac{x_4 + 1}{y_4 + 1} - \frac{x_3}{y_3}， \<br>\theta_2 \gt \theta_1<br>$$<br>即班级的通过率是单调递增的。</p><p>当某个班级的通过率呈现最大化后，即表示所有班级的平均通过率最大。</p><p>贪心的体现为：</p><p>当所有的班级都呈现通过率 $\theta$ 单调递增时，假设我们现在将一个学生加入班级，那么我们需要在 $N$ 个班级中，快速选择出一个 $\theta$ 最大的班级(借助堆优化)。这样就可以使所有班级的平均通过率最大。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> w;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((x + <span class="number">1.0</span>) / (y + <span class="number">1.0</span>)) - ((<span class="keyword">double</span>)x / y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Node&gt; heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : classes) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[<span class="number">0</span>], y = c[<span class="number">1</span>];</span><br><span class="line">            ans += (<span class="keyword">double</span>)x / y;</span><br><span class="line">            heap.push(&#123;cal(x, y), x, y&#125;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (extraStudents --) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            ans += t.w;</span><br><span class="line">            <span class="keyword">int</span> x = t.a + <span class="number">1</span>, y = t.b + <span class="number">1</span>;</span><br><span class="line">            heap.push(&#123;cal(x, y), x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / classes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N logN)$，其中 $N$ 表示为额外添加的学生数量。</p><ul><li>我们需要预处理所有的班级，计算出最初始的增长幅度，然后加入到 <strong>堆</strong> 中维护。时间复杂度 $O(NlogN)$</li><li>我们要把这些额外的学生，分别都加入到 <strong>堆顶</strong> 的第一个班级里去，并且重新计算增长幅度。时间复杂度 $O(NlogN)$</li></ul><p>空间复杂度：$O(N)$，我们使用结构体存储班级，并维护额外的信息。</p><h1 id="T4：好子数组的最大分数"><a href="#T4：好子数组的最大分数" class="headerlink" title="T4：好子数组的最大分数"></a>T4：<a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/">好子数组的最大分数</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h2 id="方法二：双指针-贪心"><a href="#方法二：双指针-贪心" class="headerlink" title="方法二：双指针 + 贪心"></a>方法二：双指针 + 贪心</h2><p>子数组的定义为： $min{ nums[i], nums[i+1],…,nums[j]} \times (j - i + 1)$。且满足 $i \le k \le j$。</p><p>算法实现流程：</p><ul><li>我们直接以下标 $k$ 为可能区间 $[i, j]$ 的中心点，然后分别以指针 $left$, 指令 $right$ 左右扩展<ul><li>当 $ left &gt;= 0 \ 时 \ nums[k] \le nums[left]$，指针 $left$ 恒向左扫描。</li><li>当 $right &lt; n \ 时 \ nums[k] \le nums[right]$，指针 $right$ 恒向右扫描。</li><li>当 指针 $left \lt 0 \ 且 \ right \gt n$ 时，表示我们已经扫描完整个数组。</li><li>当 $left \ge 0 \ 且 \ right \lt n$ ， 表示我们还未扩展到边界，为了求得最大值，我们以左右边界中任意一个最大值，作为中心点继续扩展。</li><li>当 $left \lt 0$ ，表示左边界已经没有元素，将右边界定义为中心点。</li><li>当 $right \ge n$ ，表示右边界已经没有元素，同理。</li><li>我们循环上述操作，直至在数组中找到一个最小值，然后扩展至整个数组后退出。</li></ul></li></ul><p>贪心的体现：</p><p>当我们扫描到边界值时 (且满足 $left \ge 0 \ 或 \ right \lt n$)，我们会在左右边界选择一个最大值，作为新区间的中心点。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = k, r = k, mi = nums[k];</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; nums[r] &gt;= nums[k]) r ++;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l] &gt;= nums[k]) l --;</span><br><span class="line">            ans = max(ans, (r - l - <span class="number">1</span>) * nums[k]);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span> &amp;&amp; r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n) nums[k] = max(nums[l], nums[r]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">0</span>) nums[k] = nums[r];</span><br><span class="line">            <span class="keyword">else</span> nums[k] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><ul><li>对于数组中的元素任意一个元素，我们在最坏的情况下，都不会访问达到 $N$ 次。</li></ul><p>空间复杂度：$O(1)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/&quot;&gt;仅执行一次字符串交换能否使两个字符串相等&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="图" scheme="https://qybit.gitee.io/tags/%E5%9B%BE/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>10. 正则表达式匹配</title>
    <link href="https://qybit.gitee.io/2021/03/11/259/"/>
    <id>https://qybit.gitee.io/2021/03/11/259/</id>
    <published>2021-03-11T14:24:52.000Z</published>
    <updated>2021-09-23T13:18:43.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一：递归-双指针"><a href="#方法一：递归-双指针" class="headerlink" title="方法一：递归 + 双指针"></a>方法一：递归 + 双指针</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于只存在 <code>.</code> 的字符，我们很容易去判断字符串 $p$ 是否可以匹配 $s$。</p><p>对于 <code>*</code> 字符，我们必须结合前一个字符来判断是否可以完成匹配。</p><p>具体实现：</p><ul><li>使用两个指针 $i$  和 $j$，分别指向字符串 $s$ 和 字符串 $p$。当字符串 $p$ 匹配完毕时，若指针 $i$ 未能走完整个字符串 $s$ ，那么表示当前路径不能成功匹配字符串 $s$ 。</li><li>对于特殊字符  <code>.</code>  和 <code>*</code> 而言，我们必须分情况讨论：<ul><li>对于单个字符而言，当 $s[i] = p[j]$ 时，或者 $p[j] = ‘.’$  时，此时我们是可以正常匹配的，我们还需要存储当前的结果，因为我们下一个字符可能是 <code>*</code></li><li>如果下一个字符为 <code>*</code> 时，我们必须要联系字符串 $s$ 的前一个字符，因此我们这里有两种选择方式：<ul><li>我们可以使用 <code>*</code>  ，将指针 $i$ 移动到下一位，去匹配下一个<strong>相同的</strong>字符。</li><li>还有就是跳过这个 <code>*</code> ，我们将指针 $j$ 移动两位，跳过 <code>*</code>。选择不匹配</li></ul></li><li>如果当前指针 $j$ 的下一个字符并不是 <code>*</code> 时，我们可以尝试去同时移动指针 $i$ 和 指针 $j$，当指针 $j$ 走完时，即停止递归。</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>PS：时空复杂度实际上我并不会分析，只知道这个递归的时间复杂度非常之大。<strong>C++</strong> 是直接超时的。<strong>Java</strong> 在力扣由于没有记录 <strong>JVM</strong> 的启动时间，所以是可以骗过的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) </span><br><span class="line">            <span class="keyword">return</span> i == s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> first = i &lt; s.length() &amp;&amp; (p.charAt(j) == <span class="string">&#x27;.&#x27;</span> || s.charAt(i) == p.charAt(j));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j)) || dfs(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O((n + m) \times 2 ^ {n + m})$，其中 $n$ 和 $m$ 分别为字符串 $s$ 和 字符串 $m$ 的长度。</p><ul><li>我们至少需要遍历完字符串 $s$ 和 字符串 $p$ 。</li><li>对于存在 <code>*</code> 的情况下，我们存在两个递归路径，而每一个递归路径都必须等待指针 $j$  或者指针 $i$ 扫描完毕才可以退出。</li></ul><p>空间复杂度：$O(1)$，我们使用双指针递归操作，并没有使用额外的存储空间。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>添加备忘录似乎可以减轻时间上的复杂度</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        <span class="keyword">if</span> (j == p.size()) <span class="keyword">return</span> i == s.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> first = i &lt; s.size() &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.size() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            mem[i][j] = (first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j)) || dfs(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        mem[i][j] = first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>C++</strong> 也能通过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一：递归-双指针&quot;&gt;&lt;a href=&quot;#方法一：递归-双指针&quot; class=&quot;headerlink&quot; title=&quot;方法一：递归 + 双指针&quot;&gt;&lt;/a&gt;方法一：递归 + 双指针&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="dfs" scheme="https://qybit.gitee.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类的加载机制</title>
    <link href="https://qybit.gitee.io/2021/03/10/JVM_CHAPTER7/"/>
    <id>https://qybit.gitee.io/2021/03/10/JVM_CHAPTER7/</id>
    <published>2021-03-10T02:25:27.000Z</published>
    <updated>2021-09-23T13:18:44.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【转载】"><a href="#【转载】" class="headerlink" title="【转载】"></a>【转载】</h2><p>本文作者<strong>：</strong><a href="https://www.cnblogs.com/kylinxxx/p/13778513.html">WMS</a><br><strong>本文链接</strong>：<a href="https://www.cnblogs.com/kylinxxx/p/13778513.html">https://www.cnblogs.com/kylinxxx/p/13778513.html</a><br><strong>关于博主</strong>：评论和私信会在第一时间回复。或者<a href="https://msg.cnblogs.com/msg/send/kylinxxx">直接私信</a>我。<br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">BY-NC-SA</a> 许可协议。转载请注明出处！<br><strong>声援博主</strong>：如果您觉得文章对您有帮助，可以点击文章右下角<strong>【<a href="javascript:void(0);">推荐</a>】</strong>一下。您的鼓励是博主的最大动力！</p><h1 id="虚拟机类的加载机制"><a href="#虚拟机类的加载机制" class="headerlink" title="虚拟机类的加载机制"></a>虚拟机类的加载机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类的加载机制。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？</p><ul><li>主动引用<ul><li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：<ul><li>使用 new 实例化对象；</li><li>读取或设置一个类的 static 字段（被 final 修饰的除外）；</li><li>调用类的静态方法。</li></ul></li><li>对类进行反射调用；</li><li>初始化一个类时，其父类还没初始化（需先初始化父类）；<ul><li>这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。</li></ul></li><li>虚拟机启动，先初始化包含 main() 函数的主类；</li><li>JDK 1.7 动态语言支持：一个 <code>java.lang.invoke.MethodHandle</code> 的解析结果为 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>。</li></ul></li><li>被动引用<ul><li>通过子类引用父类静态字段，不会导致子类初始化；</li><li><code>Array[] arr = new Array[10]</code>; 不会触发 Array 类初始化；</li><li><code>static final VAR</code> 在编译阶段会存入调用类的常量池，通过 <code>ClassName.VAR</code> 引用不会触发 ClassName 初始化。</li></ul></li></ul><p>也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。</p><hr><blockquote><p>类的生命周期</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/reprint/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png"></p><hr><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><blockquote><p>加载</p></blockquote><p><strong>加载（Loading）</strong>阶段，虚拟机需要完成以下三件事：</p><ul><li>通过一个类的全限定名来获取定义这个类对应的二进制字节流</li><li>将这个类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这些数据的访问入口。</li></ul><blockquote><blockquote><p>分类</p></blockquote></blockquote><ul><li>非数组类<ul><li>系统提供的引导类加载器</li><li>用户自定义的类加载器</li></ul></li><li>数组类<ul><li>不通过类加载器，由 Java 虚拟机直接创建</li><li>创建动作由 newarray 指令触发，new 实际上触发了 [L全类名 对象的初始化</li><li>规则<ul><li>数组元素是引用类型<ul><li>加载：递归加载其组件</li><li>可见性：与引用类型一致</li></ul></li><li>数组元素是非引用类型<ul><li>加载：与引导类加载器关联</li><li>可见性：public</li></ul></li></ul></li></ul></li></ul><blockquote><blockquote><p>类的显式加载和隐式加载</p></blockquote></blockquote><ul><li>显示加载：<ul><li>调用 <code>ClassLoader#loadClass(className)</code> 或 <code>Class.forName(className)</code>。</li><li>两种显示加载 .class 文件的区别：<ul><li><code>Class.forName(className)</code> 加载 class 的同时会初始化静态域，<code>ClassLoader#loadClass(className)</code> 不会初始化静态域；</li><li><code>Class.forName</code> 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。</li></ul></li></ul></li><li>隐式加载：<ul><li>new 类对象；</li><li>使用类的静态域；</li><li>创建子类对象；</li><li>使用子类的静态域；</li><li>其他的隐式加载，在 JVM 启动时：<ul><li><code>BootStrapLoader</code> 会加载一些 JVM 自身运行所需的 Class；</li><li><code>ExtClassLoader</code> 会加载指定目录下一些特殊的 Class；</li><li><code>AppClassLoader</code> 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。</li></ul></li></ul></li></ul><blockquote><p>验证</p></blockquote><p>目的： 确保 .class 文件中的字节流信息符合虚拟机的要求。</p><p>4 个验证过程：</p><ul><li>文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” 0xCAFEBABE<ul><li>魔数：每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的class文件。</li></ul></li><li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析）</li><li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）</li><li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验</li></ul><p>这个操作虽然重要，但不是必要的，可以通过 <code>-Xverify:none</code> 关掉。</p><blockquote><p>准备</p></blockquote><p>描述： 为 static 变量在方法区分配内存。</p><ul><li>static 变量准备后的初始值：<ul><li>public static int value = 123;<ul><li>准备后为 0，value 的赋值指令 putstatic 会被放在 <code>&lt;clinit&gt;()</code> 方法中，<code>&lt;clinit&gt;()</code>方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。</li></ul></li><li>public static final int value = 123;<ul><li>准备后为 123，因为被 static final 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。</li></ul></li></ul></li></ul><blockquote><p>解析</p></blockquote><p>描述： 将常量池中的 “符号引用” 替换为 “直接引用”。</p><p>在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。</p><blockquote><blockquote><p>什么是 “符号引用” 和 “直接引用” ？</p></blockquote></blockquote><ul><li>符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。</li><li>直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。</li></ul><blockquote><p>初始化</p></blockquote><p>描述： 执行类构造器 () 方法的过程。</p><ul><li><code>&lt;clinit&gt;()</code> 方法<ul><li>包含的内容：<ul><li>所有 static 的赋值操作；</li><li>static 块中的语句；</li></ul></li><li><code>&lt;clinit&gt;()</code> 方法中的语句顺序：<ul><li>基本按照语句在源文件中出现的顺序排列；</li><li>静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。</li></ul></li><li>与 <code>&lt;init&gt;()</code> 的不同：<ul><li>不需要显示调用父类的 <code>&lt;clinit&gt;()</code> 方法；</li><li>虚拟机保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法一定执行完毕。也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。</li></ul></li><li>接口与类的不同：<ul><li>执行子接口的 <code>&lt;clinit&gt;()</code> 方法前不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法（除非用到了父接口中定义的 public static final 变量）；</li></ul></li><li>执行过程中加锁：<ul><li>同一时刻只能有一个线程在执行 <code>&lt;clinit&gt;()</code> 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。</li></ul></li><li>非必要性：<ul><li>一个类如果没有任何 static 的内容就不需要执行 () 方法。</li></ul></li></ul></li></ul><h3 id="本小节的补充：-lt-clinit-gt-与-lt-init-gt-方法"><a href="#本小节的补充：-lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="本小节的补充：&lt;clinit&gt; 与 &lt;init&gt; 方法"></a>本小节的补充：<code>&lt;clinit&gt;</code> 与 <code>&lt;init&gt;</code> 方法</h3><p><strong>概述</strong></p><p>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法<code>&lt;clinit&gt;</code>, 另一个是实例的初始化方法<code>&lt;init&gt;</code></p><p><code>&lt;clinit&gt;</code>：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行</p><p><code>&lt;init&gt;</code>:在实例创建出来的时候调用，包括调用new操作符；调用Class或<code>java.lang.reflect.Constructor</code>对象的<code>newInstance()</code>方法；调用任何现有对象的clone()方法；通过<code>java.io.ObjectInputStream</code>类的<code>getObject()</code>方法反序列化。</p><h4 id="lt-clinit-gt-方法"><a href="#lt-clinit-gt-方法" class="headerlink" title="&lt;clinit&gt;方法"></a><code>&lt;clinit&gt;</code>方法</h4><blockquote><p>先理解 类初始化阶段 的含义: 该阶段负责为类变量赋予正确的初始值, 是一个类或接口被首次使用前的最后一项工作</p></blockquote><p><code>&lt;clinit&gt;</code>方法的执行时期: 类初始化阶段(该方法只能被jvm调用, 专门承担类变量的初始化工作)</p><p><code>&lt;clinit&gt;</code>方法的内容: 所有的类变量初始化语句和类型的静态初始化器</p><p>类的初始化时机: 即在java代码中首次主动使用的时候, 包含以下情形:</p><ul><li>(首次)创建某个类的新实例时–new, 反射, 克隆 或 反序列化;</li><li>(首次)调用某个类的静态方法时;</li><li>(首次)使用某个类或接口的静态字段或对该字段(final 字段除外)赋值时;</li><li>(首次)调用java的某些反射方法时;</li><li>(首次)初始化某个类的子类时;</li><li>(首次)在虚拟机启动时某个含有 main() 方法的那个启动类</li></ul><p>注意: 并非所有的类都会拥有一个方法, 满足下列条件之一的类不会拥有方法:</p><ol><li>该类既没有声明任何类变量，也没有静态初始化语句;</li><li>该类声明了类变量，但没有明确使用类变量初始化语句或静态初始化语句初始化;</li><li>该类仅包含静态 final 变量的类变量初始化语句，并且类变量初始化语句是编译时常量表达式;</li></ol><h4 id="lt-init-gt-方法"><a href="#lt-init-gt-方法" class="headerlink" title="&lt;init&gt;方法"></a><code>&lt;init&gt;</code>方法</h4><p><code>&lt;init&gt;</code>方法的执行时期: 对象的初始化阶段</p><p>实例化一个类的四种途径:</p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载过程中的“通过一个类的全限定名来获取描述这个类的二进制字节流”这个动作是放在Java虚拟机的外部来实现的，以便于让应用程序自己来决定如何去获取所需要的类，实现这个动作的代码模块被称为<strong>“类加载器”</strong>。</p><p>类加载器虽然只用于实现类的加载动作，但是它的作用却远远不限于此，比较两个类是否“相等”，不仅仅要确认这两个类是否来源于同一个class文件，还需要加载这两个类的类加载器相同。</p><h3 id="如何判断两个类-“相等”"><a href="#如何判断两个类-“相等”" class="headerlink" title="如何判断两个类 “相等”"></a>如何判断两个类 “相等”</h3><ul><li>“相等” 的要求<ul><li>同一个 .class 文件</li><li>被同一个虚拟机加载</li><li>被同一个类加载器加载</li></ul></li><li>判断 “相等” 的方法<ul><li>instanceof 关键字</li><li>Class 对象中的方法：<ul><li>equals()</li><li>isInstance()</li><li>isAssignableFrom()</li></ul></li></ul></li></ul><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>站在虚拟机的角度，只存在两种类加载器：</p><blockquote><p>启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机的一部分<br>其他类加载器，由Java语言实现，独立于虚拟机之外的，全部继承自抽象类 java.lang.ClassLoader</p></blockquote><p>从开发人员的角度，类加载器可以划分得更细致一些：</p><ul><li>启动类加载器（Bootstrap）:负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。<code>&lt;JAVA_HOME&gt;/lib``-Xbootclasspath</code> 参数指定的路径</li><li>扩展类加载器（Extension）:负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录下的，或者被 <code>java.ext.dir</code> 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<ul><li><code>&lt;JAVA_HOME&gt;/lib/ext</code></li><li><code>java.ext.dirs</code> 系统变量指定的路径</li></ul></li><li>应用程序类加载器（Application）:负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。<ul><li><code>-classpath</code> 参数</li></ul></li></ul><p>以上加载器互相配合来加载我们自己的应用程序，如果有必要，我们还可以加入自己定义的加载器。这些加载器之间的关系一般如下图示：</p><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/reprint/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>类加载器的双亲委派模型（Parent Delegation Model）：要求除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器。（注意！这里类加载器之间的父子关系一般不会以继承（Inheritance）来实现，而是使用组合（Composition）来复用父加载器的代码）。这种模型被广泛使用于几乎所有的Java程序中，但是它并不是一个强制性的约束，只是Java设计者推荐给开发者使用的一种类加载器实现方式。</p><ul><li>工作过程<ul><li>当前类加载器收到类加载的请求后，先不自己尝试加载类，而是先将请求委派给父类加载器。因此，所有的类加载请求，都会先被传送到启动类加载器。</li><li>只有当父类加载器加载失败时，当前类加载器才会尝试自己去自己负责的区域加载</li></ul></li><li>实现<ul><li>检查该类是否已经被加载</li><li>将类加载请求委派给父类<ul><li>如果父类加载器为 null，默认使用启动类加载器</li><li>parent.loadClass(name, false)</li></ul></li><li>当父类加载器加载失败时<ul><li>catch ClassNotFoundException 但不做任何处理</li><li>调用自己的 findClass() 去加载<ul><li>我们在实现自己的类加载器时只需要 extends ClassLoader，然后重写 findClass() 方法而不是 loadClass() 方法，这样就不用重写 loadClass() 中的双亲委派机制了</li></ul></li></ul></li></ul></li><li>优点<ul><li>自己写的类库同名类不会覆盖类库的类</li><li>java类随着它的类加载器一起具备了一种带有优先层级的层次关系，保证了Java程序的稳定运行。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;【转载】&quot;&gt;&lt;a href=&quot;#【转载】&quot; class=&quot;headerlink&quot; title=&quot;【转载】&quot;&gt;&lt;/a&gt;【转载】&lt;/h2&gt;&lt;p&gt;本文作者&lt;strong&gt;：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/kylinxx
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="Java" scheme="https://qybit.gitee.io/tags/Java/"/>
    
      <category term="转载" scheme="https://qybit.gitee.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="JVM" scheme="https://qybit.gitee.io/tags/JVM/"/>
    
  </entry>
  
</feed>
