<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qybit&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ab3e80cccd375287a4f40b2a02dc6cd6</icon>
  <subtitle>Talk is cheap, show me your code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qybit.gitee.io/"/>
  <updated>2021-09-25T11:07:52.909Z</updated>
  <id>https://qybit.gitee.io/</id>
  
  <author>
    <name>qybit</name>
    <email>2601970213@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EQ-583-两个字符串的删除操作</title>
    <link href="https://qybit.gitee.io/2021/09/25/583/"/>
    <id>https://qybit.gitee.io/2021/09/25/583/</id>
    <published>2021-09-25T09:51:56.000Z</published>
    <updated>2021-09-25T11:07:52.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>题目链接：<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p><a id="more"></a><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以设置 $f[i][j]$ 表示使得 $word1$ 前 $i$ 个字符 和  $word2$ 前 $j$ 个字符相等时的最小操作次数。</p><ol><li><p>对于 $0 \le i \lt word1.length$ 和 $ 0 \le j \lt word2.length$ 存在时，且我们是可以判断字符串 $word1[0…i-1]$ 和 字符串 $word2[0…j-1]$ 一定相等，那么对于 $word1$ 中第 $i$ 个字符 和 $word2$ 中第 $j$ 个字符有以下情况：</p><ol><li><p>$word1[i] = word2[j]$ ：</p><p> 我们不需要任何操作，因此 我们可以继承前 $i-1$ 个 和  前 $j -1$ 个字符相等时的最小操作次数。即 $f[i][j]=f[i-1][j-1]$</p></li><li><p>$word1[i] \neq word2[j]$：</p><ul><li>​    我们选择删除 $word1$ 中第 $i$ 个字符，假设此时字符串 $word1[0…i-1]$ 与字符串 $word2[0…j]$ 相等，那么需要的操作次数为 $f[i][j] = f[i-1][j] + 1$ </li><li>同理我们选择删除 $word2$ 中的第 $j$ 个字符，假设此时字符串 $word2[0…j-1]$ 与字符串 $word1[0…i]$ 相等，那么需要的操作次数为 $f[i][j]=f[i][j-1]+1$</li><li>我们选择同时删除 $word1$ 中的第 $i$ 个字符和 $word2$ 中的第 $j$ 个字符，那么此时需要的操作次数为 $f[i][j]=f[i-1][j-1]+2$</li><li>综合上述三种操作时，我们取最小值</li></ul></li></ol></li><li><p>状态转移方程定义<br> $$<br> f[i][j] =<br> \begin{cases}<br> f[i - 1][j - 1]&amp;, word1[i] = word2[j] \\<br> min({ f[i-1][j] + 1, f[i][j-1]+1, f[i-1][j-1]+2 })&amp;, word1[i] \ne word2[j]<br> \end{cases}<br> $$</p></li><li><p>初始化 $f$ 数组，我们的边界值实际上是当 $word1$ 或 $word2$ 为空字符串时</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i; <span class="comment">// word2 为空字符串时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j; <span class="comment">// word1 为空字符串时、</span></span><br></pre></td></tr></table></figure></li><li><p>以 <code>word1=sea</code> 和 <code>word2=eat</code> 举例，展示 $f$ 数组的状态</p><p> <img src="https://pic.imgdb.cn/item/614f02892ab3f51d91e01665.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(&#123;f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>, f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/delete-operation-for-two-strings/&quot;&gt;583. 两个字符串的删除操作&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="动态规划" scheme="https://qybit.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>第 239 场周赛</title>
    <link href="https://qybit.gitee.io/2021/05/06/259/"/>
    <id>https://qybit.gitee.io/2021/05/06/259/</id>
    <published>2021-05-06T02:07:38.000Z</published>
    <updated>2021-09-23T13:18:44.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></li><li> <a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></li></ul><h1 id="T1：到目标元素的最小距离"><a href="#T1：到目标元素的最小距离" class="headerlink" title="T1：到目标元素的最小距离"></a>T1：<a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题目模拟一遍即可。</p><p>我们使用 $int32$ 的最大值$INT_MAX$ ，当 $nums[i] = target$ 时，保证 $abs(i - start)$ 的值最小即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ans =  min(ans, <span class="built_in">abs</span>(i - start)); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><p>空间复杂度：$O(1)$。</p><h1 id="T2：将字符串拆分为递减的连续值"><a href="#T2：将字符串拆分为递减的连续值" class="headerlink" title="T2：将字符串拆分为递减的连续值"></a>T2：<a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></h1><p>注意到：当我们确定了第一个数之后，后面的数也就随之确定下来了。因此我们在搜索的过程中，是可以避免过多的冗余计算。</p><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>具体做法</p><ul><li>对于每一次递归：<ul><li>我们需要记录的状态如下：$idx$ 表示当前字符串的位置，$prev$ 表示上一个数的大小，$cnt$ 表示当前连续降序数字的数量。</li><li>我们尝试去确定第一个数，从下标 $0$ 开始增加这个数。枚举每一个可能的数（不包括全部的字符串），因为连续的字符串至少存在两个。</li><li>对于已经确定的上一个数，我们总是想要寻找下一个数，因此需要记录<strong>当前数</strong> $cur$ 的大小，当且仅当 $cur = prev - 1$ 时，我们才会继续寻找下一个数。</li><li>当我们搜索到字符串的末尾时，只有存在两个连续数字时才符合要求，此时可以返回 $True$。</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 字符串的长度是 20 位，一定会爆 int32</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitString</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        s = str;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, ULL prev, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            <span class="comment">// 连续的数字，至少要存在两个</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ULL cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; n; i ++) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 当前数已经大于上一个数，此时直接退出即可。</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; prev - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span> || prev - cur == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>, cur, cnt + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(2^n)$，其中 $n$ 为字符串的长度且最大为 $20$。</p><p>空间复杂度：$O(n)$，递归消耗的栈内存。</p><h2 id="方法二：枚举"><a href="#方法二：枚举" class="headerlink" title="方法二：枚举"></a>方法二：枚举</h2><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于字符串 $s$，我们可以枚举出所有可能的字串。</p><p>按照递归的思路去改写我们的代码</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第一个整数不能是自身</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            start = start * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">            preVal = start</span><br><span class="line">            curVal = <span class="number">0</span></span><br><span class="line">            curIdx = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> preVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">all</span>(s[k] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(curIdx, n)):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                curVal = curVal * <span class="number">10</span> + <span class="built_in">int</span>(s[j])</span><br><span class="line">                <span class="comment"># 枚举的下一个字串超过前一个整数</span></span><br><span class="line">                <span class="keyword">if</span> curVal &gt; preVal - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> preVal - curVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == n - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    preVal = curVal</span><br><span class="line">                    curVal = <span class="number">0</span></span><br><span class="line">                    curIdx = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="T3：邻位交换的最小次数"><a href="#T3：邻位交换的最小次数" class="headerlink" title="T3：邻位交换的最小次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>先找到当前字符串的第 $k$ 个排列（我们称之为<strong>妙数</strong>）</li><li>原字符串 $s$ 与 妙数 $num$ 进行对比，如果在下标 $i$ 的位置不相同：<ol><li>我们在 妙数 的下标 $i$ 之后寻找一个下标 $j$ 使得 $s[i] = num[j]$ ，再将 $j$ 对应的元素相邻的交换到 $i$ 的位置。</li><li>每一次交换都是我们的最小交换次数</li></ol></li></ol><p>寻找下一个排序与 <a href="https://leetcode-cn.com/problems/next-permutation/">力扣31. 下一个排列</a> 相同。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i] &gt;= s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] &lt;= s[i]) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin() + i + <span class="number">1</span>, s.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = num;</span><br><span class="line">        <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">            nextPermutation(num);</span><br><span class="line">            <span class="comment">// c++ 内置的实现，同理</span></span><br><span class="line">            <span class="comment">// next_permutation(num.begin(), num.end());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != s[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; num[j] != s[i]) &#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                    swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">                    ans ++;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N \times K + N^2)$，其中 $N$ 为字符串的长度，$K$ 为给定的整数。</p><ul><li>我们先做 $K$ 次寻找下一个妙数，每一次寻找妙数的时间复杂度为 $O(N)$。</li><li>我们再寻找原字符串到达妙数的最小交换次数，最坏的情况下对于每一个元素我们要访问 $N$ 次，因此时间复杂度为 $O(N^2)$</li></ul><p>空间复杂度：$O(N)$，其中 $N$ 为字符串的长度。我们需要存储原字符串。</p><h1 id="T4：包含每个查询的最小区间"><a href="#T4：包含每个查询的最小区间" class="headerlink" title="T4：包含每个查询的最小区间"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></h1><h2 id="思路：离线算法"><a href="#思路：离线算法" class="headerlink" title="思路：离线算法"></a>思路：离线算法</h2><p>我们将区间的左端点和右端点以及查询视作 事件，然后对其按照左端点、查询和右端点进行排序：</p><ul><li>如果当前事件为左端点，我们将区间长度加入 有序集合 中</li><li>如果当前事件为查询，我们取出 有序集合 的最小值</li><li>如果当前事件为右端点，我们将当前区间的长度从 有序集合 中移除</li></ul><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="comment">// 0 表示左端点</span></span><br><span class="line">        <span class="comment">// 1 表示询问</span></span><br><span class="line">        <span class="comment">// 2 表示右端点</span></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="comment">// 事件的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="comment">// if type = 0: 区间右端点的位置</span></span><br><span class="line">        <span class="comment">// if type = 1: 询问在原数组的位置</span></span><br><span class="line">        <span class="comment">// if type = 2: 区间左端点的位置</span></span><br><span class="line">        <span class="keyword">int</span> para;</span><br><span class="line"><span class="comment">// 如果位置相同，优先按照左端点</span></span><br><span class="line">        <span class="comment">// 按照左端点、询问、右端点的优先级排序</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Event&amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == t.pos) <span class="keyword">return</span> type &lt; t.type;</span><br><span class="line">            <span class="keyword">return</span> pos &lt; t.pos; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size(), m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Event&gt; events;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="comment">// 查询事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">1</span>, queries[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">            <span class="comment">// 左端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">0</span>, interval[<span class="number">0</span>], interval[<span class="number">1</span>]&#125;);</span><br><span class="line"><span class="comment">// 右端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">2</span>, interval[<span class="number">1</span>], interval[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(events.begin(), events.end());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; seg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event : events) &#123;</span><br><span class="line">            <span class="comment">// 当前事件为左端点，把区间长度插入到 有序集合</span></span><br><span class="line">            <span class="keyword">if</span> (event.type == <span class="number">0</span>) &#123;</span><br><span class="line">                seg.insert(event.para - event.pos + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 查询事件</span></span><br><span class="line">                <span class="keyword">if</span> (seg.size()) &#123;</span><br><span class="line">                    <span class="comment">// 不为空的话，就取出最小值</span></span><br><span class="line">                    ans[event.para] = *seg.begin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 右端点，此时的小区间不必再查询，我们直接移除即可</span></span><br><span class="line">                <span class="keyword">int</span> len = event.pos - event.para + <span class="number">1</span>;</span><br><span class="line">                seg.erase(seg.find(len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O((m+n)log(m+n))$，其中 $m$ 为区间数组 $intervals$ 的长度，$n$ 为查询数组 $queries$ 的长度。我们将其合并成一个 事件 数组，容量大小为 $2m + n = O(m + n)$。然后进行了排序操作，因此时间复杂度为 $O((m + n)log(m+n))$。</p><p>空间复杂度：$O(m+n)$，我们需要存储所有的事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/&quot;&gt;到目标元素的最小距离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯" scheme="https://qybit.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>第 237 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/19/w237/"/>
    <id>https://qybit.gitee.io/2021/04/19/w237/</id>
    <published>2021-04-19T01:49:11.000Z</published>
    <updated>2021-09-23T13:18:44.003Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/"> 判断句子是否为全字母句</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></li><li> <a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></li><li> <a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></li></ul><h1 id="T1：判断句子是否为全字母句"><a href="#T1：判断句子是否为全字母句" class="headerlink" title="T1：判断句子是否为全字母句"></a>T1：<a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>全字母句就是一个字符串包含字母表中的 $26$ 个字母。我们只需要开一个 $26$ 长度的数组记录一下字母的出现次数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfPangram</span><span class="params">(<span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : sentence) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : f) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度，我们需要扫描一遍字符串。</p><p>空间复杂度：$O(1)$。这里我们只使用了常数级别的数组空间。</p><h1 id="T2：雪糕的最大数量"><a href="#T2：雪糕的最大数量" class="headerlink" title="T2：雪糕的最大数量"></a>T2：<a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们的现金是固定的，而且我们可以按照任意的顺序去购买雪糕。</p><p>而且我们可以选择的仅有 $n$ 支雪糕，对于第 $i$ 支雪糕，我们要尽可能的选择定价更小的雪糕。只有我们每次都选择定价更小的雪糕，这样才可以买更多的雪糕。</p><p>所以我们可以对雪糕的定价进行排序，使得我们每次选择价格较小的雪糕。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        sort(costs.begin(), costs.end());</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cost : costs) &#123;</span><br><span class="line">            s += cost;</span><br><span class="line">            <span class="keyword">if</span> (s &lt;= coins) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p><p>空间复杂度：$O(1)$。</p><h1 id="T3：单线程-CPU"><a href="#T3：单线程-CPU" class="headerlink" title="T3：单线程 CPU"></a>T3：<a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</p><ul><li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态</li><li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 <strong>执行时间最短</strong> 的任务开始执行。</li><li>如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li><li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li><li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li></ul><p>具体实现：</p><ul><li>我们需要自定义一个数据结构来增强 $Task$，增加一个数组的下标</li><li>对于 $Task$ 数组，我们需要找出最早入队执行的任务，因此对 $Task$ 数组按照入队时间排序</li><li>我们还需要一个数据结构来模拟 CPU，可以使用 堆 实现<ul><li>对于堆中的任务，我们总是选择执行时间最短的任务开始执行</li><li>如果有多个执行时间相同的任务，我们选择下标最小的任务</li></ul></li><li>当 CPU空闲 / 堆为空 时，直接把开始执行小于等于时间戳的任务顺序入队</li><li>每次都执行一个任务，统计时间戳的累计时间</li><li>当我们把任务都入队时，即表示 CPU 可以按照顺序把任务执行完毕</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> ep;</span><br><span class="line">        <span class="keyword">int</span> pt;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            id = a;</span><br><span class="line">            ep = b;</span><br><span class="line">            pt = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getOrder(<span class="keyword">int</span>[][] t) &#123;</span><br><span class="line">        List&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = t.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> Task(i, t[i][<span class="number">0</span>], t[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按入队时间升序排序</span></span><br><span class="line">        Collections.sort(tasks, (t1, t2) -&gt; t1.ep - t2.ep);</span><br><span class="line">        PriorityQueue&lt;Task&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行时间相同，id 升序</span></span><br><span class="line">            <span class="keyword">if</span> (t1.pt == t2.pt) &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.id - t2.id;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行时间升序</span></span><br><span class="line">            <span class="keyword">return</span> t1.pt - t2.pt;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 时间戳</span></span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 把小于等于当前时间戳的任务都入队</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                heap.offer(tasks.get(i ++));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CPU 空闲</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty()) &#123;</span><br><span class="line">                now = (<span class="keyword">long</span>)tasks.get(i).ep;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                    heap.offer(tasks.get(i ++));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行一个任务</span></span><br><span class="line">            Task task = heap.poll();</span><br><span class="line">            ans[p ++] = task.id;</span><br><span class="line">            now += task.pt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有任务都进入 待执行状态，顺序执行即可</span></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            ans[p ++] = heap.poll().id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 表示任务的数量。</p><ul><li>我们对任务按照入队时间进行排序，时间复杂度 $O(NlgN)$。</li><li>在最坏的情况下，所有的任务都会进入 堆 中，此时堆的调整次数为 $N$ 次，每次调整的时间复杂度为 $O(lgN)$。因此时间复杂度为 $O(NlgN)$。</li></ul><p>空间复杂度：$O(N)$。最坏的情况下，我们建堆的空间和任务数量一致。</p><h1 id="T4：所有数对按位与结果的异或和"><a href="#T4：所有数对按位与结果的异或和" class="headerlink" title="T4：所有数对按位与结果的异或和"></a>T4：<a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>从 $arr1$ 中任意取一个数 $a$，从 $arr2$ 中任意取两个数 $b_1, b_2$，则有：<br>$$<br>\begin{align}<br>(a &amp; b_1) \bigoplus (a &amp; b_2) = &amp; [(a | \lnot b_1)&amp;(\lnot a | b_2)] | [(a | b_1) &amp; (\lnot a | \lnot b_2)] \\<br> = &amp; (\lnot a &amp; \lnot b_1 &amp; b_2) | (a &amp; b_1 &amp; \lnot b_2) \\<br> = &amp; a &amp; [(\lnot b_1 &amp; b_2) | (b_1 &amp; \lnot b_2)] \\<br> = &amp; a &amp; (b_1 \bigoplus b_2)<br>\end{align}<br>$$<br>推广到 $arr2$ 中的所有数 $0 \le i \le m$<br>$$<br>[(a &amp; b_1) \bigoplus (a &amp; b_2) \bigoplus (a &amp; b_3) … (a &amp; b_m)] = [a &amp; (b_1 \bigoplus b_2 \bigoplus b_3 \bigoplus … \bigoplus b_m)]<br>$$<br>同理，推广到 $arr1$ 中的所有的数 $0 \le i \le n$<br>$$<br>\begin{align}<br>[(a_1 &amp; b_1) \bigoplus (a_2 &amp; b_2) \bigoplus (a_3 &amp; b_3) \bigoplus … \bigoplus (a_i &amp; b_j)] = &amp; [[a_1 &amp; (b_1  \bigoplus … \bigoplus b_j)]  \bigoplus … \bigoplus [a_i &amp; (b_1  \bigoplus … \bigoplus b_j)]] \\<br>= &amp; [a_1 \bigoplus a_2 \bigoplus … \bigoplus a_i] &amp; [b_1 \bigoplus b_2 \bigoplus …\bigoplus b_j]<br>\end{align}<br>$$<br>因此，我们只需要分别计算 $s_1 = \sum_{i=0}^n xor(a[i])$ 和 $s_2 = \sum_{j=0}^m xor(b[j])$。再计算  $s_1 &amp; s_2$ 即为本题的答案。 </p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr1) s1 ^= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr2) s2 ^= n;</span><br><span class="line">        <span class="keyword">return</span> s1 &amp; s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n + m)$，其中 $n$ 和 $m$ 分别为数组 $arr1$ 和 $arr2$ 的长度。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/&quot;&gt; 判断句子是否为全字母句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="数组" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/%E5%A0%86/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/%E5%A0%86/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/tags/%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>第 236 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/12/w236/"/>
    <id>https://qybit.gitee.io/2021/04/12/w236/</id>
    <published>2021-04-12T07:23:07.000Z</published>
    <updated>2021-09-23T13:18:44.003Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></li><li> <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></li><li> <a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></li></ul><h1 id="T1：数组元素积的符号"><a href="#T1：数组元素积的符号" class="headerlink" title="T1：数组元素积的符号"></a>T1：<a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力即可，但是不建议直接对数组进行乘法操作，可能会爆 $int$ 甚至是 $64$ 位的整形。</p><p>我们只需要统计 负数 的存在个数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySign</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mask := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            mask ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mask % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。我们至多只会对数组扫描一遍。</p><p>空间复杂度：$O(1)$</p><h1 id="T2：找出游戏的获胜者"><a href="#T2：找出游戏的获胜者" class="headerlink" title="T2：找出游戏的获胜者"></a>T2：<a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一个裸的约瑟夫环问题。由于数据范围不大，所以直接模拟也是可行的</p><p>具体证明本文不再赘述，请参考博客：<a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环问题公式推导</a></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheWinner</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = (p + k) % i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为小伙伴的数量。</p><p>空间复杂度：$O(1)$</p><h1 id="T3：最少侧跳次数"><a href="#T3：最少侧跳次数" class="headerlink" title="T3：最少侧跳次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></h1><h2 id="方法一：BFS-求最短路"><a href="#方法一：BFS-求最短路" class="headerlink" title="方法一：BFS 求最短路"></a>方法一：BFS 求最短路</h2><h3 id="问题转换"><a href="#问题转换" class="headerlink" title="问题转换"></a>问题转换</h3><p>我们可以把赛道想象成一个 $3 \times n$ 的一个矩阵，我们从 $(2, 0)$ 点出发，问到达最后一列所需要的最短步长？</p><p>当然，我们这里的步长是指到达当前点 $(x, y)$ 时，我们跳跃的最小步数。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们在每次选择下一次的 ”落脚点“ 时，总是贪心的选择最少跳跃次数的点。因此，我们可以当作一个迪杰斯特拉的最短路算法。</p><p>注意点：我们在构建矩阵时，为了更好的判断障碍物，我们将会构建 $4 \times n$ 的矩阵。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, x, y;</span><br><span class="line">    <span class="comment">// 重载运算符 &lt;，表示构建小根堆。每次弹出堆的都是 d 最小的一个</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pos&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; p.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSideJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Pos&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> col = obstacles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> d = p.d;</span><br><span class="line">            <span class="comment">// 到达最后一列</span></span><br><span class="line">            <span class="keyword">if</span> (p.y == col - <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p.x + dx[i], y = p.y + dy[i];</span><br><span class="line">                <span class="comment">// 越界检查</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 下一个点是障碍物</span></span><br><span class="line">                <span class="keyword">if</span> (obstacles[y] == x) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dx[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果跳了，就消耗一步</span></span><br><span class="line">                    cost = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d + cost &lt; dist[x][y]) &#123;</span><br><span class="line">                    dist[x][y] = d + cost;</span><br><span class="line">                    pq.push(&#123;dist[x][y], x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(4 \times N)$，其中 $N$ 为障碍物的长度。</p><ul><li>我们在最坏的情况下，可能要对整个矩阵进行扫描。</li></ul><p>空间复杂度：$O(4 \times N)$，我们需要存储所有可能的点。</p><h1 id="T4：求出-MK-平均值"><a href="#T4：求出-MK-平均值" class="headerlink" title="T4：求出 MK 平均值"></a>T4：<a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>$Python$ 可以偷税暴力过</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, m: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.m = m</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addElement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.nums.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMKAverage</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &lt; self.m:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        last = self.nums[-self.m :]</span><br><span class="line">        last.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(mean(last[self.k : -self.k]))</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^2)$，其中 $calculateMKAverage$ 方法会调用 $10^5$ 次。每一次操作的数组最大长度也是 $10^5$。因此时间复杂度为 $O(N^2)$</p><p>空间复杂度：$O(N)$，我们要存储原数组和临时数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/&quot;&gt;数组元素积的符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https://l
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="BFS" scheme="https://qybit.gitee.io/tags/BFS/"/>
    
      <category term="DP" scheme="https://qybit.gitee.io/tags/DP/"/>
    
      <category term="设计" scheme="https://qybit.gitee.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/tags/%E5%A0%86/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="队列" scheme="https://qybit.gitee.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实践-豆瓣TOP250</title>
    <link href="https://qybit.gitee.io/2021/04/07/doubantop250/"/>
    <id>https://qybit.gitee.io/2021/04/07/doubantop250/</id>
    <published>2021-04-07T13:33:06.000Z</published>
    <updated>2021-09-23T13:18:43.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集中 学习+复习 Go 语言有一个多星期了，也该写点东西了。</p><p>说下使用的 Go 语言的感受吧，直观上来说。Go 刚上手是比较反人类的，比如变量名和变量类型的位置是反着的，已经函数和方法的返回值的位置就更加的奇怪了。但是，总体的上手难度不是很大。相反，我认为这些也是 Go 的一大特色吧 (笑)。总体的学习门槛是比较低的，而且 Go 身上也有很多 C/C++ 的影子 (比如指针类型，还有结构体)。最让我感到意外的就是，Go 语言中的接口的设计，真正的做到了低耦合。因为只要任意一个结构体或者类型实现了接口中的方法后，就算是真正意义上的实现了一个接口。而当我们从代码里 “拿走” 这个接口时，是不会影响到实现了该接口的结构体或者类型，因为那只是它们的方法而已。</p><p>你可能会疑惑，为什么要从爬虫开始实践？</p><p>我认为兴趣是最好的老师，我不喜欢死板的去写 ”xxx通讯录管理系统“ 或者 ”xxx管理系统“ 之类的无聊 demo。我是兴趣驱动，我更愿意从爬虫入手去学习。</p><p>本来打算拿我的看家本领 Senlium 呢，结果到官网一查还不支持 Go。</p><p>好的，说的有点多了，下面开始我们的 Go 语言爬虫实践吧。</p><p>项目地址：<a href="https://github.com/qybit/doubantop250">项目地址</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>开发环境</p><ul><li>go version go1.16.2 windows/amd64</li><li>goland</li><li>第三方库 goquery（一个类似jQuery可以操作DOM的库）</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>结构体</li><li>函数 / 方法</li><li>http</li><li>懂得 DOM 编程，至少会 JavaScript 中的 DOM 部分</li><li>正则表达式</li><li> 异常处理</li><li>json</li><li>io 处理</li></ul><h2 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h2><p>我们的工作目录长这样👇。Movie 应该写成 movie 的，写 Java 写顺手了 (笑)。</p><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/doubantop250_0.png"></p><h2 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h2><p>作为一只合格的网络爬虫，我们必须要可以发起基本的 http 请求获得网页数据。</p><p>正规的网站，一般最基础的防御就是通过 User-Agent / Agent 字段的校验，来检测是不是真人用户操作。我们只需要在请求头中加入这一字段，把自己 “伪装” 成真人用户，具体内容可以在浏览器查看。这里不在赘述。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用获取的响应内容，构建-DOM-树"><a href="#使用获取的响应内容，构建-DOM-树" class="headerlink" title="使用获取的响应内容，构建 DOM 树"></a>使用获取的响应内容，构建 DOM 树</h2><p>这一步，我们将会使用 goquery 库，它会帮助我们把网络请求的响应内容解析成一颗 DOM 树。并提供和 JavaScript 和 jQuery 类似的 API 供我们访问某个节点。</p><p>这里的 content 实际上就是 响应的Body 部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析单个页面的所有电影内容"><a href="#解析单个页面的所有电影内容" class="headerlink" title="解析单个页面的所有电影内容"></a>解析单个页面的所有电影内容</h2><p>我们拿到上面生成的 goquery.Document 对象， goquery 提供的选择器的功能和 jQuery 几乎一模一样。所以有过 jQuery 使用经验的话，上手 goquery 是非常容易的。这里的稍微麻烦点的就是我们处理字符串的时候。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">movie := &amp;entity.Movie&#123;</span><br><span class="line">Title:    title,</span><br><span class="line">Subtitle: subtitle,</span><br><span class="line">Other:    other,</span><br><span class="line">Cover:    cover,</span><br><span class="line">Desc:     desc,</span><br><span class="line">Year:     year,</span><br><span class="line">Area:     area,</span><br><span class="line">Tag:      tag,</span><br><span class="line">Star:     star,</span><br><span class="line">Comment:  comment,</span><br><span class="line">Quote:    quote,</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>这里将会调用上面的所有方法，然后根据用户输入的信息，进行决策。</p><p>比如从哪一页开始获取，以及是否需要持久化等</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   content, err := fetchSinglePageContent(URL, start)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   dom, err := generatorDomTree(content)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   books, err := parseSinglePage(dom)</span><br><span class="line">   <span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">      fmt.Println(book)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      data, _ := json.Marshal(books)</span><br><span class="line">      err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/toubantop250.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module qybit.com/doubantop250</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require github.com/PuerkitoBio/goquery v1<span class="number">.6</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="entiy-包"><a href="#entiy-包" class="headerlink" title="entiy 包"></a>entiy 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span> <span class="string">`json:&quot;title&quot;`</span><span class="comment">// 中文名</span></span><br><span class="line">Subtitle <span class="keyword">string</span> <span class="string">`json:&quot;subtitle&quot;`</span><span class="comment">// 英文名</span></span><br><span class="line">Other    <span class="keyword">string</span> <span class="string">`json:&quot;other&quot;`</span><span class="comment">// 港澳台翻译名</span></span><br><span class="line">Cover    <span class="keyword">string</span> <span class="string">`json:&quot;cover&quot;`</span><span class="comment">// 电影封面</span></span><br><span class="line">Desc     <span class="keyword">string</span> <span class="string">`json:&quot;desc&quot;`</span><span class="comment">// 描述</span></span><br><span class="line">Year     <span class="keyword">string</span> <span class="string">`json:&quot;year&quot;`</span><span class="comment">// 上映年份</span></span><br><span class="line">Area     <span class="keyword">string</span> <span class="string">`json:&quot;area&quot;`</span><span class="comment">// 属于哪个国家</span></span><br><span class="line">Tag      <span class="keyword">string</span> <span class="string">`json:&quot;tag&quot;`</span><span class="comment">// 属于哪一类型的电影</span></span><br><span class="line">Star     <span class="keyword">string</span> <span class="string">`json:&quot;star&quot;`</span><span class="comment">// 评分</span></span><br><span class="line">Comment  <span class="keyword">string</span> <span class="string">`json:&quot;comment&quot;`</span><span class="comment">// 参与评分的人数</span></span><br><span class="line">Quote    <span class="keyword">string</span> <span class="string">`json:&quot;quote&quot;`</span><span class="comment">// 宣传标语</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spider-包"><a href="#spider-包" class="headerlink" title="spider 包"></a>spider 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spider</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/PuerkitoBio/goquery&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;qybit.com/doubantop250/entity&quot;</span></span><br><span class="line"><span class="string">&quot;regexp&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">URL          <span class="keyword">string</span> = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span></span><br><span class="line">DefaultCover <span class="keyword">string</span> = <span class="string">&quot;https://img.imgdb.cn/item/601fdca33ffa7d37b326de61.jpg&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">movie := &amp;entity.Movie&#123;</span><br><span class="line">Title:    title,</span><br><span class="line">Subtitle: subtitle,</span><br><span class="line">Other:    other,</span><br><span class="line">Cover:    cover,</span><br><span class="line">Desc:     desc,</span><br><span class="line">Year:     year,</span><br><span class="line">Area:     area,</span><br><span class="line">Tag:      tag,</span><br><span class="line">Star:     star,</span><br><span class="line">Comment:  comment,</span><br><span class="line">Quote:    quote,</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">content, err := fetchSinglePageContent(URL, start)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">dom, err := generatorDomTree(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">books, err := parseSinglePage(dom)</span><br><span class="line"><span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">fmt.Println(book)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">data, _ := json.Marshal(books)</span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> k <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= page; i++ &#123;</span><br><span class="line">parseOnePage(strconv.Itoa(k), i, ok)</span><br><span class="line">k += <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;qybit.com/doubantop250/spider&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;请输入要爬取的页数，最大10页：&quot;</span>)</span><br><span class="line">cin := bufio.NewScanner(os.Stdin)</span><br><span class="line">cin.Scan()</span><br><span class="line">page, err := strconv.Atoi(cin.Text())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;输入数据不合法，请按照要求输入！&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot;是否需要持久化？（请输入 yes/y 或者 no/n）&quot;</span>)</span><br><span class="line">cin.Scan()</span><br><span class="line">ok := cin.Text()</span><br><span class="line">isOk := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> ok == <span class="string">&quot;yes&quot;</span> || ok == <span class="string">&quot;y&quot;</span> &#123;</span><br><span class="line">isOk = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">spider.Run(page, isOk)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;集中 学习+复习 Go 语言有一个多星期了，也该写点东西了。&lt;/p&gt;
&lt;p&gt;说下使用的 Go 语言的感受吧，直观上来说。Go 刚上手是比较反
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
      <category term="Go" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/Go/"/>
    
    
      <category term="Go" scheme="https://qybit.gitee.io/tags/Go/"/>
    
      <category term="爬虫" scheme="https://qybit.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>第 235 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/05/259/"/>
    <id>https://qybit.gitee.io/2021/04/05/259/</id>
    <published>2021-04-05T06:00:31.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></li><li><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></li><li><a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></li></ul><h1 id="T1：截断句子"><a href="#T1：截断句子" class="headerlink" title="T1：截断句子"></a>T1：<a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></h1><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不同单词之间是按照空格隔开的，因此我们统计空格数量即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">truncateSentence</span><span class="params">(s <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cnt <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            cnt ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == k &#123;</span><br><span class="line">            <span class="keyword">return</span> s[:i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(\sum)$，其中 $\sum$ 为前 $k$ 个单词的长度。</p><p>空间复杂度：$O(1)$，我们只使用了常数的空间</p><h1 id="T2：查找用户活跃分钟数"><a href="#T2：查找用户活跃分钟数" class="headerlink" title="T2：查找用户活跃分钟数"></a>T2：<a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></h1><p>典型的阅读理解</p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先看看我们要返回的答案到底是什么。</p><p>$answer[j] (1 \le j \le k )$ 表示 <strong>用户活跃分钟数</strong>  等于 $j$ 的用户数。老谜语人了，其实说白了就是：<strong>一个用户总共的活跃分钟数恰好等于 $j$ 的人数</strong>。</p><p>另外，一个用户在同一个分钟可以活跃多次，也就是说我们还要处理去重。</p><p>我们的解决方法很简单，使用 哈希表 即可实现去重。</p><p>那么，还存在一个问题，如何知道一个用户一共活跃了多少次呢？</p><p>我们仍然可以使用 哈希表 来实现，那么这就是一个嵌套的 哈希表 结构，如果不熟练这样的写法的话，说明基础语法还有待加强。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findingUsersActiveMinutes</span><span class="params">(logs [][]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, log := <span class="keyword">range</span>(logs) &#123;</span><br><span class="line">        id, time := log[<span class="number">0</span>], log[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> _, ok := count[id]; !ok &#123;</span><br><span class="line">            count[id] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        count[id][time] = INF </span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> _, cnt := <span class="keyword">range</span>(count) &#123;</span><br><span class="line">        ans[<span class="built_in">len</span>(cnt) - <span class="number">1</span>] ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><ul><li>我们会遍历一次数组，收集所有用户的活跃信息</li><li>我们还会遍历一次哈希表，这个取决于存在的用户数量，用户数量最大不会超过数组长度。</li><li>因此我们的最终时间复杂度为 $O(2\times N) = O(N)$</li></ul><p>空间复杂度：$O(N)$，我们会存储所有用户的信息</p><h1 id="T3：绝对差值和"><a href="#T3：绝对差值和" class="headerlink" title="T3：绝对差值和"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></h1><h2 id="方法一：排序-二分查找"><a href="#方法一：排序-二分查找" class="headerlink" title="方法一：排序 + 二分查找"></a>方法一：排序 + 二分查找</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目定义：</p><p>绝对差值和：$\sum_{i=0}^n |nums1[i] - nums2[i]|$</p><p>再搞清楚我们的目的：我们可以选用 $nums1$ 中的任意一个元素替换 $nums1$ 中的至多一个元素，使得绝对值差和最小化。</p><p>具体做法：</p><ol><li>我们可以预先计算好未 <strong>替换</strong> 元素前的绝对值差</li><li>尝试 <strong>替换</strong> 操作，我们在 $nums1$ 中找到一个<strong>最逼近</strong> $nums2[i]$ 的一个元素<ol><li>快速查找的话，我们可以想到二分查找，因此需要对 $nums1$ 进行排序操作</li><li>对于 $nums2$ 中的每一个元素，都尝试查找元素值相近的一个下标 $p$</li><li>替换完毕后，计算 $nums1[p] - nums2[i]$ 的最小值，这样可以说明两个元素很相近</li><li>再计算出偏移量 $shrink$ ，使得 $shrink$ 的值最大化，这样可以使得 绝对值差和 最小。</li></ol></li><li>我们第一步已经计算好了 <strong>未替换</strong> 元素的绝对值差，第二步我们模拟了 <strong>替换</strong> 操作后，找出了偏移量最大的替换方案，直接减去即可。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>值得注意的是，在 $Go$ 中 $int$ 默认是 $64$ 位的，因此其他语言在实现的过程中，建议使用 $64$ 位的整型变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums1)</span><br><span class="line">    cnt := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">var</span> ans, shrink <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cnt[i] = abs(nums1[i] - nums2[i])</span><br><span class="line">        ans += cnt[i]</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(nums1)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cost := cnt[i]</span><br><span class="line">        <span class="keyword">var</span> delta <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// p 是nums1中对应元素大于等于 nums2[i] 的一个下标</span></span><br><span class="line">        p := lowerBound(nums1, nums2[i])</span><br><span class="line">        <span class="comment">// fmt.Println(p)</span></span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 可能越界。</span></span><br><span class="line">            <span class="keyword">if</span> p == n &#123;</span><br><span class="line">                p --</span><br><span class="line">            &#125;</span><br><span class="line">            delta = min(abs(nums1[p] - nums2[i]), abs(nums1[p - <span class="number">1</span>] - nums2[i])) </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delta = abs(nums1[p] - nums2[i])</span><br><span class="line">        &#125;</span><br><span class="line">        shrink = max(shrink, abs(cost - delta))</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= shrink</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找出大于等于 x 的下标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= x &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p><ul><li>我们遍历一次数组预计算出未替换前的绝对值差和，时间复杂度 $O(N)$</li><li>对数组进行排序操作，$Go$ 实现的排序为快速排序时间复杂度为 $O(NlgN)$</li><li>我们会遍历 $nums2$ 数组，对于$nums2$ 数组中的任意一个元素都尝试去 $nums1$ 中找出一个最逼近的元素，二分查找的时间复杂度为 $O(lgN)$，因此总的时间复杂度为 $O(NlgN)$</li></ul><p>空间复杂度：$O(N)$，我们要存储未替换前的绝对值差。</p><h1 id="T4：序列中不同最大公约数的数目"><a href="#T4：序列中不同最大公约数的数目" class="headerlink" title="T4：序列中不同最大公约数的数目"></a>T4：<a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></h1><h2 id="方法一：数学"><a href="#方法一：数学" class="headerlink" title="方法一：数学"></a>方法一：数学</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们不必去找这个子序列，然后计算出最大公约数 $g$，我们直接枚举最大公约数 $g$ 去构造这个子序列。</p><p>假设一个数组存在最大公约数 $g$ ，那么数组中的任意一个元素都是最大公约数 $g$ 的倍数。</p><p>我们在构造这个子序列的过程中，选择的最大公约数 $g$ 的倍数必须存在于数组中，否则就不能称之为子序列。</p><p>具体做法：</p><ul><li>首先确定最大公约数 $g$ 的范围，设 $m$ 为数组 $nums$ 的最大值。那么 $1 \le g \le m$</li><li>我们假设最大公约数 $x (1 \le x \le m)$ ，然后枚举出所有不大于 $m$ 且存在与数组 $nums$ 中的所有 $x$ 的倍数 $y$ 。当且仅当所有 $y$ 的最大公约数等于 $x$ 时，说明我们找到一个可行的 子序列。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> vis []<span class="keyword">bool</span> = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> y := x; y &lt;= m; y += x &#123;</span><br><span class="line">        <span class="keyword">if</span> vis[y] &#123;</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span> &#123;</span><br><span class="line">                t = y</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = gcd(t, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局遍历存在干扰，使用之前必须重置</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    vis = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span>(nums) &#123;</span><br><span class="line">        m = max(m, v)</span><br><span class="line">        vis[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> check(i) &#123;</span><br><span class="line">            ans ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n^2)$，其中 $n$ 为数组 $nums$ 中的最大值。</p><p>空间复杂度：$O(n)$，其中 $n$ 为数组 $nums$ 中的最大值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/truncate-sentence/&quot;&gt;截断句子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/probl
      
    
    </summary>
    
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%91%A8%E8%B5%9B/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%91%A8%E8%B5%9B/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="二分" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="哈希" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Spring IoC 容器</title>
    <link href="https://qybit.gitee.io/2021/04/03/Spring-IoC/"/>
    <id>https://qybit.gitee.io/2021/04/03/Spring-IoC/</id>
    <published>2021-04-03T12:13:32.000Z</published>
    <updated>2021-09-23T13:18:44.001Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 中最重要的就是 IoC 和 AOP，我们平时使用 Spring 最多的就是 IoC，那么为啥不去深入了解一下其中的原理呢？本篇作为 Spring IoC 源码探究的文章之一，后续有机会的话将会更新 Spring MVC、MyBatis 等源码探究。</p><p>阅读本篇时，请打开 IDE 和我一起深入 IoC 容器内部的工作环境，了解 IoC 的实现细节。</p><p>本文的着重点在于 </p><ol><li><p>Bean 容器的创建；</p></li><li><p>Bean 的实例化和初始化 </p></li></ol><p>如有不足之处，欢迎讨论。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>基本的 Spring 5.3.1 运行环境</li><li>支持断点调试的 IDE</li><li>本文选择从 xml 配置文件启动</li></ol><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开始分析代码之前，先看一下基本的一个架构图</p><p><img src="https://img.imgdb.cn/item/5fd4cb8a3ffa7d37b3513ae3.png"></p><p>基本的启动代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserController controller = applicationContext.getBean(<span class="string">&quot;userController&quot;</span>, UserController.class);</span><br><span class="line">    controller.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件 （接口或者类，请任意定义一个即可）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.qybit.spring.controller.UserController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>从 <code> ApplicationContext applicationContext = new ClassPathXmlApplicationContext(...);</code> 可以发现，我们是从 xml 文件加载的，而且是可以传入多个配置文件。</p><h1 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h1><p>进入 ClassPathXmlApplicationContext 类中，发现定义为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">// 这是我们 Spring 启动的一个核心方法</span></span><br><span class="line">            <span class="comment">// 下面我们会深入其内部，逐个分析各个方法具体做了什么</span></span><br><span class="line">            refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext#refresh 方法，refresh 方法是构建 ApplicatinContext 的，当一个 IoC 容器成功创建后，我们还可以调用 refresh 方法销毁原来的 ApplicationContext，然后进行重建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保证构建当前 ApplicationContext 的完整性，不能有别的线程干扰</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 不是重点，不管它</span></span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备 refresh，记录启动时间，设置激活状态</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是将 配置文件 中定义的 bean 标签，解析成 BeanDefition，然后注册到 BeanFactory</span></span><br><span class="line">        <span class="comment">// 此时仅仅是对 Bean 的定义信息的一个保存，而不是实例化操作</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的类加载，添加 BeanPostProcessor</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">            <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 BeanPostProcessor 的实现类，</span></span><br><span class="line">            <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">            <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i18n 国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 AppplicationContext 事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 钩子函数</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册事件监听器，需要实现 ApplicationListener 接口</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有的 Singleton Bean  lazy-init 除外</span></span><br><span class="line">            <span class="comment">// 核心</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一步，广播事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 日志记录</span></span><br><span class="line">            <span class="comment">// 销毁已经创建的 Bean</span></span><br><span class="line">            <span class="comment">// 撤销状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐个介绍 refresh() 方法里的重要方法</p><h2 id="refresh-的准备工作"><a href="#refresh-的准备工作" class="headerlink" title="refresh 的准备工作"></a>refresh 的准备工作</h2><p>看看代码就可以知道做了哪些事情</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验配置文件</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Bean-容器，并注册-Bean"><a href="#创建-Bean-容器，并注册-Bean" class="headerlink" title="创建 Bean 容器，并注册 Bean"></a>创建 Bean 容器，并注册 Bean</h2><p>回到 refresh() 方法中的 obtainFreshBeanFactory() 方法。</p><p>这一步是初始化 Bean 容器，并注册保存 Bean 的信息。这也是本文重点讨论的一个方法。注意此步并没有实例化 Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果存在过 BeanFactory就先销毁，然后创建新的 BeanFactory，加载 Bean 定义，注册 Bean等</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回新创建的 BeanFactory</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext#refreshBeanFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 假设存在过 BeanFactory，先销毁</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 BeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 设置 序列化 ID</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 自定义 BeanFactory，设置：是否允许 Bean 重写，是否允许循环引用</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载 Bean 定义</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext#customizeBeanFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否允许 Bean 重写</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否允许循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractXmlApplicationContext#loadBeanDefinitions</p><p>加载 Bean 信息</p><p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还在当前类中，我们已经实例化了 Reader，接下来是要把 xml 文件转换成一颗 DOM 树，用于获取用户定义的 Bean。</p><p>// AbstractXmlApplicationContext</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 下面逐个记载所有的配置文件</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 走到下面这一步</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        count += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向下走</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Collections.addAll(actualResources, resources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 320</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ThreadLocal 存放文件资源</span></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正执行的方法</span></span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类 386 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 转换成 DOM 树</span></span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// 开始注册</span></span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        ....</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 508 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 真正执行的方法</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 94 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 128 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    .......</span><br><span class="line">        <span class="comment">// 钩子函数</span></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">    <span class="comment">// 从 根节点 开始解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 钩子函数</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过漫长的寻找，我们找到了 parseBeanDefinitions(root, this.delegate) 最终的解析方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">// 默认的</span></span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他的</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看默认中处理 <code>&lt;bean /&gt;</code> 标签的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前文件 305 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p><table><thead><tr><th>Property</th><th></th></tr></thead><tbody><tr><td>class</td><td>类的全限定名</td></tr><tr><td>name</td><td>可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td>scope</td><td>作用域</td></tr><tr><td>constructor arguments</td><td>指定构造参数</td></tr><tr><td>properties</td><td>设置属性的值</td></tr><tr><td>autowiring mode</td><td>no(默认值)、byName、byType、 constructor</td></tr><tr><td>lazy-initialization mode</td><td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td>initialization method</td><td>bean 属性设置完成后，会调用这个方法</td></tr><tr><td>destruction method</td><td>bean 销毁后的回调方法</td></tr></tbody></table><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>// BeanDefinitionParserDelegate 428</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">    <span class="comment">// 当然，如果不定义 name 属性的话，就是空的了</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                        beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                        !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们开始说说注册 Bean 吧。</p><h2 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h2><p>// BeanDefinitionReaderUtils 158</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">// 注册这个 Bean</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">            <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>// DefaultListableBeanFactory 976</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不支持重写，将会报错</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">              <span class="comment">// log </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               <span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">        <span class="comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">        <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line">            <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">            <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">            <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">            <span class="comment">//registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">            <span class="comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h2 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h2><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">        beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略实现下面接口的实现类</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationStartup.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “手动注册的类”</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理。</p><h2 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h2><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p><p>// AbstractApplicationContext.java 834</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">    <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 初始化 所有的非懒加载 beans</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                            getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理普通的 bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">    <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.beans.smart-initialize&quot;</span>)</span><br><span class="line">                .tag(<span class="string">&quot;beanName&quot;</span>, beanName);</span><br><span class="line">            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">            smartInitialize.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将会进入到 getBean(beanName); 方法里了。</p><h2 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个 beanName</span></span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经创建过了</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">// log...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是获取 bean,直接返回</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// 已经创建过相同的 bean ，说明陷入了循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否存在 BeanDefintion</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，检查 父容器</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 typeCheckOnly 为 false, 会被放入 alreadyCreated 集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">            .tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">            &#125;</span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">            <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">// 检查是否存在依赖循环</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 先注册依赖的 bean</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取到 bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 重要方法</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">// 执行创建</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查创建的类型</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是 createBean(beanName, mbd, args); 方法了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保 BeanDefintion 中的 class 已经被加载</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备方法重写</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 正式开始要创建 bean 了！！</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-bean"><a href="#创建-bean" class="headerlink" title="创建 bean"></a>创建 bean</h2><p>跨越千山万水，我们终于找到了 doCreateBean 这个方法。请持续保持 debug 状态，我们将继续深入方法内部。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 的包装类</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是 bean 包装类中的真正 实例bean</span></span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">// bean 的类型</span></span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要解决 循环依赖 问题，可以了解一下 三级缓存 机制</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 bean ，上面仅仅是 实例化，还没有对属性进行赋值等操作</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化 bean 后的回调函数，比如 init-method 方法的执行</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就看完了创建 bean 的部分，下面将会重点介绍一下 实例化bean 和 初始化bean 的部分。我们仅仅是稍微瞄一眼即可，再深层次的细节，本人能力有限也分析不动。</p><h2 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h2><p>这一步是将之前注册和保存的 beanDefintion 给实例化成对象的过程。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="comment">// 检查访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">    <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="comment">// 构造函数注入</span></span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无参构造函数</span></span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="comment">// 构造函数注入</span></span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挑个简单的无参构造函数构造实例来看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(</span><br><span class="line">                (PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>),</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化</span></span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 包装返回</span></span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的重点在于这一行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这是实例化的地方，我们进去看看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">        <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这一步走完，我们的bean就算完成了实例化。下面看看初始化的过程</p><h2 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h2><p>这一步会对 bean 的属性进行赋值，以及钩子函数(init-method)的执行等操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">            <span class="comment">// 如果没有实例化成功</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口 InstantiationAwareBeanPostProcessors 后，可以在这一步执行</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bean 实例的所有属性都在这</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">        <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过类型匹配</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">            <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值</span></span><br><span class="line">            PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                &#125;</span><br><span class="line">                pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line">        checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h2><p>属性注入完毕后，就开始执行各种回调函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">        <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring 在设计之初，就给我们留下了非常多的可扩展部分，比如 BeanFactoryPostProcessor 可以在注册 BeanDefintion 时，对 BeanDefintion 进行增强或者加入新的 Bean定于。以及 BeanPostProcessor 接口，可以在分别在实例化和初始化后进行执行相应的方法。<br>FactoryBean 在本文就不再继续讨论下去了，感兴趣的可以自行测试。<br>本文的不足之处在于限于个人能力，以及篇幅的限制，很多地方都没有深入展开的进行说明。这也算是给自己挖了个坑，后面有精力再补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring 中最重要的就是 IoC 和 AOP，我们平时使用 Spring 最多的就是 IoC，那么为啥不去深入了解一下其中的原理呢？本篇作为 Spring IoC 源码探究的文章之一，后续有机会的话将会更新 Spring MVC、MyBatis 等源码探究。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="Java" scheme="https://qybit.gitee.io/tags/Java/"/>
    
      <category term="IoC" scheme="https://qybit.gitee.io/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>第 234 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/03/259/"/>
    <id>https://qybit.gitee.io/2021/04/03/259/</id>
    <published>2021-04-03T02:56:21.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></li><li> <a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></li><li> <a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></li></ul><p>换电脑(原来的破电脑显示屏不亮了。)导致题解丢失，这是重写的一份。┭┮﹏┭┮</p><h1 id="T1：字符串中不同整数的数目"><a href="#T1：字符串中不同整数的数目" class="headerlink" title="T1：字符串中不同整数的数目"></a>T1：<a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接模拟截取数字部分即可，注意前导 $0$ 。</p><p>不可以转成数字 $int$ 或者 $long$ 等 64 位的整形数字，可能会爆掉。因此直接使用字符串即可。</p><p>$Go$ 语言中并不存在 $Set$ 集合，因此我们在使用 $Map$ 时，给 $Value$ 随便赋一个值即可。这里取得 $0x3f3f3f3f$ 意义为“无限大”。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isDigit</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDifferentIntegers</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    st := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> isDigit(word[i]) &#123;</span><br><span class="line">            <span class="keyword">var</span> num []<span class="keyword">byte</span></span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; word[i] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; isDigit(word[i]) &#123;</span><br><span class="line">                num = <span class="built_in">append</span>(num, word[i])</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            st[<span class="keyword">string</span>(num)] = INF</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(st)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。我们只会扫描一次字符串。</p><p>空间复杂度：$O(\sum)$ ，其中 $\sum$ 表示数字集的大小。</p><h1 id="T2：还原排列的最少操作步数"><a href="#T2：还原排列的最少操作步数" class="headerlink" title="T2：还原排列的最少操作步数"></a>T2：<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>纯模拟题</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reinitializePermutation</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    perm := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        perm[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> flag <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> flag &#123;</span><br><span class="line">        ans ++</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                arr[i] = perm[i / <span class="number">2</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i] = perm[n / <span class="number">2</span> + (i - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(arr) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            perm[i] = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(k \times N)$ ，其中 $k$ 为最小执行次数，$N$ 为数组的长度。</p><p>空间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><h1 id="T3：替换字符串中的括号内容"><a href="#T3：替换字符串中的括号内容" class="headerlink" title="T3：替换字符串中的括号内容"></a>T3：<a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不存在嵌套的括号，因此我们可以直接遍历字符串当遇到一个 $()$ 时，截取 $()$ 内的内容，然后到 $knowledge$ 数组里找到对应的 $Value$ 即可。</p><p>直接在 $knowledge$ 里查找 $Value$ 的时间复杂度是 $O(N)$ 的，$N$ 为 $knowledge$ 数组的长度。因此，我们可以要尽可能的优化这一步的时间复杂度操作。</p><p>不难想到使用 哈希表 来实现 $O(1)$ 查找。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(s <span class="keyword">string</span>, knowledge [][]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, kn := <span class="keyword">range</span>(knowledge) &#123;</span><br><span class="line">        hash[kn[<span class="number">0</span>]] = kn[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> j <span class="keyword">int</span> = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j &lt; n &amp;&amp; s[j] != <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">                j ++</span><br><span class="line">            &#125;</span><br><span class="line">            k := s[i + <span class="number">1</span>:j]</span><br><span class="line">            <span class="keyword">if</span> key, ok := hash[k]; ok &#123;</span><br><span class="line">                ans += key</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="string">&quot;?&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += <span class="keyword">string</span>(s[i])</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。</p><p>空间复杂度：$O(N)$，其中 $N$ 为 $knowledge$ 数组的长度。</p><h1 id="T4：好因子的最大数目"><a href="#T4：好因子的最大数目" class="headerlink" title="T4：好因子的最大数目"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></h1><p>非常复杂的一道题，了解结论的话很容易做。</p><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>我们需要构造一个数 $x$ ，它的质因子数量最大不会超过 $primeFactors$ 个。</p><p>好因子：我们必须从这个数 $x$ 的 $n$ 个不同质因子 $a_i(1 \le i \le n)$，并假设其数量分别对应为 $b_i(1 \le i \le n)$。</p><p>举例子：比如当 $x = 200$，$primeFactors = 5$ 时，</p><p>存在一个满足的条件的质因子数组：$[2,2,2,5,5]$ ，其中质因子一共有两种，分别是 $a_1=2$ 和 $a_2=5$ ，它们的数量分别为 $b_1=3$ 和 $b_2=2$。</p><p>根据题目定义，我们在构造<strong>好因子</strong>的过程中，对于每一个质因子 $a_i$ 就必须选择 $b_i$ 个。</p><p>对于质因子 $a_1=2$ 而言，我们必须要拿 $1 \le b_1 \le 3$ 个，对于质因子 $a_2=5$ 也是同理 $1 \le b_2 \le 2$。 </p><p>我们开始构造<strong>好因子</strong>：</p><p>$b_1= 1, b_2=1$ 时，好因子数量：$[10]$</p><p>$b_1=2, b_2=1$ 时，好因子数量：$[10,20]$</p><p>$….$</p><p>注意到，当 $b_1 = 3$ 和 $b_2 = 2$ ，我们可以构造出 $b_1 \times b_2 =6$ 个好因子。分别为 $[10, 20,40,50,100,200]$ 。</p><h3 id="整理一下"><a href="#整理一下" class="headerlink" title="整理一下"></a>整理一下</h3><p>对于 $n$ 个质因子 $a_i$ 及其数量 $b_i$：<br>$$<br>a_1, \ a_2, \ a_3, \ a_4, \ …, \ a_n<br>$$<br>对于质因子的数量 $b_i$：<br>$$<br>b_1 + b_2 + b_3 + b_4 + … + b_n = primeFactors<br>$$</p><p>对于 $x$ ：<br>$$<br>a_1^{b_1} \times a_2^ {b_2} \times a_3^{b_3} \times…\times a_n^{b^n} = x<br>$$<br>对于最大的 <strong>好因子</strong> 数量：<br>$$<br>b_1 \times b_2 \times b_3 \times … \times b_n = ans<br>$$</p><p>我们可以得出一个结论：<strong>把一个数分出更多的质因子数量，使得它们数量的乘积尽可能的大，这样我们就可以构造出更多的好因子。</strong></p><p>此时，请思考一个问题？</p><blockquote><p>我们应该选择哪一个 质因子 才可以使一个数划分出更多份？</p></blockquote><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p><strong>函数极值证明法</strong></p><p>我们假设 $f(x)$ 为一个正整数 $n$ 按照 $x$ 划分时的最大乘积，则有 $x$ 项  $\frac{n}{x}$。即 $f(x) = x ^\frac{n}{x}$。</p><p>目标是求 $f(x)$ 的最大值，我们可以将式子变形一下：<br>$$<br>f(x) = x^\frac{n}{x} = e^{\frac{n \times lnx}{x}}<br>$$<br>令 $g(t) = e ^t$ ，$h(x) = \frac{lnx}{n}$ ，那么 $f(x) = g(n \times h(x))$，由于 $g(t)$ 是单调递增的，$n \gt 0$，所以 $f(x)$ 与 $h(x)$ 单调性相同。</p><p>我们计算 $h(x)$ 的驻点，$h’(x) = \frac{1 - lnx}{x^2} = 0$，得到 $x = e$ 。</p><p>得到驻点 $x = e$，当 $0 \lt x \lt e$ 时， $h’(x) \gt 0$ ，所以在 $0 \lt x \lt e$ 时，$h(x)$ 是单调递增的。</p><p>当 $x \gt e$ 时，$h’(x) \lt 0$ ，所以在 $x \gt e$ 时，$h(x)$是单调递减的。由此可知 $x = e$ 为 $h(x)$ 和 $f(x)$ 的极大值点。由于 $f(x)$ 在定义域连续，因此 $x =e $ 为 $f(x)$ 的最大值点。</p><p>那么， $e = 2.71…$ 并不是一个正整数，因此我们还需要比较 $f(2)$ 和 $f(3)$ 的大小，直接计算 $f(2) / f(3)$ 的值即可。<br>$$<br>\frac{f(2)}{f(3)} = \frac{e^{\frac{nln2}{2}}}{e^{\frac{nln3}{3}}} = e ^ {\frac{nln2}{2} - \frac{nln3}{3}} = e ^ \frac{n \times ln8-ln9}{6}<br>$$<br>由于 $ln8 \lt ln9$，$n &gt; 0$ ，所以 $f(2) \lt f(3)$ 。因此当 $x = 3$ 时，$f(x)$ 可以取得最大值。</p><p>上述过程为正整数 $n$ 可以整除 $3$ 时，当不够整除时，我们还需要用 $2$ 来凑。</p><p>因此，我们对于 $n$ 和 $3$ 的余数进行讨论：</p><ul><li>当余数为0时，即$n = 3m (m \ge 2)$，将 $n$ 拆分成 $m$ 个 $3$</li><li>当余数为1时，即$n = 3m+1 (m \ge 1)$ ，由于$2\times2 \gt 3 \times 1$，所以将 $n$ 拆分成 $m - 1$ 个 $3$ 和 $2$ 个 $2$</li><li>当余数为2时，即$n=3m+2(m \ge 1)$，将 $n$ 拆分成 $m$ 个 $3$ 和 $1$ 个 $2$</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>上述证明，我们以及得知当一个正整数 $x$ 按照 $3$ 拆分，然后补充 $2$ 时，可以使得其数量的乘积最大。也就是可以构造更多的好因子数量。</p><p>那么，对于本题已经给出了质因子的数量，我们反向冲一下，就可以求出最大值 $x$ ，也就是本题的答案。</p><p>注意由于 $n$ 的范围相当的大，因此在快速幂的过程中需要边取模边运算，否则会爆数据范围。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_pow</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> y &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ret *= x</span><br><span class="line">            ret %= MOD</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x</span><br><span class="line">        x %= MOD</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % MOD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxNiceDivisors</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m, quot <span class="keyword">int</span> = n / <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> quot == <span class="number">0</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> quot == <span class="number">1</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m) * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(lgN)$，其中 $N$ 最大为 $10^9$ 。</p><p>空间复杂度：$O(1)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/&quot;&gt;字符串中不同整数的数目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a hre
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="哈希表" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动技术支持实习面经</title>
    <link href="https://qybit.gitee.io/2021/04/01/1024/"/>
    <id>https://qybit.gitee.io/2021/04/01/1024/</id>
    <published>2021-04-01T07:18:59.000Z</published>
    <updated>2021-09-23T13:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔试：-3-7"><a href="#笔试：-3-7" class="headerlink" title="笔试： 3.7"></a>笔试： 3.7</h2><p><strong>T1</strong>：给定一个数组，对于数组中的每一个元素为，打印出数组中下一个更大的数，如果没有下一个更大的数，则打印-1。<br><strong>思路</strong>：单调栈。由于数据范围很小，所以暴力即可。</p><p><strong>T2</strong>：N 个小朋友围成一圈，你可以调整任意两个小朋友的位置。使得相邻小朋友的最大身高差的值最小。<br><strong>思路</strong>：单调栈</p><p><strong>T3</strong>：你现在是一名图书管理员，你可以处理两种指令。<br>指令格式如下：</p><ol><li><p><code>1 x y</code> 表示可以将图书x和图书y放在同一个书架上。</p></li><li><p><code>2 x y</code> 表示图书x和图书y不能放在同一个书架。</p></li></ol><p>现存在一个用户，向你提供了 $N$ 条指令。并询问这些指令的执行情况。<br>输出格式：</p><ol><li>如果所有指令，都可以正常执行，输出 YES</li><li>如果不能全部执行，且不能执行的 2 号指令，恰好为 3 条，请输出 3</li><li>请输出不能执行的指令数量</li></ol><p><strong>思路</strong>：并查集模板题，如果用数组模拟的话，数据范围很大 $10^9$ 直接就报错了。我认为改用 $unorderd_map$ 后理论上和数组是一致的，但是实际操作时忘记初始化了(我是SB)。</p><p><strong>T4</strong>：变态版 <a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a> (可以查看<a href="https://qybit.gitee.io/2021/03/20/72/">我的题解</a>)。</p><p>本题是给定不定长的字符串，要求从任意一个节点出发，经过若干次操作后可以变化的最大步长。<br><strong>思路</strong>：BFS（求最大步长），DP（DP效率似乎不怎么好，我在牛客上看的反馈还没我BFS过的多）</p><h2 id="一面-3-23-60mins"><a href="#一面-3-23-60mins" class="headerlink" title="一面 3.23 60mins"></a>一面 3.23 60mins</h2><ol><li>自我介绍</li><li>用过哪些集合？</li><li>说说 ArrayList、HashSet 和 HashMap 的常用方法。</li><li>你刚刚说ArrayList的底层是数组，那么我们为什么不使用数组？</li><li>说说ArrayList的扩容机制？具体是如何扩容的？</li><li>ArrayList 和 HashSet 的区别？</li><li>你用 HashSet 都存放过哪些数据类型？你是如何写这个自定义对象的？</li><li>为什么要重写 hashcode 和 equals 方法？</li><li>我看你用的是 MySQL，MySQL 和 Redis的区别？，说说 MySQL 的存储引擎吧？它们有什么区别？</li><li>你知道事务吗？说说事务的四大特性？</li><li>说说事务的隔离级别？</li><li>你都用过哪些数据类型？char 和 varchar 的区别是什么？</li><li>Redis有哪些数据类型？</li><li>说说 Spring 的事务。</li><li>你使用 MyBatis 是怎么写 SQL 语句的？</li><li>你写的 mapper 文件里都用过哪些标签，是怎么写的？</li><li>定义的 mapper 接口中的方法是如何执行的？</li><li>做题：<ol><li>统计数字的出现次数；</li><li>反转链表</li></ol></li><li>说说 static 和 final 关键字</li><li>JAVA虚拟机的内存模型是怎样的？（不是JAVA程序的运行内存模型）</li><li>类是如何加载的？</li><li>说说栈内存和堆内存，什么是栈帧？</li><li>假如遇到深层次的递归函数，会发生什么事情？你是如何解决的？</li><li>你遇到过 OOM 吗？你是如何解决的？</li><li>反问环节</li></ol><h2 id="二面：3-26-25mins"><a href="#二面：3-26-25mins" class="headerlink" title="二面：3.26 25mins"></a>二面：3.26 25mins</h2><ol><li>  自我介绍</li><li>介绍岗位工作职责</li><li>介绍项目</li><li>描述项目细节</li><li>MVC 软件架构了解吗？</li><li>反馈说上一面表现不错</li><li>做题：<ol><li>给定一个按钮，点击修改其内容</li><li>使用调试工具，比如 Postman 调用 API</li><li>手撕快速排序</li><li>反转字符串，空间 $O(1)$</li></ol></li><li>  如果一个网页，打开很慢的话，说说可能的原因？</li><li>  get 和 post 请求的区别。</li><li>  说说 http 和 https 的区别。</li><li>  说说三次握手和四次挥手。</li><li>  写一个 sql 语句吧，查询表中 100 个 id 大于 10 的记录。</li><li>  今天的面试就到这里了，你已经通过了，等 HR 电话吧。</li><li>  反问环节</li></ol><h2 id="HR面：3-30-20mins"><a href="#HR面：3-30-20mins" class="headerlink" title="HR面：3.30 20mins"></a>HR面：3.30 20mins</h2><ol><li>   HR自我介绍（我以为是技术面）</li><li>询问成绩</li><li>介绍项目</li><li>你为什么选择前端专业？</li><li>我看你是前端专业，为什么要选择后端？</li><li>关于在留心科技实验室当前端组长的一些问题</li><li>你为什么选择上海和杭州这两个城市？</li><li>你从出生到现在感受到最为挫折的一次经历？</li><li>   你未来的规划是怎么样的？</li><li>   你为什么选择字节跳动？你有投递其它公司吗？</li><li>   什么时候可以来实习？你能实习多久？</li><li>   同学和老师对你的评价中最多的关键词</li><li>   反问环节</li></ol><h2 id="已-OC：4-1"><a href="#已-OC：4-1" class="headerlink" title="已 OC：4.1"></a>已 OC：4.1</h2><p>最后是催着 HR 小姐姐给发的offer。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;笔试：-3-7&quot;&gt;&lt;a href=&quot;#笔试：-3-7&quot; class=&quot;headerlink&quot; title=&quot;笔试： 3.7&quot;&gt;&lt;/a&gt;笔试： 3.7&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;T1&lt;/strong&gt;：给定一个数组，对于数组中的每一个元素为，打印出数组中下一个更
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="字节跳动" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>第 48 场双周赛</title>
    <link href="https://qybit.gitee.io/2021/03/21/259/"/>
    <id>https://qybit.gitee.io/2021/03/21/259/</id>
    <published>2021-03-21T02:58:00.000Z</published>
    <updated>2021-09-23T13:18:44.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></li><li> <a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></li><li> <a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/"> N 次操作后的最大分数和</a></li></ul><h1 id="T1：字符串中第二大的数字"><a href="#T1：字符串中第二大的数字" class="headerlink" title="T1：字符串中第二大的数字"></a>T1：<a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></h1><p>注意到，这里给出的混合字符串中的数字，仅仅是指 $0-9$ 之间的数字。</p><p>方法一：我们使用有序的 $set$ 集合，插入后取倒数第二个元素即可。</p><p>$Java$ 中使用 $TreeSet$ 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                st.insert(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = st.end();</span><br><span class="line">        it --, it --;</span><br><span class="line">        <span class="keyword">return</span> *(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。</p><p>空间复杂度：$O(1)$，其中 $set$ 集合，使用的空间最大仅为 $10$ 个元素。</p><h1 id="T2：设计一个验证系统"><a href="#T2：设计一个验证系统" class="headerlink" title="T2：设计一个验证系统"></a>T2：<a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目描述非常的长。实际上，我们只需要关注如下信息即可。</p><ul><li>$tokenId$ 具有唯一性，且数据级别是 $N$ ，那么我们的查找时间复杂度就尽可能的要满足 $O(1)$，不难想到哈希表</li><li>$token$ 的存活时间为 $currentTime + timeToLive$，我们在进行查询存活数量时，只需要检查当前时间是否小于存活时间即可</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// int[] life = &#123;live -&gt; dead&#125;</span></span><br><span class="line">    <span class="keyword">int</span> liveTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthenticationManager</span><span class="params">(<span class="keyword">int</span> timeToLive)</span> </span>&#123;</span><br><span class="line">        liveTime = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        map.put(tokenId, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;currentTime, currentTime + liveTime&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(tokenId)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] life = map.get(tokenId);</span><br><span class="line">        <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">            <span class="comment">// 还没死</span></span><br><span class="line">            life[<span class="number">0</span>] = currentTime;</span><br><span class="line">            life[<span class="number">1</span>] = currentTime + liveTime;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(tokenId, life);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, <span class="keyword">int</span>[]&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] life = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为 $Map$ 中所有 $tokenId$ 的数量</p><ul><li><code>AuthenticationManager#generate</code> 操作时间复杂度为 $O(1)$</li><li><code>AuthenticationManager#renew</code> 操作时间复杂度为 $O(1)$</li><li><code>AuthenticationManager#countUnexpiredTokens</code> 操作时间复杂度为 $O(N)$，我们需要遍历 $Map$ 集合。</li></ul><p>空间复杂度：$O(N)$</p><h1 id="T3：你能构造出连续值的最大数目"><a href="#T3：你能构造出连续值的最大数目" class="headerlink" title="T3：你能构造出连续值的最大数目"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></h1><h2 id="方法一：数学推导"><a href="#方法一：数学推导" class="headerlink" title="方法一：数学推导"></a>方法一：数学推导</h2><p>我们对数组进行排序，使得我们选择下一个元素时，尽可能的接近。</p><p>子问题：</p><p>假如连续整数为 $[0, 0]$ ，那么下一个元素必须满足为 $coins[0] \le 1$ ，才能保证整数连续。</p><p>归纳：</p><ul><li>对于连续整数 $[0, 1]$，那么 $coins[1] \le 2$ 使得整数为 $[0, 1 + coins[1]]$才能保证整数连续。</li><li>对于连续整数 $[0, x]$，那么 $coins[i] \le x + 1$ 使得整数为 $[0, x + coins[i]]$ 才能保证整数连续。</li></ul><p>证明：</p><p>假设前 $i$ 个元素已经构成连续整数 $[0, n]$ ，且下一个数为 $m$ 时：</p><p>若 $m &gt; n + 1$ 时，此时可以构成的整数分别为 $[0, n]$ ， $[m, m + n + 1]$ 。存在 $m \gt n + 1 \gt n$。则整数不连续。</p><p>因此要想整数连续递增，必须保证 $m \le n + 1$，使得整数连续为 $[0, n + m + 1]$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        sort(coins.begin(), coins.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + <span class="number">1</span> &lt; coin) <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">            now += coin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlogN)$，其中 $N$ 为数组长度。</p><p>空间复杂度：$O(logN)$</p><h1 id="T4：N-次操作后的最大分数和"><a href="#T4：N-次操作后的最大分数和" class="headerlink" title="T4：N 次操作后的最大分数和"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/">N 次操作后的最大分数和</a></h1><h2 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h2><p>首先看看题目是如何定义第 $i$ 次操作（$i$ 从 <strong>1</strong> 开始）：</p><ul><li>选择两个元素 $x$ 和 $y$</li><li>获得分数 $i \times gcd(x, y)$</li><li>删除 $x$ 和 $y$</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>我们也不必再关注 $nums$ 数组本身，因为我们的分数计算实际上是 $ i \times gcd(x,y)$，即与 $x$ 和 $y$ 的<strong>最大公约数和操作次数</strong>有关的。因此，我们可以<strong>预处理</strong> $nums$ 数组所有下标 $i$ 和 $j$ 的组合对应的最大公约数。</p><p>我们需要选择任意两个元素，也就是任意两个未使用过的下标，直到用完所有的操作次数。</p><p>那么，我们就可以尝试所有可能的起点，并使用一个 $path$ 数组记录我们选择元素对应的最大公约数。</p><p>当我们的操作数全部用完时，对选择的最大公约数进行排序处理（因为并没有限制操作的顺序），使得 <strong>较大的操作次数 * 较大的最大公约数</strong> 来获得最大的分数。</p><h3 id="具体实现如下："><a href="#具体实现如下：" class="headerlink" title="具体实现如下："></a>具体实现如下：</h3><p>对于任意一次操作 $i$ ，我们有：</p><ul><li>选择一个从未使用过的下标作为元素 $x$，对应下标为 $s$</li><li>再选择一个从未使用过的下标作为元素 $y$，对应下标为 $u$</li><li>我们将其对应的最大公约数 $g[s][u]$ 加入到 $path$ 数组</li><li>当我们的操作次数使用完毕时，此时 $path$ 数组中已经存在 $n / 2$ 个元素，我们获得分数的理念是 <strong>较大的操作次数 * 较大的最大公约数</strong> 。因此对 $path$ 进行备份，然后排序计算此轮获得的最大分数并更新<strong>历史最大值</strong>。</li><li>我们再回溯到选择元素 $y$ 的场景。此时我们将不再选择元素 $y$ ，将下标 $u$ 标记为未使用。如果没有元素可供选择时。</li><li>我们再次回溯到选择元素 $x$ 的场景。与选择元素 $y$ 同理。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1e9</span>; <span class="comment">// 历史最大值</span></span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">20</span>]; <span class="comment">// 标记数组</span></span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">// 预处理 最大公约数</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">// 数组长度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q, path; <span class="comment">// q 为 nums 备份，path 为选择路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = path;</span><br><span class="line">            sort(t.begin(), t.end());</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &gt;&gt; <span class="number">1</span>; i ++) &#123;</span><br><span class="line">                res += (i + <span class="number">1</span>) * t[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                s = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        used[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[u]) &#123;</span><br><span class="line">                used[u] = <span class="literal">true</span>;</span><br><span class="line">                path.push_back(g[s][u]);</span><br><span class="line">                dfs(cnt + <span class="number">1</span>);</span><br><span class="line">                used[u] = <span class="literal">false</span>;</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        used[s] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        n = nums.size();</span><br><span class="line">        q = nums;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                g[i][j] = g[j][i] = gcd(nums[i], nums[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q.begin(), q.end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N^2 + N!)$，其中 $N$ 为数组的长度。</p><ul><li>我们需要预处理 $nums$ 数组</li><li>回溯的时间复杂度大致是这个级别，推测出来的量级</li></ul><p>空间复杂度：$O(N^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/second-largest-digit-in-a-string/&quot;&gt;字符串中第二大的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="哈希表" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="回溯" scheme="https://qybit.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="设计" scheme="https://qybit.gitee.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="动态规划" scheme="https://qybit.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="递归" scheme="https://qybit.gitee.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>72. 编辑距离</title>
    <link href="https://qybit.gitee.io/2021/03/20/72/"/>
    <id>https://qybit.gitee.io/2021/03/20/72/</id>
    <published>2021-03-20T05:09:15.000Z</published>
    <updated>2021-09-23T13:18:43.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>我们要求 $word1$ 变成 $word2$ 的最少操作次数。</p><p>操作如下：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>基本指导思想，对于 $word1$ 中所有的下标，我们尝试所有可能的操作，期望可以达到 $word2$ 。但是这样的时间复杂度将会达到 指数级。因此是不可能通过本题的。但我们也可以使用记忆化的方式优化。</p><h2 id="方法一：DFS-剪枝"><a href="#方法一：DFS-剪枝" class="headerlink" title="方法一：DFS + 剪枝"></a>方法一：DFS + 剪枝</h2><p>使用两个指针分别为 $i$ 和 $j$ ，分别指向 $word1$ 和 $word2$ ，我们借助指针的移动来对 $word1$ 模拟上述的 $3$ 种操作。</p><p>这里我们可以假设 $word1[0, i-1]$ 的字符 和 $word2[0, j-1]$ 已经完全相等了，此时我们的指针分别指向 $word1$ 的第 $i$ 个字符 和 $word2$  和 第 $j$ 个字符。 对于下述的操作，我们始终是在 <strong>操作</strong> $word1$ 。</p><p>具体实现如下：</p><ul><li>当 $word1[i] = word2[j]$ 时，我们同时移动指针 $i$ 和 $j$ 向右一位。</li><li>当 $word1[i] \neq word2[j]$ 时：<ul><li>当我们选择 【删除】时，我们移动指针 $i$ 向右一位。这里实际上对于 $word1$ 而言是 【跳过】 当前字符，让 $word1$ 的下一个字符和 $word2$ 的第 $j$ 个字符得以匹配相等，而在 $word2$ 看来，我们好像是多了一个字符。因此对于 $word2$ 而言，$word2$ 是多了一个字符。</li><li>当我们选择 【插入】时，我们移动指针 $j$ 向右一位。实际上对于 $word2$ 而言是 【跳过】当前字符，让 $word2$ 的下一个字符和 $word1$ 的第 $i$ 个字符得以匹配相等。对于 $word2$ 同理，在 $j$ 的位置进行 $word2$  的 【删除】操作。</li><li>当我们选择 【替换】时，实际上是和 $word1[i] = word2[j]$ 情况一致的。我们把指针 $i$ 和 $j$ 同时向右移动一位。</li></ul></li><li>在指针 $i$ 和 $j$ 没有把 $word1$ 或者 $word2$ 扫描完毕之前，我们重复上述操作。</li><li>当任意一个指针到达字符串末尾时，即说明我们存在一个方案使得 $word1 = word2$，。因为对于任意一个 $i (0 \le i \le word1.length, j同理)$ ，我们都存在最多可以有 $3$ 种选择分支。因此，我们需要在 【删除】、【插入】和【替换】三种操作取最小值。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>由上述搜索的思路，我们可以发现。虽然我们可能的操作一共是 $6$ 种。但是对于 $word1$ 的【删除】操作，等效于对 $word2$ 进行【插入】操作。所以我们的最终操作方案实际上是 $3$ 种。</p><ul><li>$word1$ 的【插入】操作，等效于 $word2$ 的【删除】操作</li><li>$word1$ 的【删除】操作，等效于 $word2$ 的【插入】操作</li><li>$word1$ 的【替换】操作，等效于 $word2$ 的【替换】操作。</li></ul><p>公式化描述：</p><p>前提条件是，$word1[0, i-1]$ 和 $word2[0, j-1]$ 已经完全相等了。$f(i, j)$ 表示 $word1$ 的前 $i (0 \le i \le word1.length)$ 个字符转变成 $word2$ 前 $j(0 \le j \le word2.length)$ 个字符所需的最小操作次数。那么存在<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>PS：不相等时，加 $1$ 是因为我们选择了任意一个操作。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> word1, <span class="keyword">int</span> i, <span class="built_in">string</span> word2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= word1.size() || j &gt;= word2.size()) &#123;</span><br><span class="line">            mem[i][j] = word1.size() - i + word2.size() - j;</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">            mem[i][j] = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> increased = dfs(word1, i, word2, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> deleted = dfs(word1, i + <span class="number">1</span>, word2, j);</span><br><span class="line">        <span class="keyword">int</span> modify = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">        mem[i][j] = min(increased, min(deleted, modify)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">        <span class="keyword">return</span> dfs(word1, <span class="number">0</span>, word2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(3^{max{n, m}})$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p><ul><li>但是由于我们存在缓存数组，因此时间复杂度是远远小于这个级别的。具体的时间复杂度我也没有办法分析。</li></ul><p>空间复杂度：$O(n \times m)$，我们要缓存字符串所有可能状态的最小操作数。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>由上一步，我们通过 【自顶向下】的一顿分析，递推出来的式子。进行改造<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>我们需要注意的点，就是边界问题，也就是当 $i=0$ 或者 $j = 0$ 时，当任意一个字符串为空串时，我们的改变次数等于不为空的字符串的长度。</p><p>我们的动态规划转移公式仍然定义为： $f[i][j]$，表示 $word1[0,i]$ 与 $word2[0,j]$ 完全相等的最小操作次数。 </p><p>因此，动态规划的转移方程为：</p><ul><li>当 $word1[i] = word2[j]$ ，$f[i][j] = f[i-1][j-1]$，相等时，不需要任何操作。</li><li>当 $word1[i] \ne word2[j]$，$f[i][j] = min{f[i-1][j], f[i-1][j-1], f[i][j-1]} + 1$，我们从三种操作中，选择最小的一种进行一次操作。</li></ul><p>解释：</p><ul><li>$f[i-1][j]$ 表示将 $word1[0, i -1]$ 的第 $i$ 个字符【删除】后，使得 $word1[0,i] = word2[0, j]$</li><li>$f[i-1][j-1]$ 表示将 $word1[0,i-1]$ 的第 $i$ 个字符进行【修改】后，使得 $word1[0,i] = word2[0,j]$</li><li>$f[i][j-1]$ 表示在 $word1[0,i]$ 【插入】一个字符后，使得 $word1[0, i] = word2[0,j]$</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.size(), m = word2.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) </span><br><span class="line">            f[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) </span><br><span class="line">            f[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j], min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n \times m)$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p><p>空间复杂度：$O(n \times m)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;我们要求 $word1$ 变成 $word2$ 的最少操作次数。&lt;/p&gt;
&lt;p&gt;操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="DP" scheme="https://qybit.gitee.io/tags/DP/"/>
    
      <category term="DFS" scheme="https://qybit.gitee.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>第 232 场周赛</title>
    <link href="https://qybit.gitee.io/2021/03/15/w232/"/>
    <id>https://qybit.gitee.io/2021/03/15/w232/</id>
    <published>2021-03-15T02:56:07.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/">仅执行一次字符串交换能否使两个字符串相等</a></li><li> <a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">找出星型图的中心节点</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li></ul><h1 id="T1：仅执行一次字符串交换能否使两个字符串相等"><a href="#T1：仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="T1：仅执行一次字符串交换能否使两个字符串相等"></a>T1：<a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/">仅执行一次字符串交换能否使两个字符串相等</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于数据范围比较小，$1 \le s1.length, s2.length \le 100$，我们可以直接暴力的枚举字符串 $s1$ 或者 字符串 $s2$ 的交换字符的下标，然后再判断是否相等即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAlmostEqual</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="keyword">if</span> (s2.size() != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                swap(s1[i], s1[j]);</span><br><span class="line">                <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                swap(s1[i], s1[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^3)$ ，其中 $N$ 为字符串 $s1$ 或者 $s2$ 的长度。</p><ul><li>字符串的下标交换方式一共存在 $N^2$ 种，我们每一次交换都需要判断字符串 $s1$ 和 $s2$ 是否相等。</li><li>判断字符串是否相等，只能遍历两字符串。因此时间复杂度一共为 $O(N^3)$。</li></ul><p>空间复杂度：$O(1)$</p><h1 id="T2：找出星型图的中心节点"><a href="#T2：找出星型图的中心节点" class="headerlink" title="T2：找出星型图的中心节点"></a>T2：<a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">找出星型图的中心节点</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一：dfs"><a href="#方法一：dfs" class="headerlink" title="方法一：dfs"></a>方法一：dfs</h3><p>直接对给定的边，建图进行 dfs，遍历。</p><p>从某一个节点出发，找到一个可以到达所有的节点的点。</p><p>时间复杂度为 $O(N^2)$，空间复杂度为 $O(N^2)$</p><h3 id="方法二：建图优化"><a href="#方法二：建图优化" class="headerlink" title="方法二：建图优化"></a>方法二：建图优化</h3><p>我们不必去写繁杂的 dfs 代码，建图的过程中我们可以选择 <strong>邻接矩阵</strong>，存储图。然后遍历每一行，判断该行与其他列，是否都存在边。</p><p>时间复杂度为 $O(N^2)$，空间复杂度为 $O(N^2)$</p><h3 id="方法三：统计每个点的度数"><a href="#方法三：统计每个点的度数" class="headerlink" title="方法三：统计每个点的度数"></a>方法三：统计每个点的度数</h3><p>我们甚至都不必去存储所有的图的节点信息，我们可以注意到<strong>星型图</strong>的中心节点，是与所有的点都存在边，当我们找到<strong>某个点的度数等于边数</strong>时，即表示该点为中心节点。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCenter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.size() + <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deg</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>];</span><br><span class="line">            deg[a] ++, deg[b] ++;</span><br><span class="line">            <span class="keyword">if</span> (deg[a] == n) <span class="keyword">return</span> a;</span><br><span class="line">            <span class="keyword">if</span> (deg[b] == n) <span class="keyword">return</span> b; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == edges.size()) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N)$，其中 $N$ 为点的数量。</p><p>空间复杂度：$O(N)$。</p><h1 id="T3：最大平均通过率"><a href="#T3：最大平均通过率" class="headerlink" title="T3：最大平均通过率"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></h1><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>对于某一个班级 $calsses[i] = [x_i, y_i]$ 而言，其原本的通过率为 $\frac{x}{y}$。那么我们加入一个保证能够过线学生后，存在<br>$$<br>\theta =  \frac{x + 1}{y + 1} - \frac{x}{y}，\theta (0 \lt \theta \lt1) \ 表示添加学生后，通过率增长幅度<br>$$<br>当我们在该班级继续加入学生后，存在<br>$$<br>\theta_1 = \frac{x_2 + 1}{y_2 + 1} - \frac{x_1}{y_1}， \<br>\theta_2 = \frac{x_4 + 1}{y_4 + 1} - \frac{x_3}{y_3}， \<br>\theta_2 \gt \theta_1<br>$$<br>即班级的通过率是单调递增的。</p><p>当某个班级的通过率呈现最大化后，即表示所有班级的平均通过率最大。</p><p>贪心的体现为：</p><p>当所有的班级都呈现通过率 $\theta$ 单调递增时，假设我们现在将一个学生加入班级，那么我们需要在 $N$ 个班级中，快速选择出一个 $\theta$ 最大的班级(借助堆优化)。这样就可以使所有班级的平均通过率最大。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> w;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((x + <span class="number">1.0</span>) / (y + <span class="number">1.0</span>)) - ((<span class="keyword">double</span>)x / y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Node&gt; heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : classes) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[<span class="number">0</span>], y = c[<span class="number">1</span>];</span><br><span class="line">            ans += (<span class="keyword">double</span>)x / y;</span><br><span class="line">            heap.push(&#123;cal(x, y), x, y&#125;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (extraStudents --) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            ans += t.w;</span><br><span class="line">            <span class="keyword">int</span> x = t.a + <span class="number">1</span>, y = t.b + <span class="number">1</span>;</span><br><span class="line">            heap.push(&#123;cal(x, y), x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / classes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N logN)$，其中 $N$ 表示为额外添加的学生数量。</p><ul><li>我们需要预处理所有的班级，计算出最初始的增长幅度，然后加入到 <strong>堆</strong> 中维护。时间复杂度 $O(NlogN)$</li><li>我们要把这些额外的学生，分别都加入到 <strong>堆顶</strong> 的第一个班级里去，并且重新计算增长幅度。时间复杂度 $O(NlogN)$</li></ul><p>空间复杂度：$O(N)$，我们使用结构体存储班级，并维护额外的信息。</p><h1 id="T4：好子数组的最大分数"><a href="#T4：好子数组的最大分数" class="headerlink" title="T4：好子数组的最大分数"></a>T4：<a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/">好子数组的最大分数</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h2 id="方法二：双指针-贪心"><a href="#方法二：双指针-贪心" class="headerlink" title="方法二：双指针 + 贪心"></a>方法二：双指针 + 贪心</h2><p>子数组的定义为： $min{ nums[i], nums[i+1],…,nums[j]} \times (j - i + 1)$。且满足 $i \le k \le j$。</p><p>算法实现流程：</p><ul><li>我们直接以下标 $k$ 为可能区间 $[i, j]$ 的中心点，然后分别以指针 $left$, 指令 $right$ 左右扩展<ul><li>当 $ left &gt;= 0 \ 时 \ nums[k] \le nums[left]$，指针 $left$ 恒向左扫描。</li><li>当 $right &lt; n \ 时 \ nums[k] \le nums[right]$，指针 $right$ 恒向右扫描。</li><li>当 指针 $left \lt 0 \ 且 \ right \gt n$ 时，表示我们已经扫描完整个数组。</li><li>当 $left \ge 0 \ 且 \ right \lt n$ ， 表示我们还未扩展到边界，为了求得最大值，我们以左右边界中任意一个最大值，作为中心点继续扩展。</li><li>当 $left \lt 0$ ，表示左边界已经没有元素，将右边界定义为中心点。</li><li>当 $right \ge n$ ，表示右边界已经没有元素，同理。</li><li>我们循环上述操作，直至在数组中找到一个最小值，然后扩展至整个数组后退出。</li></ul></li></ul><p>贪心的体现：</p><p>当我们扫描到边界值时 (且满足 $left \ge 0 \ 或 \ right \lt n$)，我们会在左右边界选择一个最大值，作为新区间的中心点。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = k, r = k, mi = nums[k];</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; nums[r] &gt;= nums[k]) r ++;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l] &gt;= nums[k]) l --;</span><br><span class="line">            ans = max(ans, (r - l - <span class="number">1</span>) * nums[k]);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span> &amp;&amp; r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n) nums[k] = max(nums[l], nums[r]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">0</span>) nums[k] = nums[r];</span><br><span class="line">            <span class="keyword">else</span> nums[k] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><ul><li>对于数组中的元素任意一个元素，我们在最坏的情况下，都不会访问达到 $N$ 次。</li></ul><p>空间复杂度：$O(1)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/&quot;&gt;仅执行一次字符串交换能否使两个字符串相等&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="图" scheme="https://qybit.gitee.io/tags/%E5%9B%BE/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>10. 正则表达式匹配</title>
    <link href="https://qybit.gitee.io/2021/03/11/259/"/>
    <id>https://qybit.gitee.io/2021/03/11/259/</id>
    <published>2021-03-11T14:24:52.000Z</published>
    <updated>2021-09-23T13:18:43.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一：递归-双指针"><a href="#方法一：递归-双指针" class="headerlink" title="方法一：递归 + 双指针"></a>方法一：递归 + 双指针</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于只存在 <code>.</code> 的字符，我们很容易去判断字符串 $p$ 是否可以匹配 $s$。</p><p>对于 <code>*</code> 字符，我们必须结合前一个字符来判断是否可以完成匹配。</p><p>具体实现：</p><ul><li>使用两个指针 $i$  和 $j$，分别指向字符串 $s$ 和 字符串 $p$。当字符串 $p$ 匹配完毕时，若指针 $i$ 未能走完整个字符串 $s$ ，那么表示当前路径不能成功匹配字符串 $s$ 。</li><li>对于特殊字符  <code>.</code>  和 <code>*</code> 而言，我们必须分情况讨论：<ul><li>对于单个字符而言，当 $s[i] = p[j]$ 时，或者 $p[j] = ‘.’$  时，此时我们是可以正常匹配的，我们还需要存储当前的结果，因为我们下一个字符可能是 <code>*</code></li><li>如果下一个字符为 <code>*</code> 时，我们必须要联系字符串 $s$ 的前一个字符，因此我们这里有两种选择方式：<ul><li>我们可以使用 <code>*</code>  ，将指针 $i$ 移动到下一位，去匹配下一个<strong>相同的</strong>字符。</li><li>还有就是跳过这个 <code>*</code> ，我们将指针 $j$ 移动两位，跳过 <code>*</code>。选择不匹配</li></ul></li><li>如果当前指针 $j$ 的下一个字符并不是 <code>*</code> 时，我们可以尝试去同时移动指针 $i$ 和 指针 $j$，当指针 $j$ 走完时，即停止递归。</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>PS：时空复杂度实际上我并不会分析，只知道这个递归的时间复杂度非常之大。<strong>C++</strong> 是直接超时的。<strong>Java</strong> 在力扣由于没有记录 <strong>JVM</strong> 的启动时间，所以是可以骗过的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) </span><br><span class="line">            <span class="keyword">return</span> i == s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> first = i &lt; s.length() &amp;&amp; (p.charAt(j) == <span class="string">&#x27;.&#x27;</span> || s.charAt(i) == p.charAt(j));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j)) || dfs(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O((n + m) \times 2 ^ {n + m})$，其中 $n$ 和 $m$ 分别为字符串 $s$ 和 字符串 $m$ 的长度。</p><ul><li>我们至少需要遍历完字符串 $s$ 和 字符串 $p$ 。</li><li>对于存在 <code>*</code> 的情况下，我们存在两个递归路径，而每一个递归路径都必须等待指针 $j$  或者指针 $i$ 扫描完毕才可以退出。</li></ul><p>空间复杂度：$O(1)$，我们使用双指针递归操作，并没有使用额外的存储空间。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>添加备忘录似乎可以减轻时间上的复杂度</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        <span class="keyword">if</span> (j == p.size()) <span class="keyword">return</span> i == s.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> first = i &lt; s.size() &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.size() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            mem[i][j] = (first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j)) || dfs(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        mem[i][j] = first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>C++</strong> 也能通过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一：递归-双指针&quot;&gt;&lt;a href=&quot;#方法一：递归-双指针&quot; class=&quot;headerlink&quot; title=&quot;方法一：递归 + 双指针&quot;&gt;&lt;/a&gt;方法一：递归 + 双指针&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="dfs" scheme="https://qybit.gitee.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类的加载机制</title>
    <link href="https://qybit.gitee.io/2021/03/10/JVM_CHAPTER7/"/>
    <id>https://qybit.gitee.io/2021/03/10/JVM_CHAPTER7/</id>
    <published>2021-03-10T02:25:27.000Z</published>
    <updated>2021-09-23T13:18:44.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【转载】"><a href="#【转载】" class="headerlink" title="【转载】"></a>【转载】</h2><p>本文作者<strong>：</strong><a href="https://www.cnblogs.com/kylinxxx/p/13778513.html">WMS</a><br><strong>本文链接</strong>：<a href="https://www.cnblogs.com/kylinxxx/p/13778513.html">https://www.cnblogs.com/kylinxxx/p/13778513.html</a><br><strong>关于博主</strong>：评论和私信会在第一时间回复。或者<a href="https://msg.cnblogs.com/msg/send/kylinxxx">直接私信</a>我。<br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">BY-NC-SA</a> 许可协议。转载请注明出处！<br><strong>声援博主</strong>：如果您觉得文章对您有帮助，可以点击文章右下角<strong>【<a href="javascript:void(0);">推荐</a>】</strong>一下。您的鼓励是博主的最大动力！</p><h1 id="虚拟机类的加载机制"><a href="#虚拟机类的加载机制" class="headerlink" title="虚拟机类的加载机制"></a>虚拟机类的加载机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类的加载机制。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？</p><ul><li>主动引用<ul><li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：<ul><li>使用 new 实例化对象；</li><li>读取或设置一个类的 static 字段（被 final 修饰的除外）；</li><li>调用类的静态方法。</li></ul></li><li>对类进行反射调用；</li><li>初始化一个类时，其父类还没初始化（需先初始化父类）；<ul><li>这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。</li></ul></li><li>虚拟机启动，先初始化包含 main() 函数的主类；</li><li>JDK 1.7 动态语言支持：一个 <code>java.lang.invoke.MethodHandle</code> 的解析结果为 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>。</li></ul></li><li>被动引用<ul><li>通过子类引用父类静态字段，不会导致子类初始化；</li><li><code>Array[] arr = new Array[10]</code>; 不会触发 Array 类初始化；</li><li><code>static final VAR</code> 在编译阶段会存入调用类的常量池，通过 <code>ClassName.VAR</code> 引用不会触发 ClassName 初始化。</li></ul></li></ul><p>也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。</p><hr><blockquote><p>类的生命周期</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/reprint/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png"></p><hr><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><blockquote><p>加载</p></blockquote><p><strong>加载（Loading）</strong>阶段，虚拟机需要完成以下三件事：</p><ul><li>通过一个类的全限定名来获取定义这个类对应的二进制字节流</li><li>将这个类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这些数据的访问入口。</li></ul><blockquote><blockquote><p>分类</p></blockquote></blockquote><ul><li>非数组类<ul><li>系统提供的引导类加载器</li><li>用户自定义的类加载器</li></ul></li><li>数组类<ul><li>不通过类加载器，由 Java 虚拟机直接创建</li><li>创建动作由 newarray 指令触发，new 实际上触发了 [L全类名 对象的初始化</li><li>规则<ul><li>数组元素是引用类型<ul><li>加载：递归加载其组件</li><li>可见性：与引用类型一致</li></ul></li><li>数组元素是非引用类型<ul><li>加载：与引导类加载器关联</li><li>可见性：public</li></ul></li></ul></li></ul></li></ul><blockquote><blockquote><p>类的显式加载和隐式加载</p></blockquote></blockquote><ul><li>显示加载：<ul><li>调用 <code>ClassLoader#loadClass(className)</code> 或 <code>Class.forName(className)</code>。</li><li>两种显示加载 .class 文件的区别：<ul><li><code>Class.forName(className)</code> 加载 class 的同时会初始化静态域，<code>ClassLoader#loadClass(className)</code> 不会初始化静态域；</li><li><code>Class.forName</code> 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。</li></ul></li></ul></li><li>隐式加载：<ul><li>new 类对象；</li><li>使用类的静态域；</li><li>创建子类对象；</li><li>使用子类的静态域；</li><li>其他的隐式加载，在 JVM 启动时：<ul><li><code>BootStrapLoader</code> 会加载一些 JVM 自身运行所需的 Class；</li><li><code>ExtClassLoader</code> 会加载指定目录下一些特殊的 Class；</li><li><code>AppClassLoader</code> 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。</li></ul></li></ul></li></ul><blockquote><p>验证</p></blockquote><p>目的： 确保 .class 文件中的字节流信息符合虚拟机的要求。</p><p>4 个验证过程：</p><ul><li>文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” 0xCAFEBABE<ul><li>魔数：每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的class文件。</li></ul></li><li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析）</li><li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）</li><li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验</li></ul><p>这个操作虽然重要，但不是必要的，可以通过 <code>-Xverify:none</code> 关掉。</p><blockquote><p>准备</p></blockquote><p>描述： 为 static 变量在方法区分配内存。</p><ul><li>static 变量准备后的初始值：<ul><li>public static int value = 123;<ul><li>准备后为 0，value 的赋值指令 putstatic 会被放在 <code>&lt;clinit&gt;()</code> 方法中，<code>&lt;clinit&gt;()</code>方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。</li></ul></li><li>public static final int value = 123;<ul><li>准备后为 123，因为被 static final 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。</li></ul></li></ul></li></ul><blockquote><p>解析</p></blockquote><p>描述： 将常量池中的 “符号引用” 替换为 “直接引用”。</p><p>在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。</p><blockquote><blockquote><p>什么是 “符号引用” 和 “直接引用” ？</p></blockquote></blockquote><ul><li>符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。</li><li>直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。</li></ul><blockquote><p>初始化</p></blockquote><p>描述： 执行类构造器 () 方法的过程。</p><ul><li><code>&lt;clinit&gt;()</code> 方法<ul><li>包含的内容：<ul><li>所有 static 的赋值操作；</li><li>static 块中的语句；</li></ul></li><li><code>&lt;clinit&gt;()</code> 方法中的语句顺序：<ul><li>基本按照语句在源文件中出现的顺序排列；</li><li>静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。</li></ul></li><li>与 <code>&lt;init&gt;()</code> 的不同：<ul><li>不需要显示调用父类的 <code>&lt;clinit&gt;()</code> 方法；</li><li>虚拟机保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法一定执行完毕。也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。</li></ul></li><li>接口与类的不同：<ul><li>执行子接口的 <code>&lt;clinit&gt;()</code> 方法前不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法（除非用到了父接口中定义的 public static final 变量）；</li></ul></li><li>执行过程中加锁：<ul><li>同一时刻只能有一个线程在执行 <code>&lt;clinit&gt;()</code> 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。</li></ul></li><li>非必要性：<ul><li>一个类如果没有任何 static 的内容就不需要执行 () 方法。</li></ul></li></ul></li></ul><h3 id="本小节的补充：-lt-clinit-gt-与-lt-init-gt-方法"><a href="#本小节的补充：-lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="本小节的补充：&lt;clinit&gt; 与 &lt;init&gt; 方法"></a>本小节的补充：<code>&lt;clinit&gt;</code> 与 <code>&lt;init&gt;</code> 方法</h3><p><strong>概述</strong></p><p>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法<code>&lt;clinit&gt;</code>, 另一个是实例的初始化方法<code>&lt;init&gt;</code></p><p><code>&lt;clinit&gt;</code>：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行</p><p><code>&lt;init&gt;</code>:在实例创建出来的时候调用，包括调用new操作符；调用Class或<code>java.lang.reflect.Constructor</code>对象的<code>newInstance()</code>方法；调用任何现有对象的clone()方法；通过<code>java.io.ObjectInputStream</code>类的<code>getObject()</code>方法反序列化。</p><h4 id="lt-clinit-gt-方法"><a href="#lt-clinit-gt-方法" class="headerlink" title="&lt;clinit&gt;方法"></a><code>&lt;clinit&gt;</code>方法</h4><blockquote><p>先理解 类初始化阶段 的含义: 该阶段负责为类变量赋予正确的初始值, 是一个类或接口被首次使用前的最后一项工作</p></blockquote><p><code>&lt;clinit&gt;</code>方法的执行时期: 类初始化阶段(该方法只能被jvm调用, 专门承担类变量的初始化工作)</p><p><code>&lt;clinit&gt;</code>方法的内容: 所有的类变量初始化语句和类型的静态初始化器</p><p>类的初始化时机: 即在java代码中首次主动使用的时候, 包含以下情形:</p><ul><li>(首次)创建某个类的新实例时–new, 反射, 克隆 或 反序列化;</li><li>(首次)调用某个类的静态方法时;</li><li>(首次)使用某个类或接口的静态字段或对该字段(final 字段除外)赋值时;</li><li>(首次)调用java的某些反射方法时;</li><li>(首次)初始化某个类的子类时;</li><li>(首次)在虚拟机启动时某个含有 main() 方法的那个启动类</li></ul><p>注意: 并非所有的类都会拥有一个方法, 满足下列条件之一的类不会拥有方法:</p><ol><li>该类既没有声明任何类变量，也没有静态初始化语句;</li><li>该类声明了类变量，但没有明确使用类变量初始化语句或静态初始化语句初始化;</li><li>该类仅包含静态 final 变量的类变量初始化语句，并且类变量初始化语句是编译时常量表达式;</li></ol><h4 id="lt-init-gt-方法"><a href="#lt-init-gt-方法" class="headerlink" title="&lt;init&gt;方法"></a><code>&lt;init&gt;</code>方法</h4><p><code>&lt;init&gt;</code>方法的执行时期: 对象的初始化阶段</p><p>实例化一个类的四种途径:</p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载过程中的“通过一个类的全限定名来获取描述这个类的二进制字节流”这个动作是放在Java虚拟机的外部来实现的，以便于让应用程序自己来决定如何去获取所需要的类，实现这个动作的代码模块被称为<strong>“类加载器”</strong>。</p><p>类加载器虽然只用于实现类的加载动作，但是它的作用却远远不限于此，比较两个类是否“相等”，不仅仅要确认这两个类是否来源于同一个class文件，还需要加载这两个类的类加载器相同。</p><h3 id="如何判断两个类-“相等”"><a href="#如何判断两个类-“相等”" class="headerlink" title="如何判断两个类 “相等”"></a>如何判断两个类 “相等”</h3><ul><li>“相等” 的要求<ul><li>同一个 .class 文件</li><li>被同一个虚拟机加载</li><li>被同一个类加载器加载</li></ul></li><li>判断 “相等” 的方法<ul><li>instanceof 关键字</li><li>Class 对象中的方法：<ul><li>equals()</li><li>isInstance()</li><li>isAssignableFrom()</li></ul></li></ul></li></ul><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>站在虚拟机的角度，只存在两种类加载器：</p><blockquote><p>启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机的一部分<br>其他类加载器，由Java语言实现，独立于虚拟机之外的，全部继承自抽象类 java.lang.ClassLoader</p></blockquote><p>从开发人员的角度，类加载器可以划分得更细致一些：</p><ul><li>启动类加载器（Bootstrap）:负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。<code>&lt;JAVA_HOME&gt;/lib``-Xbootclasspath</code> 参数指定的路径</li><li>扩展类加载器（Extension）:负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录下的，或者被 <code>java.ext.dir</code> 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<ul><li><code>&lt;JAVA_HOME&gt;/lib/ext</code></li><li><code>java.ext.dirs</code> 系统变量指定的路径</li></ul></li><li>应用程序类加载器（Application）:负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。<ul><li><code>-classpath</code> 参数</li></ul></li></ul><p>以上加载器互相配合来加载我们自己的应用程序，如果有必要，我们还可以加入自己定义的加载器。这些加载器之间的关系一般如下图示：</p><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/reprint/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>类加载器的双亲委派模型（Parent Delegation Model）：要求除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器。（注意！这里类加载器之间的父子关系一般不会以继承（Inheritance）来实现，而是使用组合（Composition）来复用父加载器的代码）。这种模型被广泛使用于几乎所有的Java程序中，但是它并不是一个强制性的约束，只是Java设计者推荐给开发者使用的一种类加载器实现方式。</p><ul><li>工作过程<ul><li>当前类加载器收到类加载的请求后，先不自己尝试加载类，而是先将请求委派给父类加载器。因此，所有的类加载请求，都会先被传送到启动类加载器。</li><li>只有当父类加载器加载失败时，当前类加载器才会尝试自己去自己负责的区域加载</li></ul></li><li>实现<ul><li>检查该类是否已经被加载</li><li>将类加载请求委派给父类<ul><li>如果父类加载器为 null，默认使用启动类加载器</li><li>parent.loadClass(name, false)</li></ul></li><li>当父类加载器加载失败时<ul><li>catch ClassNotFoundException 但不做任何处理</li><li>调用自己的 findClass() 去加载<ul><li>我们在实现自己的类加载器时只需要 extends ClassLoader，然后重写 findClass() 方法而不是 loadClass() 方法，这样就不用重写 loadClass() 中的双亲委派机制了</li></ul></li></ul></li></ul></li><li>优点<ul><li>自己写的类库同名类不会覆盖类库的类</li><li>java类随着它的类加载器一起具备了一种带有优先层级的层次关系，保证了Java程序的稳定运行。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;【转载】&quot;&gt;&lt;a href=&quot;#【转载】&quot; class=&quot;headerlink&quot; title=&quot;【转载】&quot;&gt;&lt;/a&gt;【转载】&lt;/h2&gt;&lt;p&gt;本文作者&lt;strong&gt;：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/kylinxx
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="Java" scheme="https://qybit.gitee.io/tags/Java/"/>
    
      <category term="转载" scheme="https://qybit.gitee.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="JVM" scheme="https://qybit.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>131. 分割回文串</title>
    <link href="https://qybit.gitee.io/2021/03/07/259/"/>
    <id>https://qybit.gitee.io/2021/03/07/259/</id>
    <published>2021-03-07T02:47:14.000Z</published>
    <updated>2021-09-23T13:18:43.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="方法一：回溯-剪枝优化"><a href="#方法一：回溯-剪枝优化" class="headerlink" title="方法一：回溯 + 剪枝优化"></a>方法一：回溯 + 剪枝优化</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于本题，我们要找出字符串 $s$ 中，所有可能的回文子串，因此我们需要搜索与回溯遍历所有可能的字串。</p><p>对于字符串中某个下标 $i$ ，我们可以假设其 $[0,i]$ 的部分，已经全部是回文子串并且加入答案数组 $res$ 中。那么，对于区间 $<a href="n%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6">i,n</a>$，我们可以枚举出所有可能的长度 $len (1 \le len \le n-i+1)$，并使用双指针检查是否为回文子串。</p><p>如果为回文子串，我们把该字串加入到答案数组，然后我们下一次搜索时就可以跳过这一个回文字串，从下标 $i + len$ 开始重复上述过程，直到 $i \ge n$ 为止。当以该字串为回文串的路径，搜索完毕后，我们再删除该字串，然后再重新以另一个可能存在的回文串重复上述过程。</p><p>直到，没有存在可能的回文串才会结束我们的算法。即我们从头扫到尾，都未发现回文串时。</p><h3 id="剪枝的体现："><a href="#剪枝的体现：" class="headerlink" title="剪枝的体现："></a>剪枝的体现：</h3><ul><li>当我们对于任意一个下标 $i$ 进行枚举时，我们会枚举出所有可能的切割长度所产生的字串，但是我们只会选择属于回文子串的路径进行搜索。而不是回文子串的路径，则会被抛弃。</li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>对于回溯的题目，我们脑海中需要有一颗递归树。请以 <strong>自行脑部/画出递归树</strong> 的方式来理解本题的解法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[n - <span class="number">1</span> - i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path, <span class="keyword">int</span> idx, <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - idx + <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">string</span> sub = s.substr(idx, i);</span><br><span class="line">            <span class="keyword">if</span> (check(sub)) &#123;</span><br><span class="line">                path.push_back(sub);</span><br><span class="line">                dfs(res, path, idx + i, s);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        dfs(res, path, <span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N \times 2^N)$，其中 $N$ 是字符串 $s$ 的长度。</p><ul><li><p>我们需要利用双指针检查是否为回文子串，时间复杂度为 $O(N)$。</p></li><li><p>在最坏的情况下，字符串 $s$ 是由 $N$ 个相同的字符所组成的。那么我们要面临的划分方案为 $2^{N-1} = O(2^N)$ 。而对于任意一个划分的字串，我们都必须要利用双指针检查是否为回文子串。所以时间复杂度为 $O(N \times 2^N)$。</p></li></ul><p>空间复杂度：$O(N \times 2^N)$，我们需要存储所有可能的回文子串。</p>]]></content>
    
    <summary type="html">
    
      回溯
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="回溯" scheme="https://qybit.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>第46场双周赛</title>
    <link href="https://qybit.gitee.io/2021/02/22/w46/"/>
    <id>https://qybit.gitee.io/2021/02/22/w46/</id>
    <published>2021-02-22T14:29:38.000Z</published>
    <updated>2021-09-23T13:18:44.009Z</updated>
    
    <content type="html"><![CDATA[<p>第46场双周赛题解</p><p>比赛地址：<a href="https://leetcode-cn.com/contest/biweekly-contest-46/">第 46 场双周赛</a></p><h1 id="题目清单："><a href="#题目清单：" class="headerlink" title="题目清单："></a>题目清单：</h1><ul><li> <a href="https://leetcode-cn.com/problems/longest-nice-substring/">最长的美好子字符串</a></li><li> <a href="https://leetcode-cn.com/problems/form-array-by-concatenating-subarrays-of-another-array/">通过连接另一个数组的子数组得到一个数组</a></li><li> <a href="https://leetcode-cn.com/problems/map-of-highest-peak/">地图中的最高点</a></li><li> <a href="https://leetcode-cn.com/problems/tree-of-coprimes/">互质树</a></li></ul><a id="more"></a><h1 id="T1：最长的美好子字符串"><a href="#T1：最长的美好子字符串" class="headerlink" title="T1：最长的美好子字符串"></a>T1：<a href="https://leetcode-cn.com/problems/longest-nice-substring/">最长的美好子字符串</a></h1><h2 id="方法一：枚举-哈希表"><a href="#方法一：枚举-哈希表" class="headerlink" title="方法一：枚举+哈希表"></a>方法一：枚举+哈希表</h2><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>题目描述比较长，简单概括一下就是：</p><p>在给定的字符中，找到一个连续的、最长的而且是最早出现的 <strong>美好子字符串</strong>。<strong>美好子字符串</strong> 的定义是对于任意一个字符（如 <code>a</code>出现在子串里，那么<code>A</code>就必须要存在），它的大小写形式都必须出现（不论次数）在这个子字符串里。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看看数据范围，给定字符串的长度为 $100$。因此，我们可以枚举出所有可能的子字符串，然后再检查这个子字符串是否为 <strong>美好子字符串</strong>。</p><p>枚举所有的子字符串时间复杂度为 $O(N^2)$，再检查子字符串 $O(N)$。所以我们的算法最终时间复杂度为 $O(N^3)$ ，计算量为 $10^6$ 次。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// true 返回大写, false 返回小写</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">return</span> c - <span class="number">32</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; has;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="comment">// 提前存入哈希表，并记录字串以待返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">            has.insert(s[k]);</span><br><span class="line">            ret.push_back(s[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k ++) &#123;</span><br><span class="line">            <span class="comment">// 分别转换为大写和小写形式</span></span><br><span class="line">            <span class="keyword">auto</span> c1 = convert(s[k], <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">auto</span> c2 = convert(s[k], <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 任意一个不存在，即可返回一个空串</span></span><br><span class="line">            <span class="keyword">if</span> (!has.count(c1) || !has.count(c2)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestNiceSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = check(s, i, j);</span><br><span class="line">                <span class="keyword">if</span> (t.size() &gt; ans.size()) </span><br><span class="line">                    ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^3)$，其中 $N$ 表示字符串的长度。</p><ul><li>我们要枚举出所有可能的字串，时间复杂度$O(N^2)$。</li><li>我们枚举出字串后，对于每一个字串，我们都需要遍历一次以验证是否为<strong>美好子字符串</strong>，遍历字符串的时间复杂度为 $O(N)$。</li><li>所以我们的算法最终时间复杂度为 $O(N^3)$。</li></ul><p>空间复杂度：$O(N^3)$，其中 $N$ 表示为子串的长度。</p><ul><li>我们对于任意一个字串都需要记录其出现的种类以及存储字串的空间，空间复杂度为 $O(N)$。</li><li>我们要枚举出来 $N^2$ 个字串，因此空间复杂度为 $O(N^3)$。</li></ul><h1 id="T2：通过连接另一个数组的子数组得到一个数组"><a href="#T2：通过连接另一个数组的子数组得到一个数组" class="headerlink" title="T2：通过连接另一个数组的子数组得到一个数组"></a>T2：<a href="https://leetcode-cn.com/problems/form-array-by-concatenating-subarrays-of-another-array/">通过连接另一个数组的子数组得到一个数组</a></h1><h2 id="方法一：贪心-双指针（存疑，系本人看错题）"><a href="#方法一：贪心-双指针（存疑，系本人看错题）" class="headerlink" title="方法一：贪心+双指针（存疑，系本人看错题）"></a>方法一：贪心+双指针（存疑，系本人看错题）</h2><h2 id="开头-1"><a href="#开头-1" class="headerlink" title="开头"></a>开头</h2><p>给定一个二维的数组，和一个整数数组。</p><p>我们的目标是，把二维数组 $groups$ 的每一个行 $groups[i](0 \le i\le n-1，n为二维数组的行数)$ 都映射到整数数组的子数组 $nums[j, k] (groups[i].length =k-j+1，区间[j,k]的长度是等于 groups[i]行的长度)$  上，且 $groups[i]$ 必须在 $groups[i+1](i \le n -1)$ 之前映射到 $nums$ 上。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>需要好好看看题，这题就是阅读理解。</p><p>那么，我们可以这样贪心，对于二维数组的任意一行 $i (0 \le i \le n-2)$ ，我们都必须要完全映射到一维数组 $nums$ 的子数组上，且子数组之间没有重叠冲突。</p><p>我们这么做的理由很容易得到证明。题目说了，当 $i (i \gt 0)$ 时，$groups[i-1]$ 行在 $nums$ 中的出现位置一定在第 $i$ 个 $groups[i]$ 行之前。</p><p>具体做法如下：</p><ul><li>我们使用循环遍历二维数组的所有行，对于每一行，我们遍历所有的列，并计算总和</li><li>使用一个 $cur$ 指针，表示当前在一维数组的位置。我们希望找到一段与当前行长度一样的区间，也就是总和相等的子数组<ul><li>如果找到，那么我们将 $cur$ 指针，移动 $groups[i].length$ 次。表示这段区间我们已经使用。</li><li>如果未找到，那么我们将 $cur$ 指针，只移动一次。</li><li>在此过程中，如果 $cur$ 指针，不够移动 $groups[i].length$ 次，则表示我们无法将当前行的元素，全部都映射到一位数组上，我们返回 $false$。</li></ul></li><li>如果我们遍历完所有的二维数组，则表示二维数组可以全部映射到一维数组上，我们返回 $true$。</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canChoose</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; groups, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = groups.size();</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = groups[i].size();</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j ++) sum += groups[i][j];</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur + len &gt; nums.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = cur; k &lt; cur + len; k ++) &#123;</span><br><span class="line">                    t += nums[k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t == sum) &#123;</span><br><span class="line">                    cur += len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur ++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != sum &amp;&amp; cur &lt; nums.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^2)$，其中 $N$ 为数组的长度。</p><ul><li>我们必须要遍历二维数组，时间复杂度为 $O(N^2)$。</li><li>在遍历二维数组的第二维时，我们还会遍历一维数组数组，这是同时进行的。时间复杂度为 $O(N)$。</li><li>因此，我们的时间复杂度为 $O(N^2)$。</li></ul><p>空间复杂度：$O(1)$，我们只使用了常数空间。</p><h1 id="T3：地图中的最高点"><a href="#T3：地图中的最高点" class="headerlink" title="T3：地图中的最高点"></a>T3：<a href="https://leetcode-cn.com/problems/map-of-highest-peak/">地图中的最高点</a></h1><h2 id="方法一：多源BFS"><a href="#方法一：多源BFS" class="headerlink" title="方法一：多源BFS"></a>方法一：多源BFS</h2><h2 id="开头-2"><a href="#开头-2" class="headerlink" title="开头"></a>开头</h2><p>一个出发点的是一般的 BFS。</p><p>多源BFS，说得通俗一点其实就是一开始搜索之前，队列里存放多个<strong>起点</strong>，依次出发遍历。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>我们解读题目为：</p><blockquote><p>​    从任意一个水域出发，我们可以到达陆地的最大距离。</p></blockquote><p>直接 BFS ，一层一层的扩散搜索。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; highestPeak(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isWater) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = isWater.size(), n = isWater[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> used[m][n];</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isWater[i][j]) </span><br><span class="line">                    q.push(&#123;i, j&#125;), used[i][j] = <span class="literal">true</span>, isWater[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 步长，即最大距离</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line">            <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front(); </span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> x = p.x, y = p.y;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!used[nx][ny] &amp;&amp; !isWater[nx][ny]) &#123;</span><br><span class="line">                        q.push(&#123;nx, ny&#125;);</span><br><span class="line">                        used[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                        isWater[nx][ny] = step;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(M \times N)$，其中 $M$ 为矩阵的行数，$N$ 为矩阵的列数。我们需要遍历所有的矩阵。</p><p>空间复杂度：$O(M \times N)$，在最坏的情况下，整个矩阵都是水域。此时所有的点全部都要进入队列。</p><h1 id="T1：互质树"><a href="#T1：互质树" class="headerlink" title="T1：互质树"></a>T1：<a href="https://leetcode-cn.com/problems/tree-of-coprimes/">互质树</a></h1><h1 id="开头-3"><a href="#开头-3" class="headerlink" title="开头"></a>开头</h1><p>题目描述的花里胡哨的，简化一下就是。</p><p>对于树上的任意一个节点，找到一个距离此节点最近的祖先节点满足两个节点的值是互质的。</p><h1 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h1><p>我们不可能试图去枚举所有的点，因为当树呈现线性的极端情况下，我们的暴力做法时间复杂度为 $O(N^2)$，而我们要枚举 $10^5$ 个点，$10^{10}$ 次计算，一定是超时的。</p><p>好在，节点的每个值都是比较小的 $1 \le nums[i] \le 50$，因此我们可以从值出发。</p><p>我们记录 $[1,50]$ 之间所有可能互质的两个数，然后对于任意一个节点的值 $x$，我们希望找到一个<strong>互质</strong>且 <strong>“最深”</strong> （深度最大的）的节点的值 $y$。</p><p> 具体做法：</p><ul><li>我们先构建出无向图，然后计算出 $[1,50]$ 之间所有互质的点，然后从第一个点 $0$ 开始向下搜索，定义 $pos$ 数组表示数组对应的节点，定义数组 $depth$ 表示节点的深度。</li><li>对于任意一个节点$u$ 和其对应的值 $x$，我们枚举在 $[1,50]$ 之间所有可能互质的数 $y$，再根据 $pos[y]$ 和 $ans[u]$ 的对应深度来更新 $ans[u]$ 的最近祖先。<ul><li>我们再暂时将值 $x$ 的设置为指向 $u$，再递归处理循环上述过程，为防止 $stackoverflow$ ，当我们遍历到父亲节点时退出。</li></ul></li></ul><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>注意：在力扣中，c++使用全局遍历必须要初始化！（调了半小时后，我才突然意识到这个问题）</p><p>力扣中的c++在判题的过程中，如果使用了全局变量，在使用前不初始化的话，不同用例之间的数据会互相干扰。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; graph[N];</span><br><span class="line"><span class="comment">// pos 数值所在的层数</span></span><br><span class="line"><span class="comment">// depth 指节点的深度</span></span><br><span class="line"><span class="keyword">int</span> depth[N], pos[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w, ans;</span><br><span class="line">    <span class="comment">// 记录互质的数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = w[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;y : g[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[y] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[u] == <span class="number">-1</span> ||  depth[pos[y]] &gt; depth[ans[u]]) &#123;</span><br><span class="line">                    ans[u] = pos[y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = pos[x];</span><br><span class="line">        pos[x] = u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">            depth[j] = depth[u] + <span class="number">1</span>;</span><br><span class="line">            dfs(j, u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getCoprimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        w = nums;</span><br><span class="line">        <span class="comment">// 必须初始化全局变量</span></span><br><span class="line">        <span class="built_in">memset</span>(depth, <span class="number">0</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">        <span class="built_in">memset</span>(pos, <span class="number">-1</span>, <span class="keyword">sizeof</span> pos);</span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span> graph);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        ans.resize(n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>];</span><br><span class="line">            graph[a].push_back(b);</span><br><span class="line">            graph[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd(i, j) == <span class="number">1</span>) &#123;</span><br><span class="line">                    g[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(50 \times N)$，其中 $N$ 为树中点的数量。</p><ul><li><p>计算 $[1, 50]$ 之间所有可能互质的数，时间复杂度 $O(50^2\times log(50))$。</p></li><li><p>对于任意一个节点，我们都要枚举出 $[1,50]$ 之间互质的数。时间复杂度 $O(50 \times N)$。</p></li><li><p>所以时间复杂度为 $O(50 \times N)$。</p></li></ul><p>空间复杂度：$O(N^2)$，其中 $N$ 为树中点的数量。</p><ul><li>我们需要存储无向图，使用了二维数组。</li><li>我们还需要存储每个节点的深度</li><li>我们需要存储原 $nums$ 数组，答案数组。</li></ul>]]></content>
    
    <summary type="html">
    
      第46场双周赛
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="BFS" scheme="https://qybit.gitee.io/tags/BFS/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="DFS" scheme="https://qybit.gitee.io/tags/DFS/"/>
    
      <category term="图" scheme="https://qybit.gitee.io/tags/%E5%9B%BE/"/>
    
      <category term="树" scheme="https://qybit.gitee.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>848. 字母移位</title>
    <link href="https://qybit.gitee.io/2021/02/20/848/"/>
    <id>https://qybit.gitee.io/2021/02/20/848/</id>
    <published>2021-02-20T12:33:33.000Z</published>
    <updated>2021-09-23T13:18:43.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>给定一个字符串和数组，且二者长度是相同的。</p><p>移位过程中，字母表是环绕的，即超过 <code>z</code> 的部分，将会从 <code>a</code> 重新开始计数。</p><p><code>shifts[i] = x</code> ，表示的是我们将 <code>S</code> 中的前 <code>i + 1</code> 个字母移位 <code>x</code> 次。</p><p><strong>移位</strong>操作我们定义为 $shift$ 函数处理。</p><h1 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h1><p>我们发现了数据范围，实际上是 $2 \times 10 ^ 4$，而我们的暴力做法时间复杂度将会达到 $N^2$ ，也就是 $4 \times 10^8$ 计算次数。那么对于一道中等题，显而易见是会 $TLE$ 超时的。</p><p>先看看暴力的做法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = shifts.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = shifts[i] % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">                s[j] = shift(s[j], k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">shift</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c + k - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：$O(N^2)$，其中 $N$ 表示数组和字符串的长度。</p><p>空间复杂度：$O(1)$</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>对于 $shifts[i] \ (0 \le i \le n-1)，其中 n 为数组长度$ 而言，我们的<strong>移位</strong>操作次数实际上是<br>$$<br>\sum_{k=i}^{n-1} shift(S[k], shifts[k])，其中 \ S \ 为字符串<br>$$<br>因此，我们可以采用<strong>后缀和</strong>来优化这一过程。</p><p>与前缀和最好相反，后缀和 我们定义为 $Sum[i]$，表示为区间 $[i, n -1]$ 的总和。</p><h1 id="方法二：后缀和"><a href="#方法二：后缀和" class="headerlink" title="方法二：后缀和"></a>方法二：后缀和</h1><p>我们定义 $Sum[i]$ 表示为<br>$$<br>\sum_{k=i}^{n-1}arr[k]<br>$$<br>这样就可以在 $O(1)$ 时间复杂度，获得第 $i$ 个字符一共<strong>移位</strong>多少次。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = shifts.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            shifts[i] %= <span class="number">26</span>;</span><br><span class="line">            shifts[i] += shifts[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) S[i] = shift(S[i], shifts[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">shift</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c + k - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：$O(N)$，其中 $N$ 为数组和字符串的长度。</p><ul><li>我们会遍历一次 $shifts$ 数组，计算出后缀和。时间复杂度 $O(N)$</li><li>我们遍历字符串，给每一个字符进行<strong>移位</strong>操作，<strong>移位</strong>操作时间复杂度为 $O(1)$。所以遍历字符串的时间复杂度为 $O(N)$。</li><li>我们对于数组或者字符串中的任意一个元素，至多只会遍历一次。</li></ul><p>空间复杂度：$O(1)$，我们直接使用的 $shifts$ 数组的空间。</p>]]></content>
    
    <summary type="html">
    
      力扣848-字母移位
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>1.两数之和</title>
    <link href="https://qybit.gitee.io/2021/02/18/1/"/>
    <id>https://qybit.gitee.io/2021/02/18/1/</id>
    <published>2021-02-18T07:42:46.000Z</published>
    <updated>2021-09-23T13:18:43.993Z</updated>
    
    <content type="html"><![CDATA[<p>当年我的劝退题目~，第一次做力扣被这道题卡到劝退。半天憋不出来一个可以 <code>AC</code> 的代码。</p><p>今天有必要给它写个题解，来纪念一下。</p><p>本文，将会分别从不同的时间复杂度来解决问题，如下 $O(N^2)$、$O(NlogN)$、$O(N)$ 的解决思路。</p><a id="more"></a><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>我们需要在一个数组中，找到两个不同的下标使得下标对应的元素和等于 $targert$。</p><p>假设存在两个下标 $i$ 和 $j$ （$i \ne j$），使得 $nums[i] + nums[j] = target (i \ne j)$，其中 $nums$ 表示为数组。</p><h1 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h1><p>思路如下：</p><ul><li>第一层循环，我们固定一个下标 $i$。</li><li>第二层循环，我们在下标 $i$ 固定的前提下，再寻找一个下标 $j$，使得 $nums[i] + nums[j] = target (i \ne j)$。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) </span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N^2)$，其中 $N$ 为数组的长度。对于数组中的每个元素，我们在最坏的情况下需要访问 $N$ 次。</p><p>空间复杂度：$O(1)$</p><h1 id="方法二：排序-双指针"><a href="#方法二：排序-双指针" class="headerlink" title="方法二：排序 + 双指针"></a>方法二：排序 + 双指针</h1><p>我们先将数组排序后，再使用双指针分别从数组 <strong>头部</strong> 和 <strong>尾部</strong> 夹逼寻找符合条件的两个元素。</p><p>由于排序后会打乱其原本的信息，因此我们必须要重新存储一下数组的元素，并维护其原本的位置。这一步我们可以使用结构体或者类来实现。</p><p>那么为什么可以使用双指针呢？证明如下：</p><ul><li>对于数组中的两个指针 $left(left \ge 0)$ 和 $right(right \le n - 1)$，其中 $n$ 为数组长度。存在如下情况：<ul><li>​    $q[left] + q[right] \gt target$，那么此时指针 $right$ 必不可能是向右移动的，因为对于 $q[right] \le q[right + 1] (right \le n -2)$ 一定成立。为了使得 $left$ 和 $right$ 所指元素 <strong>等于</strong> $target$  ，$right$ 只能单调向左移动。</li><li>$q[left] + q[right] \lt target$，对于 $left$ 指针而言也是同理。对于 $q[left - 1] \le q[left](left &gt; 0)$ 一定成立。为了使得 $left$ 和 $right$ 所指元素 <strong>等于</strong> $target$。$left$ 只能单调向右移动。</li><li>$q[left] + q[right] = target$ ，那么皆大欢喜，我们找到两个符合条件的下标。返回 $left$ 和 $right$ 所指元素的原本下标位置即可。</li></ul></li><li>只有满足了指针移动的单调性，我们才可以使用双指针来解决此类问题。</li></ul><p>类似题目推荐：</p><ul><li> <a href="https://leetcode-cn.com/problems/container-with-most-water/">力扣 11.盛最多水的容器</a></li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ele</span> &#123;</span></span><br><span class="line">    <span class="comment">// a 表示数组元素， k 表示该元素在原数组的位置</span></span><br><span class="line">    <span class="keyword">int</span> a, k;</span><br><span class="line">    <span class="comment">// 重载操作符，方便排序 </span></span><br><span class="line">    <span class="comment">// 按照数组元素大小升序排列</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Ele &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; t.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            q[i] = &#123;nums[i], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q, q + n);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = q[left].a + q[right].a;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;q[left].k, q[right].k&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(NlogN)$，其中 $N$ 为数组的长度。</p><ul><li>我们第一次遍历数组，备份各元素原本下标的位置。时间复杂度$O(N)$。</li><li>我们对<strong>新数组</strong>元素进行排序操作，此处的时间复杂度为 $O(NlogN)$。</li><li>我们还要双指针遍历<strong>新数组</strong>，来寻找符合条件的两个下标，并返回<strong>原本</strong>的下标位置。时间复杂度$O(N)$。</li><li>我们对于所有数组中的任意一个元素，在最坏的情况下都不会访问到达 $N$ 次。因此时间复杂度为 $O(NlogN)$。</li></ul><p>空间复杂度：$O(N)$，我们需要备份原来的数组的信息。</p><h1 id="方法三：哈希表-这个方法应该是最优解"><a href="#方法三：哈希表-这个方法应该是最优解" class="headerlink" title="方法三：哈希表 (这个方法应该是最优解)"></a>方法三：哈希表 (这个方法应该是最优解)</h1><p>假设存在两个下标 $i$ 和 $j$ $(i \ne j)$，满足 $a = nums[i], b = nums[j]$，那么此时 $a + b = target$。</p><p>对于数组中的元素，我们固定一个下标并假设其为 $i$ ，如下图</p><p><img src="https://img.imgdb.cn/item/602e232d99aa8726f2955d70.jpg"></p><p>那么我们的最终目标其实是，询问 $b (nums[j])$ 是否存在于区间 $[0, i - 1]$ 中，并且这个操作必须是 $O(1)$ 时间复杂度的。</p><p>因此我们不难想到用 <strong>哈希表</strong> 来优化。考虑到本题中，存在负数，因此不可以使用数组来充当哈希表，我们只能使用 <code>Map</code> 结构来实现。</p><p>类似题目推荐：</p><ul><li> <a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/">961. 重复 N 次的元素</a></li><li> <a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></li><li> <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (f.find(x) != f.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, f[x]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            f[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N)$，其中 $N$ 为数组长度。我们至多只会遍历一遍数组。</p><p>空间复杂度：$O(N)$，其中 $N$ 为数组长度。我们需要使用 <strong>哈希表</strong> 维护数组元素和下标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当年我的劝退题目~，第一次做力扣被这道题卡到劝退。半天憋不出来一个可以 &lt;code&gt;AC&lt;/code&gt; 的代码。&lt;/p&gt;
&lt;p&gt;今天有必要给它写个题解，来纪念一下。&lt;/p&gt;
&lt;p&gt;本文，将会分别从不同的时间复杂度来解决问题，如下 $O(N^2)$、$O(NlogN)$、$O(N)$ 的解决思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="双指针" scheme="https://qybit.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="哈希表" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第228场周赛</title>
    <link href="https://qybit.gitee.io/2021/02/14/w228/"/>
    <id>https://qybit.gitee.io/2021/02/14/w228/</id>
    <published>2021-02-14T07:18:07.000Z</published>
    <updated>2021-09-23T13:18:44.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>比赛链接：<a href="https://leetcode-cn.com/contest/weekly-contest-228/">第 228 场周赛</a></p><p>题目单：</p><ul><li><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/">生成交替二进制字符串的最少操作数</a></li><li><a href="https://leetcode-cn.com/problems/count-number-of-homogenous-substrings/">统计同构子字符串的数目</a></li><li><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/"> 袋子里最少数目的球</a></li><li><a href="https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/"> 一个图中连通三元组的最小度数</a></li></ul><h1 id="T1：生成交替二进制字符串的最少操作数"><a href="#T1：生成交替二进制字符串的最少操作数" class="headerlink" title="T1：生成交替二进制字符串的最少操作数"></a>T1：<a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/">生成交替二进制字符串的最少操作数</a></h1><p>由交替字符串的定义，我们可以知道像 $010101…$ 和 $101010…$ 这种字符串是<strong>交替二进制字符串</strong>。</p><p>那么， 我们的标准只有两个，要么是变成 $0101$ 交替组成的字符串，要么是变成 $1010$ 交替组成的字符串。</p><p>因此，我们同时变换成两种标准的交替二进制字符串，然后取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>其中 $n1$ 代表的是 $1010…$ ，$n2$ 代表的是 $0101…$</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="comment">// 010101  101010</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                n2 += s[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                n1 += s[i] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n2 += s[i] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                n1 += s[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N)$，其中$N$ 为字符串的长度。我们只会遍历一次字符串。</p><p>空间复杂度：$O(1)$</p><h1 id="T2：统计同构子字符串的数目"><a href="#T2：统计同构子字符串的数目" class="headerlink" title="T2：统计同构子字符串的数目"></a>T2：<a href="https://leetcode-cn.com/problems/count-number-of-homogenous-substrings/">统计同构子字符串的数目</a></h1><blockquote><p>​    同构字符串：如果一个字符串种的所有字符都相同，那么该字符串就是同构字符串</p></blockquote><p>观察用例 <code>s = abbcccaa</code></p><p><code>c</code> 出现 $3$ 次，<code>cc</code> 出现 $2$ 次，<code>ccc</code> 出现 $1$ 次。</p><p>假设 <code>ccc....c</code> 存在 $n$ 个连续的字串，那么：</p><ol><li>$n$ 个 <code>c</code></li><li>$n-1$ 个 <code>cc</code></li><li>$n - 2$ 个 <code>ccc</code></li><li>…..</li><li>$1$ 个 <code>ccc....c</code></li></ol><p>所以，这段连续 $n$ 个 <code>ccc....c</code> 一共贡献了<br>$$<br>1 + 2 + 3 + 4 + … +n = \frac{n \times (n + 1)}{2}<br>$$<br>$\frac{n \times (n + 1)}{2}$ 个同构字符串。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>注意了，假设用例中存在全是同一个字符的情况下，那么 $10 ^ 5 \times (10 ^ 5 + 1)$，此时会爆 <code>int</code>。所以需要用 <code>long long</code>，64位的整数变量。</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHomogenous</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; s[i] == s[j]) j++;</span><br><span class="line">            LL count = j - i;</span><br><span class="line">            ans += count * (count + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            ans %= mod;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。我们至多只有遍历一次字符串。</p><p>空间复杂度：$O(1)$</p><h1 id="T3：袋子里最少数目的球"><a href="#T3：袋子里最少数目的球" class="headerlink" title="T3：袋子里最少数目的球"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/">袋子里最少数目的球</a></h1><p>我们可以转换一下问题。</p><blockquote><p>​    在不超过 $maxOperations$ 的操作次数下，使得每个袋子里球的<strong>最大数目</strong>不超过 $y$  个。</p></blockquote><p>当 $y$ 增加时，我们的操作次数就会减少，那么 $y$ 的大小就具有单调性。因此可以二分进行查找。</p><p>假设对于单个袋子里的 $x$ 个球：</p><ul><li>如果 $x \ mod  \ y = 0$，此时可以整除 $y$ 时，可以进行 $\frac{x}{y}$ 操作。</li><li>如果 $x \ mod \ y \ne 0$，此时不能整除 $y$ 时，我们直接下取整 $\lfloor \frac{x}{y} \rfloor$</li></ul><p>那么，分类讨论后，我们可以发现 $\lfloor \frac{x - 1}{y} \rfloor$ 和上述讨论的结果实际上是等价的。</p><p>因此，对于数组中的 $N$ 个袋子，我们都有上述的操作方案。那么：<br>$$<br>\sum_{x \ \in \ nums} \lfloor \frac{x - 1}{y} \rfloor \le maxOperations<br>$$</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> y, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : nums) &#123;</span><br><span class="line">            count += (x - <span class="number">1</span>) / y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= maxOperations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, y, maxOperations)) right = y;</span><br><span class="line">            <span class="keyword">else</span> left = y + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N logC)$，其中 $N$ 为数组的长度，$C$ 为 $max(nums)$ 数组中的最大值，$C$ 不超过 $10^9$。</p><ul><li><p>我们会进行 $logC$ 次二分查找。</p></li><li><p>每一次二分查找，我们需要遍历数组验证操作数是否超过 $maxOperations$的次数。时间复杂度$O(N)$。</p></li></ul><p>空间复杂度：$O(1)$</p><h1 id="T4：一个图中连通三元组的最小度数"><a href="#T4：一个图中连通三元组的最小度数" class="headerlink" title="T4：一个图中连通三元组的最小度数"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/">一个图中连通三元组的最小度数</a></h1><blockquote><p>​    三元组：是指三个点组成的集合，且三个点之间是两两存在边的</p><p>​    联通三元组的度数：是指将这个三元组的集合视作一个“点” 。然后这个“点“ 和其他点的度数之和（无向图只要某个点存在一条边，那么这个点的度数就可以 +2），集合内部点的度数则不参与计算。</p></blockquote><p>先了解上述概念后，在看看数据范围，实际上才 $400$ 个点<del>（看不起谁呢？[doge]）</del>。 我们的算法很暴力，差不多是$400^3$，这个计算出来是 6400万，因此在力扣是完全够用的。</p><p>我们直接暴力枚举三个点，检查一下是否构成三元组，然后再计算出最小的度数。</p><p>值得注意的是，三元组可能是不存在的，因此我们需要特判一下。</p><p>我们的算法时间复杂度很高，这么做纯粹是这题数据很弱，正确的做法尚待学习！</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>三元组的度数，不包含内部之间的入度和出度。因此需要减去 $6$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edge[<span class="number">0</span>], b = edge[<span class="number">1</span>];</span><br><span class="line">            graph[a][b] = graph[b][a] = <span class="number">1</span>;</span><br><span class="line">            degree[a] ++ , degree[b] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= n; k ++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (graph[j][k] &amp;&amp; graph[i][k]) &#123;</span><br><span class="line">                            ans = min(ans, degree[i] + degree[j] + degree[k] - <span class="number">6</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N^3)$ ，其中 $N$ 是图中点的数量。我们会枚举所有可能的三元组。</p><p>空间复杂度：$O(N^2)$，我们需要存储所有的边，以及每个点的入度和出度之和。</p>]]></content>
    
    <summary type="html">
    
      周赛
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="二分" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="图" scheme="https://qybit.gitee.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="https://qybit.gitee.io/2021/02/10/567/"/>
    <id>https://qybit.gitee.io/2021/02/10/567/</id>
    <published>2021-02-10T02:58:01.000Z</published>
    <updated>2021-09-25T09:55:04.524Z</updated>
    
    <content type="html"><![CDATA[<p>力扣链接：<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></p><p>相似题目推荐：</p><ul><li> <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></li></ul><a id="more"></a><h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>题目的意思很清楚，我们需要在字符串 <code>s2</code> 中找到一段连续的子数组包含字符串 <code>s1</code> 中所有的字符，不论顺序。</p><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>双指针的具体做法：</p><ul><li>我们要求的是排列，因此我们只需要考虑<strong>种类</strong>和<strong>数量</strong>；</li><li>使用两个指针$left$ 和 $right$，表示我们在$s2$上遍历的区间$[left,right]$，使用一个变量$count$ 表示当遍历区间时，区间内字符出现在$s1$的种类数：<ul><li>如果一个字符的出现次数恰好等于字符串$s1$的出现次数，那么 $count+=1$</li><li>当左端点移动时，某个字符出现次数减少了，恰好小于$s1$的出现次数，那么 $count-=1$</li><li>当区间$[left, right]$内出现的字符种类数和$s1$的字符种类数相同时，我们固定$right$。然后移动$left$，使得$right-left == |s1|$，其中$|s1|$为字符串$s1$的长度。这样我们就找到了$s1$在$s2$的一个排列。</li></ul></li></ul><p>暴力是否可行？</p><p>这道题的数据范围比较小，才 $10^4$，因此暴力的时间复杂度是$O(N^2)$，计算量是 $10^8$，在力扣应该够用的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s1.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="keyword">int</span> preCount = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">need</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s1) need[x - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (need[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                preCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s2[right++];</span><br><span class="line">            <span class="keyword">if</span> (need[c1 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                hash[c1 - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                <span class="keyword">if</span> (hash[c1 - <span class="string">&#x27;a&#x27;</span>] == need[c1 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == preCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left == len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> c2 = s2[left++];</span><br><span class="line">                <span class="keyword">if</span> (need[c2 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    hash[c2 - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    <span class="keyword">if</span> (hash[c2 - <span class="string">&#x27;a&#x27;</span>] &lt; need[c2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(|s1| + |s2| + |\sum|)$，其中 $|s1|$表示字符串$s1$的长度，$|s2|$表示字符串$s2$的长度，其中$\sum$表示我们存储的小写字母的数量，其中$\sum$表示我们存储的字母出现次数，其大小取决于出现的字母 $ASCII$ 的最大值和最小值。</p><ul><li>我们会遍历字符串$s1$，时间复杂度$O(|s1|)$</li><li>我们还会遍历字符串$s1$的哈希数组，时间复杂度$O(|\sum|)$</li><li>双指针需要遍历字符串$s2$，时间复杂度$O(|s2|)$</li></ul><p>空间复杂度：$O(|\sum|)$</p><h2 id="暴力代码"><a href="#暴力代码" class="headerlink" title="暴力代码"></a>暴力代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.size() &gt; s2.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s1.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s1) hash[x - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.size() - len; i ++) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + len; j++) &#123;</span><br><span class="line">                f[s2[j] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j] != hash[j]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(|s1| + |s2| \times |s1|)$</p><ul><li>我们需要在字符串$s2$ 上，暴力枚举 $|s2| - |s1|$ 次，来找子区间是否为字符串$s1$的一个排列。</li></ul><p>空间复杂度：$O(\sum)$，其中$\sum$为字符集大小。</p>]]></content>
    
    <summary type="html">
    
      力扣567题题解
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="双指针" scheme="https://qybit.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
