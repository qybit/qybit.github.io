<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qybit&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ab3e80cccd375287a4f40b2a02dc6cd6</icon>
  <subtitle>Talk is cheap, show me your code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qybit.gitee.io/"/>
  <updated>2021-10-08T01:40:07.354Z</updated>
  <id>https://qybit.gitee.io/</id>
  
  <author>
    <name>qybit</name>
    <email>2601970213@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EQ-187-重复的DNA序列</title>
    <link href="https://qybit.gitee.io/2021/10/08/187/"/>
    <id>https://qybit.gitee.io/2021/10/08/187/</id>
    <published>2021-10-08T01:30:00.000Z</published>
    <updated>2021-10-08T01:40:07.354Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></p><h1 id="方法一：哈希"><a href="#方法一：哈希" class="headerlink" title="方法一：哈希"></a>方法一：哈希</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以通过枚举字符串 $s$ 中所有长度为 $10$ 的子串并且统计其出现的次数来实现</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">10</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">string</span> sub = s.substr(i, <span class="number">10</span>);</span><br><span class="line">            hash[sub] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; <span class="number">1</span>) res.push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NL)$，其中 $N$ 为字符串 $s$ 的长度，$L=10$ 是子串的长度。</p><p>空间复杂度：$O(NL)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/repeated-dna-sequences/&quot;&gt;187. 重复的DNA序列&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：哈希&quot;&gt;&lt;a href=&quot;#方法一：哈希&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="哈希" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>EQ-434-字符串中的单词数</title>
    <link href="https://qybit.gitee.io/2021/10/07/434/"/>
    <id>https://qybit.gitee.io/2021/10/07/434/</id>
    <published>2021-10-07T06:35:31.000Z</published>
    <updated>2021-10-07T06:46:23.149Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">434. 字符串中的单词数</a></p><h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>题目中的单词是指连续不为空格的字符，所以我们可以根据 <code>单词+空格</code>模式来匹配单词。我们可以在字符串的尾部添加一个空格，来匹配最后一个单词。</p><p>我们还可以通过库函数 split 来实现，具体可见 <strong>代码二</strong></p><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) res ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度</p><p>空间复杂度：$O(1)$。</p><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(s.split(<span class="string">&quot; &quot;</span>)).filter(item -&gt; !item.equals(<span class="string">&quot;&quot;</span>)).toArray().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度</p><p>空间复杂度：$O(N)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-segments-in-a-string/&quot;&gt;434. 字符串中的单词数&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：模拟&quot;&gt;&lt;a href=&quot;#方法一：模拟&quot; c
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>EQ-166-分数到小数</title>
    <link href="https://qybit.gitee.io/2021/10/03/259/"/>
    <id>https://qybit.gitee.io/2021/10/03/259/</id>
    <published>2021-10-03T02:38:53.000Z</published>
    <updated>2021-10-03T03:41:21.515Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">166. 分数到小数</a></p><h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>题目要求根据给定分数的分子和分母，求得字符串形式的小数或整数。由于给定的整数范围是 $[-2^{31}, 2^{31}-1]$，因此我们需要将整数转换为 $64$ 位的整数。</p><p>从分数转换到小数的做法是，分子除以分母。我们可以得到这样的结果：整数，有限小数和无限循环小数。</p><p>考虑到负数的情况，我们优先处理返回字符串的正负号问题，当且仅当仅有一个整数小于0时，我们提前放入负号。</p><p>如果我们计算除法得到整数，直接返回整数字符串即可。</p><p>如果我们计算除法得到有限小数或无限循环小数，因为除数是固定，小数部分对于被除数我们就可以做补0除法运算，并且记录所有被除数出现过的下标。如果出现了相同的下标，那就表示出现了循环。否则就表示有限小数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">long</span> a = numerator, b = denominator;</span><br><span class="line">        <span class="keyword">if</span> ((a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>) || (a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>)) sb.append(<span class="string">&quot;-&quot;</span>); <span class="comment">// 放入负号</span></span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        sb.append(a / b);</span><br><span class="line">        <span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="keyword">return</span> sb.toString(); <span class="comment">// 可以整除</span></span><br><span class="line">        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算小数部分</span></span><br><span class="line">        Map&lt;Long, Number&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> ((a = (a % b) * <span class="number">10</span>) &gt; <span class="number">0</span> &amp;&amp; !map.containsKey(a)) &#123; <span class="comment">// 补0运算并判断被除数下标</span></span><br><span class="line">            <span class="comment">// 记录下标</span></span><br><span class="line">            map.put(a, sb.length());</span><br><span class="line">            sb.append(a / b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> sb.toString(); <span class="comment">// 整除，有限小数</span></span><br><span class="line">        <span class="keyword">return</span> sb.insert(map.get(a).intValue(), <span class="string">&quot;(&quot;</span>).append(<span class="string">&quot;)&quot;</span>).toString(); <span class="comment">// 循环小数，在循环节的下标处，插入 () 返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 表示结果字符串的长度，答案字符串长度小于 $10^4$。</p><p>空间复杂度：$O(N)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/fraction-to-recurring-decimal/&quot;&gt;166. 分数到小数&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：模拟&quot;&gt;&lt;a href=&quot;#方法一：模拟&quot; class
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>EQ-34-在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://qybit.gitee.io/2021/10/01/34/"/>
    <id>https://qybit.gitee.io/2021/10/01/34/</id>
    <published>2021-10-01T06:58:54.000Z</published>
    <updated>2021-10-01T07:55:27.789Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>找了一道极其具有代表性的题目来复习一下二分查找算法，在有序数组里找重复元素的第一个和最后一个位置。</p><p>先看看我们一般情况下简单的二分算法是怎么样的。这里的需求是，在有序数组中查找元素 $x$。</p><p>一般情况下，我们会定义区间 $[l, r]$ ，每一次划分时我们取 $[l, mid-1]$，或者 $[mid + 1, 1]$ 。当 $mid$ 命中时，我们即刻返回 $mid$ 。当 $l == r$ 说明，有序数组里没有我们要找的元素，我们返回 $-1$；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">nums_, x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums_.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums_[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums_[mid] &gt; x) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">5</span>; </span><br><span class="line"><span class="built_in">console</span>.log(search(nums, target)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="YXC-算法模板"><a href="#YXC-算法模板" class="headerlink" title="YXC 算法模板"></a>YXC 算法模板</h2><p><a href="https://www.acwing.com/user/myspace/index/1/">@闫学灿</a> 的算法模板非常的简单整洁，他为我们总结了两套通用的<a href="https://www.acwing.com/blog/content/31/">二分查找算法模板</a></p><p>根据 YXC 的算法思路：假设目标值存在闭区间 $[l, r]$，每一次将区间缩小一半，当 <code>l=r</code>时，我们就找到了目标值。</p><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><p>当我们将区间 $[l,r]$ 划分成 $[l, mid]$ 和 $[mid + 1, r]$，其更新操作是 <code>r=mid</code> 或者 <code>l=mid+1</code>，计算 <code>mid</code> 时不需要加1。</p><p>算法模板表示为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把上面自己的算法，改造成适用于 YXC 版算法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">nums_, x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums_.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums_[mid] &gt;= x) &#123; <span class="comment">// 注意这里的区间选择，[l, mid] 新的区间里必须包含 x，否则算法将会出现错误</span></span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums_[l] != x) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">9</span>; </span><br><span class="line"><span class="built_in">console</span>.log(search(nums, target)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>注意：二分算法的思路非常简单，即当数组整体呈现单调性即可。但是在具体的问题中，如何正确的分配区间是一个致命的问题，你在实际代码很容易就会写成死循环，或者算法期望错误。</p><p>我们不参考 版本2，因为版本2需要 $\lceil mid \rceil$ ，我们可能会搞混淆所以不考虑版本2。</p><h1 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们设置 $p1, p2$ 分别为对应元素的左端点和右端点，$L$  和  $R$ 设置为数组的起点和末位。这道题的思路就是：先查找第一个等于 $target$ 的位置，然后再查找第一个大于 $target$ 元素的位置减一。</p><ol><li><p>先找到左边界值的位置，每一次划分时，我们都取 $[l, mid]$ 区间。这与我们上面的二分算法是一致的</p><p> <img src="https://pic.imgdb.cn/item/6156ba5c2ab3f51d91386e19.jpg"></p></li><li><p>我们设置第二次 二分查找 的闭区间为 $[p1, R]$，我们可以查找第一个大于 $target$ 的位置 $p3$，这样最右边的元素位置 $p2 = p3-1$ </p><p> <img src="https://pic.imgdb.cn/item/6156bdea2ab3f51d913e99b6.jpg"></p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        p1 = l;</span><br><span class="line">        r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;p1, p2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(log \ n)$，其中 $n$ 表示为数组的长度。我们一共进行两次二分查找，其中一次二分查找的时间复杂度为 $O(log \ n)$，即 $O(2 \times log \ n) = O(log \ n)$。</p><p>空间复杂度：$O(1)$，我们只使用了常量空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="二分查找" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>EQ-3-无重复字符的最长字串</title>
    <link href="https://qybit.gitee.io/2021/09/29/3/"/>
    <id>https://qybit.gitee.io/2021/09/29/3/</id>
    <published>2021-09-29T12:21:28.000Z</published>
    <updated>2021-09-29T12:37:04.469Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们定义两个指针 $l$ 和 $r$ ，分别表示最长不重复子串的左端点和右端点。</p><p>对于每一个子串，我们都尽可能的扩大子串的范围，每一次都将指针 $r$ 向右移动一位。并且记录字符串 $s[l…r]$ 中所有存在的字符，而当我们固定左右指针时，此时想移动右指针就存在两种情况：</p><ol><li>我们定义右指针指定的元素为 $c = s[r]$，对于此时的双指针</li><li>字符 $c$ 不在字符串 $s[l…r]$ 中，我们的左指针不动，右指针向右移动一位；</li><li>字符 $c$ 存在于字符串 $s[l…r]$ 中，此时我们固定右指针 $r$ 不动，移动左指针 $l$ 向右直到字符 $c \notin s[l…r]$ 时 ，我们就消除了重复字符，此时移动右指针向右移动一位。   </li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[r ++];</span><br><span class="line">            <span class="keyword">while</span> (st.find(c) != st.end()) &#123;</span><br><span class="line">                st.erase(s[l ++]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.insert(c);</span><br><span class="line">            res = max(res, (<span class="keyword">int</span>)st.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n)$，其中 $n$ 表示字符串的长度，我们的左右指针最多只会遍历一次字符串，相当于 $O(2 \times n)= O(n)$，常熟可忽略。</p><p>空间复杂度：$O(|\sum|)$，其中 $\sum$ 为最长子串的数量，我们需要记录最长子串的所有字符。其中字符表示 ASCII 值，所以 $\sum_{max} = 128$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;3. 无重复字符的最长子串&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：双指针&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="https://qybit.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>async/await原理学习笔记</title>
    <link href="https://qybit.gitee.io/2021/09/29/async-await-source/"/>
    <id>https://qybit.gitee.io/2021/09/29/async-await-source/</id>
    <published>2021-09-29T02:10:24.000Z</published>
    <updated>2021-09-29T11:33:07.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="1、JS-是单线程"><a href="#1、JS-是单线程" class="headerlink" title="1、JS 是单线程"></a>1、JS 是单线程</h3><p>首先，JavaScript 的一大特色就是单线程语言，这种设计使得 JavaScript 在同一时刻只做一件事；作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，避免了复杂性，比如假设 JavaScript 有两个线程，那么在同一时刻进行添加和删除节点操作，为浏览器分辨以哪个线程为主带来了困难，所以单线程是它作为脚本语言的优势，也是核心所在。</p><h3 id="2、同步任务和异步任务"><a href="#2、同步任务和异步任务" class="headerlink" title="2、同步任务和异步任务"></a>2、同步任务和异步任务</h3><p>单线程也就意味所有的任务都需要排队，前一个任务结束后下一个任务才会执行，为了提高 CPU 的利用率，就把任务分为了同步任务和异步任务。同步任务会在主线程栈顺序执行，而异步任务则会先进入任务队列中。在主线程上会形成一个执行栈，等执行栈中所有任务执行完毕后，会到异步任务队列中查看有哪些事件，此时异步任务结束等待状态，进入执行栈中，开始执行。</p><h2 id="JS-异步编程方法"><a href="#JS-异步编程方法" class="headerlink" title="JS 异步编程方法"></a>JS 异步编程方法</h2><p>需求描述：假设我有一个 <code>db1.json</code> 存放用户的个人信息，有一个 <code>db2.json</code> 存放用户的订单信息。现在我要查找该用户的全部订单信息，我应该怎么做？</p><blockquote><p>首先我需要先根据前台的信息查找到用户的个人信息后，再去查找用户的订单信息。</p></blockquote><p>那么在业务代码上是如何体现的呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">&#x27;/db/db1.json&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err; <span class="comment">// error </span></span><br><span class="line"> <span class="comment">// success</span></span><br><span class="line">    readFile(<span class="string">&#x27;/db/db2.json&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// do something </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以很明显的看到，我们的业务代码在不停的嵌套着这种回调函数风格，假如我在获取到 <code>bd1.json</code> 之后还有其他的事情，比如查看用户是不是满足打折优惠、满减和附赠优惠卷等活动时，那这个嵌套的深度将会 $\infty$ 大。</p><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><ol><li><p>嵌套深度过大，代码难以阅读和维护，造成 “回调地狱”。</p></li><li><p>异步任务具有 “滞后性”，即它略过异步任务代码，直接执行同步代码。造成 undefined 错误。</p><p> 相信有很多用过 jQuery 的小伙伴，那么对于下面这种错误代码，应该都非常的熟悉</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://xxx.com/api/xxx&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: <span class="number">12</span>,  </span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        res = data; <span class="comment">// 上下文找不到该变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><p> 原因此时很简单，因为 ajax 本身是一个异步任务，因此在执行时 ajax 函数的上下文已经发生了改变。因此找不到 res 变量，又由于 JS 会提升变量因此 res = undefined。</p><p> 解决办法：async: false，将 ajax 改为 同步任务</p></li><li><p>执行上下文发生改变。</p></li></ol><h2 id="Promise-链式调用解决-回调地狱"><a href="#Promise-链式调用解决-回调地狱" class="headerlink" title="Promise 链式调用解决 回调地狱"></a>Promise 链式调用解决 回调地狱</h2><p>我们改造异步编程中的代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       readFile(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// do something </span></span><br><span class="line">            resolve(data);</span><br><span class="line">    &#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 链式调用</span></span><br><span class="line">readFilePromise(<span class="string">&#x27;/db1.json&#x27;</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">&#x27;/db2.json&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(); <span class="comment">// .....</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这样的代码可能看起来逻辑上是足够清晰了，但是我又不想嵌套这么多层的 <code>then</code>，而且每一层 <code>then</code> 里我还要返回一个 Promise ，才能保证调用链的正常执行。</p><h2 id="解决-回调地狱-的终极方法"><a href="#解决-回调地狱-的终极方法" class="headerlink" title="解决 回调地狱 的终极方法"></a>解决 回调地狱 的终极方法</h2><h3 id="async-await-关键字"><a href="#async-await-关键字" class="headerlink" title="async/await 关键字"></a>async/await 关键字</h3><p>可以通过 <code>async/await</code> 一对关键字，注意是一对，使用 <code>await</code> 时必须要先声明 <code>async</code> 。我们可以通过 <code>await</code> 阻塞同步任务，使得异步任务完成后再继续进行同步任务。</p><p>具体可看代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       readFile(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// do something </span></span><br><span class="line">            resolve(data);</span><br><span class="line">    &#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">;(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFilePromise(<span class="string">&#x27;/db1.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFilePromise(<span class="string">&#x27;/db2.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样我们的异步任务代码就可以完美的嵌入到同步任务代码中了</p><h2 id="深挖原理"><a href="#深挖原理" class="headerlink" title="深挖原理"></a>深挖原理</h2><p>我们从最经典的异步任务 <code>setTimeout</code> 举例，把它改写成同步任务</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">await</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="comment">// 分别输出</span></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// p3</span></span><br></pre></td></tr></table></figure><ul><li><p>async 和 await 处理异步任务都是基于 Promise 的，await 后面需要跟一个返回 Promise 对象的函数。</p></li><li><p>如果 await 后跟的是一个普通函数，await 会将其 Promise 化。</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> otherTest();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">otherTest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherTest&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出 test start -&gt; otherTest -&gt; after test -&gt; test end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为其相当于变成了</span></span><br><span class="line"><span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test start&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        otherTest();</span><br><span class="line">    &#125;);</span><br><span class="line">    p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;test end&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>async/await是语法糖，用 async 标记的函数，在其内部遇到 await 标记的逻辑时，会被阻塞不执行后续的逻辑，等 await 内部的逻辑处理完毕后，再继续走await后面的逻辑，这个方式，其实就是 ES6 定义的 generator 函数。即 async 与 await 将标记的函数转换成了生成器。</p></li></ul><h3 id="手动实现一个-async-函数"><a href="#手动实现一个-async-函数" class="headerlink" title="手动实现一个 async 函数"></a>手动实现一个 async 函数</h3><p>将 函数 <code>p</code> 变成一个 generator 函数，其中遇到 await 的地方就改成 yield</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">p</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">yield</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续运行 p()，得到一个迭代器，调用  next()，我们需要手动调用这个 next 函数才会继续执行 函数p，所以我们需要一个自动执行的入口函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            next(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)(p);</span><br></pre></td></tr></table></figure><p>该函数会自动调用，我们执行了生成器 p 得到迭代器 gen，通过递归 next ，将 gen 自动执行到底（当 done =true 时，每次调用迭代器都会返回 <code>&#123;value: &#39;xxx&#39;, done: boolean&#125;</code> ）。</p><p>而当 yield 后面表达式返回 Promise 时，通过迭代器的 next 方法放到 Promise 的 then 中执行，使得 yield 后面的逻辑要等待 p1 完成后才能继续进行，即达到同步的效果。</p><p>可见 async/await 是通过将函数变为一个生成器函数，并使用自动执行函数来执行他，在执行过程中，有意地让生成的迭代器放到 Promise 的 then 中，即异步完成后才执行，从而达到的同步效果。</p><p>完整的流程</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">        res(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">p</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">yield</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            next(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)(p);</span><br></pre></td></tr></table></figure><ul><li>首先自动执行函数，执行生成器 p 得到迭代器 gen</li><li>调用 next 函数，执行 gen.next，此时执行器执行到 p 函数的 yield p1()，返回了一个 Promise，该 Promise 在 1s 后打印 p1 后并返回 p2</li><li>在此之前，自动执行函数，在该 Promise 的回调中传入了 next 方法</li><li>则 1s 后，打印 p1，返回 p2，执行 next(p2)</li><li>迭代器继续执行 yield p1 后面的逻辑，并且把 p2 赋值给了 <code>p2</code></li><li>打印 p2，p3</li><li>async / await 的实现原比我们实现的 demo 要复杂，但是核心逻辑就是 generator 结合自动执行函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;1、JS-是单线程&quot;&gt;&lt;a href=&quot;#1、JS-是单线程&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="前端" scheme="https://qybit.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="https://qybit.gitee.io/categories/%E5%89%8D%E7%AB%AF/JS/"/>
    
    
      <category term="前端" scheme="https://qybit.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="https://qybit.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>EQ-437-路径总和III</title>
    <link href="https://qybit.gitee.io/2021/09/28/437/"/>
    <id>https://qybit.gitee.io/2021/09/28/437/</id>
    <published>2021-09-28T10:13:24.000Z</published>
    <updated>2021-09-28T10:47:08.789Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p><h1 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以遍历出所有的可能情况，对于某个节点 $node$ 我们穷举出所有可能的路径，只要满足和为 $target$ 我们就认为找到了一条路径。</p><p>对于任意一个节点 $node$，我们都需要计算其子节点存在的可能路径，一共有 $n$ 个节点，因为时间复杂度为 $O(n^2)$。观察数据范围节点范围最大是 $1000$，因此可行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        getSum(root, <span class="number">0</span>, targetSum);</span><br><span class="line">        pathSum(root -&gt; left, targetSum);</span><br><span class="line">        pathSum(root -&gt; right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> cur, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        cur += root -&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        getSum(root -&gt; left, cur, target);</span><br><span class="line">        getSum(root -&gt; right, cur, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n^2)$，其中 $n$ 为二叉树节点的数量，对于某一个节点，我们要遍历其所有子节点，时间复杂度为 $O(n)$。一共有 $n$ 个节点，因此时间复杂度为 $O(n^2)$。</p><p>空间复杂度：$O(n)$，递归消耗的栈空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/path-sum-iii/&quot;&gt;437. 路径总和 III&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：深度优先搜索&quot;&gt;&lt;a href=&quot;#方法一：深度优先搜索&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="二叉树" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="https://qybit.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>EQ-2-两数相加</title>
    <link href="https://qybit.gitee.io/2021/09/27/2/"/>
    <id>https://qybit.gitee.io/2021/09/27/2/</id>
    <published>2021-09-27T10:21:40.000Z</published>
    <updated>2021-09-27T10:49:08.195Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></p><h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>由于两个链表都是<strong>逆序</strong>存储数字的位数，因此我们对于每一个相同位置的数字可以直接相加。</p><p>我们可以同时遍历链表，逐位计算每一位的和，并与当前进位的值和相加。如果当前位的数字分别为 $n1$ 和 $n2$ ，进位值 $carry$，那么当前位的和即表示为 $n1 + n2 + carry$，答案链表对应位置的数字即 $(n1 + n2 + carry) ; mod ; 10$，新的进位为 $\lfloor \frac{n1+n2+carry}{10} \rfloor$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        res -&gt; next = cur;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1 -&gt; val;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2 -&gt; val;</span><br><span class="line">            <span class="keyword">int</span> s = n1 + n2 + carry;</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            carry = s / <span class="number">10</span>;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1 -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(max(n, m))$，其中 $n$ 表示为链表1的长度，$m$ 表示为链表2的长度。我们会遍历两个链表的全部位置，且每个位置的处理时间为 $O(1)$。</p><p>空间复杂度：$O(max(n, m))$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot;&gt;2. 两数相加&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：模拟&quot;&gt;&lt;a href=&quot;#方法一：模拟&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="链表" scheme="https://qybit.gitee.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>EQ-371-两整数之和</title>
    <link href="https://qybit.gitee.io/2021/09/26/371/"/>
    <id>https://qybit.gitee.io/2021/09/26/371/</id>
    <published>2021-09-26T01:33:01.000Z</published>
    <updated>2021-09-26T02:16:26.953Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></p><h1 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>有符号整数在计算机中通常以补码的形式存储和表示，补码具有以下特征：</p><ol><li>正整数的补码与原码一致；负整数的补码为其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1</li><li>可以将减法运算转化为补码的加法运算来实现</li><li>补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算</li></ol><p>摘至：<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">百度百科-补码</a></p><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>首先，题目不允许使用运算符 <code>+</code> 和 <code>-</code> 。因此我们可以使用位运算代替这两种运算符的方式，观察一下我们在做补码加法时有如下四种情况</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span>;(进位)</span><br></pre></td></tr></table></figure><p>对于整数 $a$ 和 $b$，我们可以总结出：</p><ol><li>在不考虑进位的情况下，我们得到<strong>无进位加法结果</strong> $a \bigoplus b$。</li><li> 而所有需要进位的位为 $a \&amp; b$ ，<strong>进位结果</strong>可以表示为 $a \&amp; b &lt;&lt; 1$</li></ol><p>我们要求得 $a + b$ ，就表示为 <strong>无进位结果</strong> 和 <strong>进位结果</strong> 之和。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(log(C))$，令 $C$ 为有符号整数的位数，题目数据范围为 $32$ 位整数，因此 $C$ 最大可取值 $32$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-two-integers/&quot;&gt;371. 两整数之和&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;方法一：位运算&quot;&gt;&lt;a href=&quot;#方法一：位运算&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="位运算" scheme="https://qybit.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>EQ-583-两个字符串的删除操作</title>
    <link href="https://qybit.gitee.io/2021/09/25/583/"/>
    <id>https://qybit.gitee.io/2021/09/25/583/</id>
    <published>2021-09-25T09:51:56.000Z</published>
    <updated>2021-09-26T01:54:02.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>题目链接：<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p><a id="more"></a><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以设置 $f[i][j]$ 表示使得 $word1$ 前 $i$ 个字符 和  $word2$ 前 $j$ 个字符相等时的最小操作次数。</p><ol><li><p>对于 $0 \le i \lt word1.length$ 和 $ 0 \le j \lt word2.length$ 存在时，且我们是可以判断字符串 $word1[0…i-1]$ 和 字符串 $word2[0…j-1]$ 一定相等，那么对于 $word1$ 中第 $i$ 个字符 和 $word2$ 中第 $j$ 个字符有以下情况：</p><ol><li><p>$word1[i] = word2[j]$ ：</p><p> 我们不需要任何操作，因此 我们可以继承前 $i-1$ 个 和  前 $j -1$ 个字符相等时的最小操作次数。即 $f[i][j]=f[i-1][j-1]$</p></li><li><p>$word1[i] \neq word2[j]$：</p><ul><li>​    我们选择删除 $word1$ 中第 $i$ 个字符，假设此时字符串 $word1[0…i-1]$ 与字符串 $word2[0…j]$ 相等，那么需要的操作次数为 $f[i][j] = f[i-1][j] + 1$ </li><li>同理我们选择删除 $word2$ 中的第 $j$ 个字符，假设此时字符串 $word2[0…j-1]$ 与字符串 $word1[0…i]$ 相等，那么需要的操作次数为 $f[i][j]=f[i][j-1]+1$</li><li>我们选择同时删除 $word1$ 中的第 $i$ 个字符和 $word2$ 中的第 $j$ 个字符，那么此时需要的操作次数为 $f[i][j]=f[i-1][j-1]+2$</li><li>综合上述三种操作时，我们取最小值</li></ul></li></ol></li><li><p>状态转移方程定义<br> $$<br> f[i][j] =<br> \begin{cases}<br> f[i - 1][j - 1]&amp;, word1[i] = word2[j] \\<br> min({ f[i-1][j] + 1, f[i][j-1]+1, f[i-1][j-1]+2 })&amp;, word1[i] \ne word2[j]<br> \end{cases}<br> $$</p></li><li><p>初始化 $f$ 数组，我们的边界值实际上是当 $word1$ 或 $word2$ 为空字符串时</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i; <span class="comment">// word2 为空字符串时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j; <span class="comment">// word1 为空字符串时、</span></span><br></pre></td></tr></table></figure></li><li><p>以 <code>word1=sea</code> 和 <code>word2=eat</code> 举例，展示 $f$ 数组的状态</p><p> <img src="https://pic.imgdb.cn/item/614f04932ab3f51d91e2c486.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(&#123;f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>, f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p> 时间复杂度：$O(m \times n)$，其中 $m$ 为 $word1.length$，$n$ 为 $word2.length$ 。</p><p> 空间复杂度：$O(m \times n)$。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/delete-operation-for-two-strings/&quot;&gt;583. 两个字符串的删除操作&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="每日一题" scheme="https://qybit.gitee.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="动态规划" scheme="https://qybit.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>第 239 场周赛</title>
    <link href="https://qybit.gitee.io/2021/05/06/259/"/>
    <id>https://qybit.gitee.io/2021/05/06/259/</id>
    <published>2021-05-06T02:07:38.000Z</published>
    <updated>2021-09-23T13:18:44.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></li><li> <a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></li></ul><h1 id="T1：到目标元素的最小距离"><a href="#T1：到目标元素的最小距离" class="headerlink" title="T1：到目标元素的最小距离"></a>T1：<a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题目模拟一遍即可。</p><p>我们使用 $int32$ 的最大值$INT_MAX$ ，当 $nums[i] = target$ 时，保证 $abs(i - start)$ 的值最小即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ans =  min(ans, <span class="built_in">abs</span>(i - start)); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><p>空间复杂度：$O(1)$。</p><h1 id="T2：将字符串拆分为递减的连续值"><a href="#T2：将字符串拆分为递减的连续值" class="headerlink" title="T2：将字符串拆分为递减的连续值"></a>T2：<a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></h1><p>注意到：当我们确定了第一个数之后，后面的数也就随之确定下来了。因此我们在搜索的过程中，是可以避免过多的冗余计算。</p><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>具体做法</p><ul><li>对于每一次递归：<ul><li>我们需要记录的状态如下：$idx$ 表示当前字符串的位置，$prev$ 表示上一个数的大小，$cnt$ 表示当前连续降序数字的数量。</li><li>我们尝试去确定第一个数，从下标 $0$ 开始增加这个数。枚举每一个可能的数（不包括全部的字符串），因为连续的字符串至少存在两个。</li><li>对于已经确定的上一个数，我们总是想要寻找下一个数，因此需要记录<strong>当前数</strong> $cur$ 的大小，当且仅当 $cur = prev - 1$ 时，我们才会继续寻找下一个数。</li><li>当我们搜索到字符串的末尾时，只有存在两个连续数字时才符合要求，此时可以返回 $True$。</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 字符串的长度是 20 位，一定会爆 int32</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitString</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        s = str;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, ULL prev, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            <span class="comment">// 连续的数字，至少要存在两个</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ULL cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; n; i ++) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 当前数已经大于上一个数，此时直接退出即可。</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; prev - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span> || prev - cur == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>, cur, cnt + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(2^n)$，其中 $n$ 为字符串的长度且最大为 $20$。</p><p>空间复杂度：$O(n)$，递归消耗的栈内存。</p><h2 id="方法二：枚举"><a href="#方法二：枚举" class="headerlink" title="方法二：枚举"></a>方法二：枚举</h2><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于字符串 $s$，我们可以枚举出所有可能的字串。</p><p>按照递归的思路去改写我们的代码</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第一个整数不能是自身</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            start = start * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">            preVal = start</span><br><span class="line">            curVal = <span class="number">0</span></span><br><span class="line">            curIdx = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> preVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">all</span>(s[k] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(curIdx, n)):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                curVal = curVal * <span class="number">10</span> + <span class="built_in">int</span>(s[j])</span><br><span class="line">                <span class="comment"># 枚举的下一个字串超过前一个整数</span></span><br><span class="line">                <span class="keyword">if</span> curVal &gt; preVal - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> preVal - curVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == n - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    preVal = curVal</span><br><span class="line">                    curVal = <span class="number">0</span></span><br><span class="line">                    curIdx = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="T3：邻位交换的最小次数"><a href="#T3：邻位交换的最小次数" class="headerlink" title="T3：邻位交换的最小次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>先找到当前字符串的第 $k$ 个排列（我们称之为<strong>妙数</strong>）</li><li>原字符串 $s$ 与 妙数 $num$ 进行对比，如果在下标 $i$ 的位置不相同：<ol><li>我们在 妙数 的下标 $i$ 之后寻找一个下标 $j$ 使得 $s[i] = num[j]$ ，再将 $j$ 对应的元素相邻的交换到 $i$ 的位置。</li><li>每一次交换都是我们的最小交换次数</li></ol></li></ol><p>寻找下一个排序与 <a href="https://leetcode-cn.com/problems/next-permutation/">力扣31. 下一个排列</a> 相同。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i] &gt;= s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] &lt;= s[i]) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin() + i + <span class="number">1</span>, s.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = num;</span><br><span class="line">        <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">            nextPermutation(num);</span><br><span class="line">            <span class="comment">// c++ 内置的实现，同理</span></span><br><span class="line">            <span class="comment">// next_permutation(num.begin(), num.end());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != s[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; num[j] != s[i]) &#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                    swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">                    ans ++;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N \times K + N^2)$，其中 $N$ 为字符串的长度，$K$ 为给定的整数。</p><ul><li>我们先做 $K$ 次寻找下一个妙数，每一次寻找妙数的时间复杂度为 $O(N)$。</li><li>我们再寻找原字符串到达妙数的最小交换次数，最坏的情况下对于每一个元素我们要访问 $N$ 次，因此时间复杂度为 $O(N^2)$</li></ul><p>空间复杂度：$O(N)$，其中 $N$ 为字符串的长度。我们需要存储原字符串。</p><h1 id="T4：包含每个查询的最小区间"><a href="#T4：包含每个查询的最小区间" class="headerlink" title="T4：包含每个查询的最小区间"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></h1><h2 id="思路：离线算法"><a href="#思路：离线算法" class="headerlink" title="思路：离线算法"></a>思路：离线算法</h2><p>我们将区间的左端点和右端点以及查询视作 事件，然后对其按照左端点、查询和右端点进行排序：</p><ul><li>如果当前事件为左端点，我们将区间长度加入 有序集合 中</li><li>如果当前事件为查询，我们取出 有序集合 的最小值</li><li>如果当前事件为右端点，我们将当前区间的长度从 有序集合 中移除</li></ul><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="comment">// 0 表示左端点</span></span><br><span class="line">        <span class="comment">// 1 表示询问</span></span><br><span class="line">        <span class="comment">// 2 表示右端点</span></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="comment">// 事件的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="comment">// if type = 0: 区间右端点的位置</span></span><br><span class="line">        <span class="comment">// if type = 1: 询问在原数组的位置</span></span><br><span class="line">        <span class="comment">// if type = 2: 区间左端点的位置</span></span><br><span class="line">        <span class="keyword">int</span> para;</span><br><span class="line"><span class="comment">// 如果位置相同，优先按照左端点</span></span><br><span class="line">        <span class="comment">// 按照左端点、询问、右端点的优先级排序</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Event&amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == t.pos) <span class="keyword">return</span> type &lt; t.type;</span><br><span class="line">            <span class="keyword">return</span> pos &lt; t.pos; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size(), m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Event&gt; events;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="comment">// 查询事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">1</span>, queries[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">            <span class="comment">// 左端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">0</span>, interval[<span class="number">0</span>], interval[<span class="number">1</span>]&#125;);</span><br><span class="line"><span class="comment">// 右端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">2</span>, interval[<span class="number">1</span>], interval[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(events.begin(), events.end());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; seg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event : events) &#123;</span><br><span class="line">            <span class="comment">// 当前事件为左端点，把区间长度插入到 有序集合</span></span><br><span class="line">            <span class="keyword">if</span> (event.type == <span class="number">0</span>) &#123;</span><br><span class="line">                seg.insert(event.para - event.pos + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 查询事件</span></span><br><span class="line">                <span class="keyword">if</span> (seg.size()) &#123;</span><br><span class="line">                    <span class="comment">// 不为空的话，就取出最小值</span></span><br><span class="line">                    ans[event.para] = *seg.begin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 右端点，此时的小区间不必再查询，我们直接移除即可</span></span><br><span class="line">                <span class="keyword">int</span> len = event.pos - event.para + <span class="number">1</span>;</span><br><span class="line">                seg.erase(seg.find(len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O((m+n)log(m+n))$，其中 $m$ 为区间数组 $intervals$ 的长度，$n$ 为查询数组 $queries$ 的长度。我们将其合并成一个 事件 数组，容量大小为 $2m + n = O(m + n)$。然后进行了排序操作，因此时间复杂度为 $O((m + n)log(m+n))$。</p><p>空间复杂度：$O(m+n)$，我们需要存储所有的事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/&quot;&gt;到目标元素的最小距离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯" scheme="https://qybit.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>第 237 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/19/w237/"/>
    <id>https://qybit.gitee.io/2021/04/19/w237/</id>
    <published>2021-04-19T01:49:11.000Z</published>
    <updated>2021-09-26T02:16:09.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/"> 判断句子是否为全字母句</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></li><li> <a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></li><li> <a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></li></ul><h1 id="T1：判断句子是否为全字母句"><a href="#T1：判断句子是否为全字母句" class="headerlink" title="T1：判断句子是否为全字母句"></a>T1：<a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>全字母句就是一个字符串包含字母表中的 $26$ 个字母。我们只需要开一个 $26$ 长度的数组记录一下字母的出现次数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfPangram</span><span class="params">(<span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : sentence) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : f) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度，我们需要扫描一遍字符串。</p><p>空间复杂度：$O(1)$。这里我们只使用了常数级别的数组空间。</p><h1 id="T2：雪糕的最大数量"><a href="#T2：雪糕的最大数量" class="headerlink" title="T2：雪糕的最大数量"></a>T2：<a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们的现金是固定的，而且我们可以按照任意的顺序去购买雪糕。</p><p>而且我们可以选择的仅有 $n$ 支雪糕，对于第 $i$ 支雪糕，我们要尽可能的选择定价更小的雪糕。只有我们每次都选择定价更小的雪糕，这样才可以买更多的雪糕。</p><p>所以我们可以对雪糕的定价进行排序，使得我们每次选择价格较小的雪糕。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        sort(costs.begin(), costs.end());</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cost : costs) &#123;</span><br><span class="line">            s += cost;</span><br><span class="line">            <span class="keyword">if</span> (s &lt;= coins) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p><p>空间复杂度：$O(1)$。</p><h1 id="T3：单线程-CPU"><a href="#T3：单线程-CPU" class="headerlink" title="T3：单线程 CPU"></a>T3：<a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</p><ul><li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态</li><li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 <strong>执行时间最短</strong> 的任务开始执行。</li><li>如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li><li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li><li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li></ul><p>具体实现：</p><ul><li>我们需要自定义一个数据结构来增强 $Task$，增加一个数组的下标</li><li>对于 $Task$ 数组，我们需要找出最早入队执行的任务，因此对 $Task$ 数组按照入队时间排序</li><li>我们还需要一个数据结构来模拟 CPU，可以使用 堆 实现<ul><li>对于堆中的任务，我们总是选择执行时间最短的任务开始执行</li><li>如果有多个执行时间相同的任务，我们选择下标最小的任务</li></ul></li><li>当 CPU空闲 / 堆为空 时，直接把开始执行小于等于时间戳的任务顺序入队</li><li>每次都执行一个任务，统计时间戳的累计时间</li><li>当我们把任务都入队时，即表示 CPU 可以按照顺序把任务执行完毕</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> ep;</span><br><span class="line">        <span class="keyword">int</span> pt;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            id = a;</span><br><span class="line">            ep = b;</span><br><span class="line">            pt = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getOrder(<span class="keyword">int</span>[][] t) &#123;</span><br><span class="line">        List&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = t.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> Task(i, t[i][<span class="number">0</span>], t[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按入队时间升序排序</span></span><br><span class="line">        Collections.sort(tasks, (t1, t2) -&gt; t1.ep - t2.ep);</span><br><span class="line">        PriorityQueue&lt;Task&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行时间相同，id 升序</span></span><br><span class="line">            <span class="keyword">if</span> (t1.pt == t2.pt) &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.id - t2.id;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行时间升序</span></span><br><span class="line">            <span class="keyword">return</span> t1.pt - t2.pt;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 时间戳</span></span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 把小于等于当前时间戳的任务都入队</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                heap.offer(tasks.get(i ++));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CPU 空闲</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty()) &#123;</span><br><span class="line">                now = (<span class="keyword">long</span>)tasks.get(i).ep;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                    heap.offer(tasks.get(i ++));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行一个任务</span></span><br><span class="line">            Task task = heap.poll();</span><br><span class="line">            ans[p ++] = task.id;</span><br><span class="line">            now += task.pt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有任务都进入 待执行状态，顺序执行即可</span></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            ans[p ++] = heap.poll().id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 表示任务的数量。</p><ul><li>我们对任务按照入队时间进行排序，时间复杂度 $O(NlgN)$。</li><li>在最坏的情况下，所有的任务都会进入 堆 中，此时堆的调整次数为 $N$ 次，每次调整的时间复杂度为 $O(lgN)$。因此时间复杂度为 $O(NlgN)$。</li></ul><p>空间复杂度：$O(N)$。最坏的情况下，我们建堆的空间和任务数量一致。</p><h1 id="T4：所有数对按位与结果的异或和"><a href="#T4：所有数对按位与结果的异或和" class="headerlink" title="T4：所有数对按位与结果的异或和"></a>T4：<a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>从 $arr1$ 中任意取一个数 $a$，从 $arr2$ 中任意取两个数 $b_1, b_2$，则有：<br>$$<br>\begin{align}<br>(a &amp; b_1) \bigoplus (a &amp; b_2) = &amp; [(a | \lnot b_1)&amp;(\lnot a | b_2)] | [(a | b_1) &amp; (\lnot a | \lnot b_2)] \\<br> = &amp; (\lnot a &amp; \lnot b_1 &amp; b_2) | (a &amp; b_1 &amp; \lnot b_2) \\<br> = &amp; a &amp; [(\lnot b_1 &amp; b_2) | (b_1 &amp; \lnot b_2)] \\<br> = &amp; a &amp; (b_1 \bigoplus b_2)<br>\end{align}<br>$$<br>推广到 $arr2$ 中的所有数 $0 \le i \le m$<br>$$<br>[(a &amp; b_1) \bigoplus (a &amp; b_2) \bigoplus (a &amp; b_3) … (a &amp; b_m)] = [a &amp; (b_1 \bigoplus b_2 \bigoplus b_3 \bigoplus … \bigoplus b_m)]<br>$$<br>同理，推广到 $arr1$ 中的所有的数 $0 \le i \le n$<br>$$<br>\begin{align}<br>[(a_1 &amp; b_1) \bigoplus (a_2 &amp; b_2) \bigoplus (a_3 &amp; b_3) \bigoplus … \bigoplus (a_i &amp; b_j)] = &amp; [[a_1 &amp; (b_1  \bigoplus … \bigoplus b_j)]  \bigoplus … \bigoplus [a_i &amp; (b_1  \bigoplus … \bigoplus b_j)]] \\<br>= &amp; [a_1 \bigoplus a_2 \bigoplus … \bigoplus a_i] &amp; [b_1 \bigoplus b_2 \bigoplus …\bigoplus b_j]<br>\end{align}<br>$$<br>因此，我们只需要分别计算 $s_1 = \sum_{i=0}^n xor(a[i])$ 和 $s_2 = \sum_{j=0}^m xor(b[j])$。再计算  $s_1 &amp; s_2$ 即为本题的答案。 </p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr1) s1 ^= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr2) s2 ^= n;</span><br><span class="line">        <span class="keyword">return</span> s1 &amp; s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n + m)$，其中 $n$ 和 $m$ 分别为数组 $arr1$ 和 $arr2$ 的长度。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/&quot;&gt; 判断句子是否为全字母句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="字符串" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="数组" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/%E5%A0%86/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F/%E5%A0%86/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/tags/%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>第 236 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/12/w236/"/>
    <id>https://qybit.gitee.io/2021/04/12/w236/</id>
    <published>2021-04-12T07:23:07.000Z</published>
    <updated>2021-09-23T13:18:44.003Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></li><li> <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></li><li> <a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></li></ul><h1 id="T1：数组元素积的符号"><a href="#T1：数组元素积的符号" class="headerlink" title="T1：数组元素积的符号"></a>T1：<a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力即可，但是不建议直接对数组进行乘法操作，可能会爆 $int$ 甚至是 $64$ 位的整形。</p><p>我们只需要统计 负数 的存在个数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySign</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mask := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            mask ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mask % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。我们至多只会对数组扫描一遍。</p><p>空间复杂度：$O(1)$</p><h1 id="T2：找出游戏的获胜者"><a href="#T2：找出游戏的获胜者" class="headerlink" title="T2：找出游戏的获胜者"></a>T2：<a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一个裸的约瑟夫环问题。由于数据范围不大，所以直接模拟也是可行的</p><p>具体证明本文不再赘述，请参考博客：<a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环问题公式推导</a></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheWinner</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = (p + k) % i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为小伙伴的数量。</p><p>空间复杂度：$O(1)$</p><h1 id="T3：最少侧跳次数"><a href="#T3：最少侧跳次数" class="headerlink" title="T3：最少侧跳次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></h1><h2 id="方法一：BFS-求最短路"><a href="#方法一：BFS-求最短路" class="headerlink" title="方法一：BFS 求最短路"></a>方法一：BFS 求最短路</h2><h3 id="问题转换"><a href="#问题转换" class="headerlink" title="问题转换"></a>问题转换</h3><p>我们可以把赛道想象成一个 $3 \times n$ 的一个矩阵，我们从 $(2, 0)$ 点出发，问到达最后一列所需要的最短步长？</p><p>当然，我们这里的步长是指到达当前点 $(x, y)$ 时，我们跳跃的最小步数。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们在每次选择下一次的 ”落脚点“ 时，总是贪心的选择最少跳跃次数的点。因此，我们可以当作一个迪杰斯特拉的最短路算法。</p><p>注意点：我们在构建矩阵时，为了更好的判断障碍物，我们将会构建 $4 \times n$ 的矩阵。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, x, y;</span><br><span class="line">    <span class="comment">// 重载运算符 &lt;，表示构建小根堆。每次弹出堆的都是 d 最小的一个</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pos&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; p.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSideJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Pos&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> col = obstacles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> d = p.d;</span><br><span class="line">            <span class="comment">// 到达最后一列</span></span><br><span class="line">            <span class="keyword">if</span> (p.y == col - <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p.x + dx[i], y = p.y + dy[i];</span><br><span class="line">                <span class="comment">// 越界检查</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 下一个点是障碍物</span></span><br><span class="line">                <span class="keyword">if</span> (obstacles[y] == x) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dx[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果跳了，就消耗一步</span></span><br><span class="line">                    cost = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d + cost &lt; dist[x][y]) &#123;</span><br><span class="line">                    dist[x][y] = d + cost;</span><br><span class="line">                    pq.push(&#123;dist[x][y], x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(4 \times N)$，其中 $N$ 为障碍物的长度。</p><ul><li>我们在最坏的情况下，可能要对整个矩阵进行扫描。</li></ul><p>空间复杂度：$O(4 \times N)$，我们需要存储所有可能的点。</p><h1 id="T4：求出-MK-平均值"><a href="#T4：求出-MK-平均值" class="headerlink" title="T4：求出 MK 平均值"></a>T4：<a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>$Python$ 可以偷税暴力过</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, m: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.m = m</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addElement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.nums.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMKAverage</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &lt; self.m:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        last = self.nums[-self.m :]</span><br><span class="line">        last.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(mean(last[self.k : -self.k]))</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^2)$，其中 $calculateMKAverage$ 方法会调用 $10^5$ 次。每一次操作的数组最大长度也是 $10^5$。因此时间复杂度为 $O(N^2)$</p><p>空间复杂度：$O(N)$，我们要存储原数组和临时数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/&quot;&gt;数组元素积的符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https://l
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="BFS" scheme="https://qybit.gitee.io/tags/BFS/"/>
    
      <category term="DP" scheme="https://qybit.gitee.io/tags/DP/"/>
    
      <category term="设计" scheme="https://qybit.gitee.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="堆" scheme="https://qybit.gitee.io/tags/%E5%A0%86/"/>
    
      <category term="队列" scheme="https://qybit.gitee.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实践-豆瓣TOP250</title>
    <link href="https://qybit.gitee.io/2021/04/07/doubantop250/"/>
    <id>https://qybit.gitee.io/2021/04/07/doubantop250/</id>
    <published>2021-04-07T13:33:06.000Z</published>
    <updated>2021-09-23T13:18:43.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集中 学习+复习 Go 语言有一个多星期了，也该写点东西了。</p><p>说下使用的 Go 语言的感受吧，直观上来说。Go 刚上手是比较反人类的，比如变量名和变量类型的位置是反着的，已经函数和方法的返回值的位置就更加的奇怪了。但是，总体的上手难度不是很大。相反，我认为这些也是 Go 的一大特色吧 (笑)。总体的学习门槛是比较低的，而且 Go 身上也有很多 C/C++ 的影子 (比如指针类型，还有结构体)。最让我感到意外的就是，Go 语言中的接口的设计，真正的做到了低耦合。因为只要任意一个结构体或者类型实现了接口中的方法后，就算是真正意义上的实现了一个接口。而当我们从代码里 “拿走” 这个接口时，是不会影响到实现了该接口的结构体或者类型，因为那只是它们的方法而已。</p><p>你可能会疑惑，为什么要从爬虫开始实践？</p><p>我认为兴趣是最好的老师，我不喜欢死板的去写 ”xxx通讯录管理系统“ 或者 ”xxx管理系统“ 之类的无聊 demo。我是兴趣驱动，我更愿意从爬虫入手去学习。</p><p>本来打算拿我的看家本领 Senlium 呢，结果到官网一查还不支持 Go。</p><p>好的，说的有点多了，下面开始我们的 Go 语言爬虫实践吧。</p><p>项目地址：<a href="https://github.com/qybit/doubantop250">项目地址</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>开发环境</p><ul><li>go version go1.16.2 windows/amd64</li><li>goland</li><li>第三方库 goquery（一个类似jQuery可以操作DOM的库）</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>结构体</li><li>函数 / 方法</li><li>http</li><li>懂得 DOM 编程，至少会 JavaScript 中的 DOM 部分</li><li>正则表达式</li><li> 异常处理</li><li>json</li><li>io 处理</li></ul><h2 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h2><p>我们的工作目录长这样👇。Movie 应该写成 movie 的，写 Java 写顺手了 (笑)。</p><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/doubantop250_0.png"></p><h2 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h2><p>作为一只合格的网络爬虫，我们必须要可以发起基本的 http 请求获得网页数据。</p><p>正规的网站，一般最基础的防御就是通过 User-Agent / Agent 字段的校验，来检测是不是真人用户操作。我们只需要在请求头中加入这一字段，把自己 “伪装” 成真人用户，具体内容可以在浏览器查看。这里不在赘述。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用获取的响应内容，构建-DOM-树"><a href="#使用获取的响应内容，构建-DOM-树" class="headerlink" title="使用获取的响应内容，构建 DOM 树"></a>使用获取的响应内容，构建 DOM 树</h2><p>这一步，我们将会使用 goquery 库，它会帮助我们把网络请求的响应内容解析成一颗 DOM 树。并提供和 JavaScript 和 jQuery 类似的 API 供我们访问某个节点。</p><p>这里的 content 实际上就是 响应的Body 部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析单个页面的所有电影内容"><a href="#解析单个页面的所有电影内容" class="headerlink" title="解析单个页面的所有电影内容"></a>解析单个页面的所有电影内容</h2><p>我们拿到上面生成的 goquery.Document 对象， goquery 提供的选择器的功能和 jQuery 几乎一模一样。所以有过 jQuery 使用经验的话，上手 goquery 是非常容易的。这里的稍微麻烦点的就是我们处理字符串的时候。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">movie := &amp;entity.Movie&#123;</span><br><span class="line">Title:    title,</span><br><span class="line">Subtitle: subtitle,</span><br><span class="line">Other:    other,</span><br><span class="line">Cover:    cover,</span><br><span class="line">Desc:     desc,</span><br><span class="line">Year:     year,</span><br><span class="line">Area:     area,</span><br><span class="line">Tag:      tag,</span><br><span class="line">Star:     star,</span><br><span class="line">Comment:  comment,</span><br><span class="line">Quote:    quote,</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>这里将会调用上面的所有方法，然后根据用户输入的信息，进行决策。</p><p>比如从哪一页开始获取，以及是否需要持久化等</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   content, err := fetchSinglePageContent(URL, start)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   dom, err := generatorDomTree(content)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   books, err := parseSinglePage(dom)</span><br><span class="line">   <span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">      fmt.Println(book)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      data, _ := json.Marshal(books)</span><br><span class="line">      err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/toubantop250.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module qybit.com/doubantop250</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require github.com/PuerkitoBio/goquery v1<span class="number">.6</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="entiy-包"><a href="#entiy-包" class="headerlink" title="entiy 包"></a>entiy 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span> <span class="string">`json:&quot;title&quot;`</span><span class="comment">// 中文名</span></span><br><span class="line">Subtitle <span class="keyword">string</span> <span class="string">`json:&quot;subtitle&quot;`</span><span class="comment">// 英文名</span></span><br><span class="line">Other    <span class="keyword">string</span> <span class="string">`json:&quot;other&quot;`</span><span class="comment">// 港澳台翻译名</span></span><br><span class="line">Cover    <span class="keyword">string</span> <span class="string">`json:&quot;cover&quot;`</span><span class="comment">// 电影封面</span></span><br><span class="line">Desc     <span class="keyword">string</span> <span class="string">`json:&quot;desc&quot;`</span><span class="comment">// 描述</span></span><br><span class="line">Year     <span class="keyword">string</span> <span class="string">`json:&quot;year&quot;`</span><span class="comment">// 上映年份</span></span><br><span class="line">Area     <span class="keyword">string</span> <span class="string">`json:&quot;area&quot;`</span><span class="comment">// 属于哪个国家</span></span><br><span class="line">Tag      <span class="keyword">string</span> <span class="string">`json:&quot;tag&quot;`</span><span class="comment">// 属于哪一类型的电影</span></span><br><span class="line">Star     <span class="keyword">string</span> <span class="string">`json:&quot;star&quot;`</span><span class="comment">// 评分</span></span><br><span class="line">Comment  <span class="keyword">string</span> <span class="string">`json:&quot;comment&quot;`</span><span class="comment">// 参与评分的人数</span></span><br><span class="line">Quote    <span class="keyword">string</span> <span class="string">`json:&quot;quote&quot;`</span><span class="comment">// 宣传标语</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spider-包"><a href="#spider-包" class="headerlink" title="spider 包"></a>spider 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spider</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/PuerkitoBio/goquery&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;qybit.com/doubantop250/entity&quot;</span></span><br><span class="line"><span class="string">&quot;regexp&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">URL          <span class="keyword">string</span> = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span></span><br><span class="line">DefaultCover <span class="keyword">string</span> = <span class="string">&quot;https://img.imgdb.cn/item/601fdca33ffa7d37b326de61.jpg&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">movie := &amp;entity.Movie&#123;</span><br><span class="line">Title:    title,</span><br><span class="line">Subtitle: subtitle,</span><br><span class="line">Other:    other,</span><br><span class="line">Cover:    cover,</span><br><span class="line">Desc:     desc,</span><br><span class="line">Year:     year,</span><br><span class="line">Area:     area,</span><br><span class="line">Tag:      tag,</span><br><span class="line">Star:     star,</span><br><span class="line">Comment:  comment,</span><br><span class="line">Quote:    quote,</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">content, err := fetchSinglePageContent(URL, start)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">dom, err := generatorDomTree(content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">books, err := parseSinglePage(dom)</span><br><span class="line"><span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">fmt.Println(book)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">data, _ := json.Marshal(books)</span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> k <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= page; i++ &#123;</span><br><span class="line">parseOnePage(strconv.Itoa(k), i, ok)</span><br><span class="line">k += <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;qybit.com/doubantop250/spider&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;请输入要爬取的页数，最大10页：&quot;</span>)</span><br><span class="line">cin := bufio.NewScanner(os.Stdin)</span><br><span class="line">cin.Scan()</span><br><span class="line">page, err := strconv.Atoi(cin.Text())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;输入数据不合法，请按照要求输入！&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot;是否需要持久化？（请输入 yes/y 或者 no/n）&quot;</span>)</span><br><span class="line">cin.Scan()</span><br><span class="line">ok := cin.Text()</span><br><span class="line">isOk := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> ok == <span class="string">&quot;yes&quot;</span> || ok == <span class="string">&quot;y&quot;</span> &#123;</span><br><span class="line">isOk = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">spider.Run(page, isOk)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;集中 学习+复习 Go 语言有一个多星期了，也该写点东西了。&lt;/p&gt;
&lt;p&gt;说下使用的 Go 语言的感受吧，直观上来说。Go 刚上手是比较反
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
      <category term="Go" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/Go/"/>
    
    
      <category term="Go" scheme="https://qybit.gitee.io/tags/Go/"/>
    
      <category term="爬虫" scheme="https://qybit.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>第 235 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/05/259/"/>
    <id>https://qybit.gitee.io/2021/04/05/259/</id>
    <published>2021-04-05T06:00:31.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></li><li><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></li><li><a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></li></ul><h1 id="T1：截断句子"><a href="#T1：截断句子" class="headerlink" title="T1：截断句子"></a>T1：<a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></h1><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不同单词之间是按照空格隔开的，因此我们统计空格数量即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">truncateSentence</span><span class="params">(s <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cnt <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            cnt ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == k &#123;</span><br><span class="line">            <span class="keyword">return</span> s[:i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(\sum)$，其中 $\sum$ 为前 $k$ 个单词的长度。</p><p>空间复杂度：$O(1)$，我们只使用了常数的空间</p><h1 id="T2：查找用户活跃分钟数"><a href="#T2：查找用户活跃分钟数" class="headerlink" title="T2：查找用户活跃分钟数"></a>T2：<a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></h1><p>典型的阅读理解</p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先看看我们要返回的答案到底是什么。</p><p>$answer[j] (1 \le j \le k )$ 表示 <strong>用户活跃分钟数</strong>  等于 $j$ 的用户数。老谜语人了，其实说白了就是：<strong>一个用户总共的活跃分钟数恰好等于 $j$ 的人数</strong>。</p><p>另外，一个用户在同一个分钟可以活跃多次，也就是说我们还要处理去重。</p><p>我们的解决方法很简单，使用 哈希表 即可实现去重。</p><p>那么，还存在一个问题，如何知道一个用户一共活跃了多少次呢？</p><p>我们仍然可以使用 哈希表 来实现，那么这就是一个嵌套的 哈希表 结构，如果不熟练这样的写法的话，说明基础语法还有待加强。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findingUsersActiveMinutes</span><span class="params">(logs [][]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, log := <span class="keyword">range</span>(logs) &#123;</span><br><span class="line">        id, time := log[<span class="number">0</span>], log[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> _, ok := count[id]; !ok &#123;</span><br><span class="line">            count[id] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        count[id][time] = INF </span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> _, cnt := <span class="keyword">range</span>(count) &#123;</span><br><span class="line">        ans[<span class="built_in">len</span>(cnt) - <span class="number">1</span>] ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><ul><li>我们会遍历一次数组，收集所有用户的活跃信息</li><li>我们还会遍历一次哈希表，这个取决于存在的用户数量，用户数量最大不会超过数组长度。</li><li>因此我们的最终时间复杂度为 $O(2\times N) = O(N)$</li></ul><p>空间复杂度：$O(N)$，我们会存储所有用户的信息</p><h1 id="T3：绝对差值和"><a href="#T3：绝对差值和" class="headerlink" title="T3：绝对差值和"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></h1><h2 id="方法一：排序-二分查找"><a href="#方法一：排序-二分查找" class="headerlink" title="方法一：排序 + 二分查找"></a>方法一：排序 + 二分查找</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目定义：</p><p>绝对差值和：$\sum_{i=0}^n |nums1[i] - nums2[i]|$</p><p>再搞清楚我们的目的：我们可以选用 $nums1$ 中的任意一个元素替换 $nums1$ 中的至多一个元素，使得绝对值差和最小化。</p><p>具体做法：</p><ol><li>我们可以预先计算好未 <strong>替换</strong> 元素前的绝对值差</li><li>尝试 <strong>替换</strong> 操作，我们在 $nums1$ 中找到一个<strong>最逼近</strong> $nums2[i]$ 的一个元素<ol><li>快速查找的话，我们可以想到二分查找，因此需要对 $nums1$ 进行排序操作</li><li>对于 $nums2$ 中的每一个元素，都尝试查找元素值相近的一个下标 $p$</li><li>替换完毕后，计算 $nums1[p] - nums2[i]$ 的最小值，这样可以说明两个元素很相近</li><li>再计算出偏移量 $shrink$ ，使得 $shrink$ 的值最大化，这样可以使得 绝对值差和 最小。</li></ol></li><li>我们第一步已经计算好了 <strong>未替换</strong> 元素的绝对值差，第二步我们模拟了 <strong>替换</strong> 操作后，找出了偏移量最大的替换方案，直接减去即可。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>值得注意的是，在 $Go$ 中 $int$ 默认是 $64$ 位的，因此其他语言在实现的过程中，建议使用 $64$ 位的整型变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums1)</span><br><span class="line">    cnt := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">var</span> ans, shrink <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cnt[i] = abs(nums1[i] - nums2[i])</span><br><span class="line">        ans += cnt[i]</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(nums1)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cost := cnt[i]</span><br><span class="line">        <span class="keyword">var</span> delta <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// p 是nums1中对应元素大于等于 nums2[i] 的一个下标</span></span><br><span class="line">        p := lowerBound(nums1, nums2[i])</span><br><span class="line">        <span class="comment">// fmt.Println(p)</span></span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 可能越界。</span></span><br><span class="line">            <span class="keyword">if</span> p == n &#123;</span><br><span class="line">                p --</span><br><span class="line">            &#125;</span><br><span class="line">            delta = min(abs(nums1[p] - nums2[i]), abs(nums1[p - <span class="number">1</span>] - nums2[i])) </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delta = abs(nums1[p] - nums2[i])</span><br><span class="line">        &#125;</span><br><span class="line">        shrink = max(shrink, abs(cost - delta))</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= shrink</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找出大于等于 x 的下标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= x &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p><ul><li>我们遍历一次数组预计算出未替换前的绝对值差和，时间复杂度 $O(N)$</li><li>对数组进行排序操作，$Go$ 实现的排序为快速排序时间复杂度为 $O(NlgN)$</li><li>我们会遍历 $nums2$ 数组，对于$nums2$ 数组中的任意一个元素都尝试去 $nums1$ 中找出一个最逼近的元素，二分查找的时间复杂度为 $O(lgN)$，因此总的时间复杂度为 $O(NlgN)$</li></ul><p>空间复杂度：$O(N)$，我们要存储未替换前的绝对值差。</p><h1 id="T4：序列中不同最大公约数的数目"><a href="#T4：序列中不同最大公约数的数目" class="headerlink" title="T4：序列中不同最大公约数的数目"></a>T4：<a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></h1><h2 id="方法一：数学"><a href="#方法一：数学" class="headerlink" title="方法一：数学"></a>方法一：数学</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们不必去找这个子序列，然后计算出最大公约数 $g$，我们直接枚举最大公约数 $g$ 去构造这个子序列。</p><p>假设一个数组存在最大公约数 $g$ ，那么数组中的任意一个元素都是最大公约数 $g$ 的倍数。</p><p>我们在构造这个子序列的过程中，选择的最大公约数 $g$ 的倍数必须存在于数组中，否则就不能称之为子序列。</p><p>具体做法：</p><ul><li>首先确定最大公约数 $g$ 的范围，设 $m$ 为数组 $nums$ 的最大值。那么 $1 \le g \le m$</li><li>我们假设最大公约数 $x (1 \le x \le m)$ ，然后枚举出所有不大于 $m$ 且存在与数组 $nums$ 中的所有 $x$ 的倍数 $y$ 。当且仅当所有 $y$ 的最大公约数等于 $x$ 时，说明我们找到一个可行的 子序列。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> vis []<span class="keyword">bool</span> = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> y := x; y &lt;= m; y += x &#123;</span><br><span class="line">        <span class="keyword">if</span> vis[y] &#123;</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span> &#123;</span><br><span class="line">                t = y</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = gcd(t, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局遍历存在干扰，使用之前必须重置</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    vis = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span>(nums) &#123;</span><br><span class="line">        m = max(m, v)</span><br><span class="line">        vis[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> check(i) &#123;</span><br><span class="line">            ans ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n^2)$，其中 $n$ 为数组 $nums$ 中的最大值。</p><p>空间复杂度：$O(n)$，其中 $n$ 为数组 $nums$ 中的最大值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/truncate-sentence/&quot;&gt;截断句子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/probl
      
    
    </summary>
    
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%91%A8%E8%B5%9B/"/>
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%91%A8%E8%B5%9B/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="二分" scheme="https://qybit.gitee.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="哈希" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Spring IoC 容器</title>
    <link href="https://qybit.gitee.io/2021/04/03/Spring-IoC/"/>
    <id>https://qybit.gitee.io/2021/04/03/Spring-IoC/</id>
    <published>2021-04-03T12:13:32.000Z</published>
    <updated>2021-09-23T13:18:44.001Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 中最重要的就是 IoC 和 AOP，我们平时使用 Spring 最多的就是 IoC，那么为啥不去深入了解一下其中的原理呢？本篇作为 Spring IoC 源码探究的文章之一，后续有机会的话将会更新 Spring MVC、MyBatis 等源码探究。</p><p>阅读本篇时，请打开 IDE 和我一起深入 IoC 容器内部的工作环境，了解 IoC 的实现细节。</p><p>本文的着重点在于 </p><ol><li><p>Bean 容器的创建；</p></li><li><p>Bean 的实例化和初始化 </p></li></ol><p>如有不足之处，欢迎讨论。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>基本的 Spring 5.3.1 运行环境</li><li>支持断点调试的 IDE</li><li>本文选择从 xml 配置文件启动</li></ol><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开始分析代码之前，先看一下基本的一个架构图</p><p><img src="https://img.imgdb.cn/item/5fd4cb8a3ffa7d37b3513ae3.png"></p><p>基本的启动代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserController controller = applicationContext.getBean(<span class="string">&quot;userController&quot;</span>, UserController.class);</span><br><span class="line">    controller.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件 （接口或者类，请任意定义一个即可）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.qybit.spring.controller.UserController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>从 <code> ApplicationContext applicationContext = new ClassPathXmlApplicationContext(...);</code> 可以发现，我们是从 xml 文件加载的，而且是可以传入多个配置文件。</p><h1 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h1><p>进入 ClassPathXmlApplicationContext 类中，发现定义为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">// 这是我们 Spring 启动的一个核心方法</span></span><br><span class="line">            <span class="comment">// 下面我们会深入其内部，逐个分析各个方法具体做了什么</span></span><br><span class="line">            refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext#refresh 方法，refresh 方法是构建 ApplicatinContext 的，当一个 IoC 容器成功创建后，我们还可以调用 refresh 方法销毁原来的 ApplicationContext，然后进行重建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保证构建当前 ApplicationContext 的完整性，不能有别的线程干扰</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 不是重点，不管它</span></span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备 refresh，记录启动时间，设置激活状态</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是将 配置文件 中定义的 bean 标签，解析成 BeanDefition，然后注册到 BeanFactory</span></span><br><span class="line">        <span class="comment">// 此时仅仅是对 Bean 的定义信息的一个保存，而不是实例化操作</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的类加载，添加 BeanPostProcessor</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">            <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 BeanPostProcessor 的实现类，</span></span><br><span class="line">            <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">            <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i18n 国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 AppplicationContext 事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 钩子函数</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册事件监听器，需要实现 ApplicationListener 接口</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有的 Singleton Bean  lazy-init 除外</span></span><br><span class="line">            <span class="comment">// 核心</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一步，广播事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 日志记录</span></span><br><span class="line">            <span class="comment">// 销毁已经创建的 Bean</span></span><br><span class="line">            <span class="comment">// 撤销状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐个介绍 refresh() 方法里的重要方法</p><h2 id="refresh-的准备工作"><a href="#refresh-的准备工作" class="headerlink" title="refresh 的准备工作"></a>refresh 的准备工作</h2><p>看看代码就可以知道做了哪些事情</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验配置文件</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Bean-容器，并注册-Bean"><a href="#创建-Bean-容器，并注册-Bean" class="headerlink" title="创建 Bean 容器，并注册 Bean"></a>创建 Bean 容器，并注册 Bean</h2><p>回到 refresh() 方法中的 obtainFreshBeanFactory() 方法。</p><p>这一步是初始化 Bean 容器，并注册保存 Bean 的信息。这也是本文重点讨论的一个方法。注意此步并没有实例化 Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果存在过 BeanFactory就先销毁，然后创建新的 BeanFactory，加载 Bean 定义，注册 Bean等</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回新创建的 BeanFactory</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext#refreshBeanFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 假设存在过 BeanFactory，先销毁</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 BeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 设置 序列化 ID</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 自定义 BeanFactory，设置：是否允许 Bean 重写，是否允许循环引用</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载 Bean 定义</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext#customizeBeanFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否允许 Bean 重写</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否允许循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractXmlApplicationContext#loadBeanDefinitions</p><p>加载 Bean 信息</p><p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还在当前类中，我们已经实例化了 Reader，接下来是要把 xml 文件转换成一颗 DOM 树，用于获取用户定义的 Bean。</p><p>// AbstractXmlApplicationContext</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 下面逐个记载所有的配置文件</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 走到下面这一步</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        count += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向下走</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Collections.addAll(actualResources, resources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 320</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ThreadLocal 存放文件资源</span></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正执行的方法</span></span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类 386 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 转换成 DOM 树</span></span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// 开始注册</span></span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        ....</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 508 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 真正执行的方法</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 94 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 128 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    .......</span><br><span class="line">        <span class="comment">// 钩子函数</span></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">    <span class="comment">// 从 根节点 开始解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 钩子函数</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过漫长的寻找，我们找到了 parseBeanDefinitions(root, this.delegate) 最终的解析方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">// 默认的</span></span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他的</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看默认中处理 <code>&lt;bean /&gt;</code> 标签的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前文件 305 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p><table><thead><tr><th>Property</th><th></th></tr></thead><tbody><tr><td>class</td><td>类的全限定名</td></tr><tr><td>name</td><td>可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td>scope</td><td>作用域</td></tr><tr><td>constructor arguments</td><td>指定构造参数</td></tr><tr><td>properties</td><td>设置属性的值</td></tr><tr><td>autowiring mode</td><td>no(默认值)、byName、byType、 constructor</td></tr><tr><td>lazy-initialization mode</td><td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td>initialization method</td><td>bean 属性设置完成后，会调用这个方法</td></tr><tr><td>destruction method</td><td>bean 销毁后的回调方法</td></tr></tbody></table><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>// BeanDefinitionParserDelegate 428</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">    <span class="comment">// 当然，如果不定义 name 属性的话，就是空的了</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                        beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                        !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们开始说说注册 Bean 吧。</p><h2 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h2><p>// BeanDefinitionReaderUtils 158</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">// 注册这个 Bean</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">            <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>// DefaultListableBeanFactory 976</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不支持重写，将会报错</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">              <span class="comment">// log </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               <span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">        <span class="comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">        <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line">            <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">            <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">            <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">            <span class="comment">//registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">            <span class="comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h2 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h2><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">        beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略实现下面接口的实现类</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationStartup.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “手动注册的类”</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理。</p><h2 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h2><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p><p>// AbstractApplicationContext.java 834</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">    <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 初始化 所有的非懒加载 beans</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                            getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理普通的 bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">    <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.beans.smart-initialize&quot;</span>)</span><br><span class="line">                .tag(<span class="string">&quot;beanName&quot;</span>, beanName);</span><br><span class="line">            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">            smartInitialize.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将会进入到 getBean(beanName); 方法里了。</p><h2 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个 beanName</span></span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经创建过了</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">// log...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是获取 bean,直接返回</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// 已经创建过相同的 bean ，说明陷入了循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否存在 BeanDefintion</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，检查 父容器</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 typeCheckOnly 为 false, 会被放入 alreadyCreated 集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">            .tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">            &#125;</span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">            <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">// 检查是否存在依赖循环</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 先注册依赖的 bean</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取到 bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 重要方法</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">// 执行创建</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查创建的类型</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是 createBean(beanName, mbd, args); 方法了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保 BeanDefintion 中的 class 已经被加载</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备方法重写</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 正式开始要创建 bean 了！！</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-bean"><a href="#创建-bean" class="headerlink" title="创建 bean"></a>创建 bean</h2><p>跨越千山万水，我们终于找到了 doCreateBean 这个方法。请持续保持 debug 状态，我们将继续深入方法内部。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 的包装类</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是 bean 包装类中的真正 实例bean</span></span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">// bean 的类型</span></span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要解决 循环依赖 问题，可以了解一下 三级缓存 机制</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 bean ，上面仅仅是 实例化，还没有对属性进行赋值等操作</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化 bean 后的回调函数，比如 init-method 方法的执行</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就看完了创建 bean 的部分，下面将会重点介绍一下 实例化bean 和 初始化bean 的部分。我们仅仅是稍微瞄一眼即可，再深层次的细节，本人能力有限也分析不动。</p><h2 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h2><p>这一步是将之前注册和保存的 beanDefintion 给实例化成对象的过程。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="comment">// 检查访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">    <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="comment">// 构造函数注入</span></span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无参构造函数</span></span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="comment">// 构造函数注入</span></span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挑个简单的无参构造函数构造实例来看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(</span><br><span class="line">                (PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>),</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化</span></span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 包装返回</span></span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的重点在于这一行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这是实例化的地方，我们进去看看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">        <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这一步走完，我们的bean就算完成了实例化。下面看看初始化的过程</p><h2 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h2><p>这一步会对 bean 的属性进行赋值，以及钩子函数(init-method)的执行等操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">            <span class="comment">// 如果没有实例化成功</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口 InstantiationAwareBeanPostProcessors 后，可以在这一步执行</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bean 实例的所有属性都在这</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">        <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过类型匹配</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">            <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值</span></span><br><span class="line">            PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                &#125;</span><br><span class="line">                pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line">        checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h2><p>属性注入完毕后，就开始执行各种回调函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">        <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring 在设计之初，就给我们留下了非常多的可扩展部分，比如 BeanFactoryPostProcessor 可以在注册 BeanDefintion 时，对 BeanDefintion 进行增强或者加入新的 Bean定于。以及 BeanPostProcessor 接口，可以在分别在实例化和初始化后进行执行相应的方法。<br>FactoryBean 在本文就不再继续讨论下去了，感兴趣的可以自行测试。<br>本文的不足之处在于限于个人能力，以及篇幅的限制，很多地方都没有深入展开的进行说明。这也算是给自己挖了个坑，后面有精力再补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring 中最重要的就是 IoC 和 AOP，我们平时使用 Spring 最多的就是 IoC，那么为啥不去深入了解一下其中的原理呢？本篇作为 Spring IoC 源码探究的文章之一，后续有机会的话将会更新 Spring MVC、MyBatis 等源码探究。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="Java" scheme="https://qybit.gitee.io/tags/Java/"/>
    
      <category term="IoC" scheme="https://qybit.gitee.io/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>第 234 场周赛</title>
    <link href="https://qybit.gitee.io/2021/04/03/259/"/>
    <id>https://qybit.gitee.io/2021/04/03/259/</id>
    <published>2021-04-03T02:56:21.000Z</published>
    <updated>2021-09-23T13:18:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li> <a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></li><li> <a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></li><li> <a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></li><li> <a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></li></ul><p>换电脑(原来的破电脑显示屏不亮了。)导致题解丢失，这是重写的一份。┭┮﹏┭┮</p><h1 id="T1：字符串中不同整数的数目"><a href="#T1：字符串中不同整数的数目" class="headerlink" title="T1：字符串中不同整数的数目"></a>T1：<a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接模拟截取数字部分即可，注意前导 $0$ 。</p><p>不可以转成数字 $int$ 或者 $long$ 等 64 位的整形数字，可能会爆掉。因此直接使用字符串即可。</p><p>$Go$ 语言中并不存在 $Set$ 集合，因此我们在使用 $Map$ 时，给 $Value$ 随便赋一个值即可。这里取得 $0x3f3f3f3f$ 意义为“无限大”。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isDigit</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDifferentIntegers</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    st := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> isDigit(word[i]) &#123;</span><br><span class="line">            <span class="keyword">var</span> num []<span class="keyword">byte</span></span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; word[i] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; isDigit(word[i]) &#123;</span><br><span class="line">                num = <span class="built_in">append</span>(num, word[i])</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            st[<span class="keyword">string</span>(num)] = INF</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(st)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。我们只会扫描一次字符串。</p><p>空间复杂度：$O(\sum)$ ，其中 $\sum$ 表示数字集的大小。</p><h1 id="T2：还原排列的最少操作步数"><a href="#T2：还原排列的最少操作步数" class="headerlink" title="T2：还原排列的最少操作步数"></a>T2：<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>纯模拟题</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reinitializePermutation</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    perm := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        perm[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> flag <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> flag &#123;</span><br><span class="line">        ans ++</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                arr[i] = perm[i / <span class="number">2</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i] = perm[n / <span class="number">2</span> + (i - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(arr) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            perm[i] = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(k \times N)$ ，其中 $k$ 为最小执行次数，$N$ 为数组的长度。</p><p>空间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p><h1 id="T3：替换字符串中的括号内容"><a href="#T3：替换字符串中的括号内容" class="headerlink" title="T3：替换字符串中的括号内容"></a>T3：<a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不存在嵌套的括号，因此我们可以直接遍历字符串当遇到一个 $()$ 时，截取 $()$ 内的内容，然后到 $knowledge$ 数组里找到对应的 $Value$ 即可。</p><p>直接在 $knowledge$ 里查找 $Value$ 的时间复杂度是 $O(N)$ 的，$N$ 为 $knowledge$ 数组的长度。因此，我们可以要尽可能的优化这一步的时间复杂度操作。</p><p>不难想到使用 哈希表 来实现 $O(1)$ 查找。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(s <span class="keyword">string</span>, knowledge [][]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, kn := <span class="keyword">range</span>(knowledge) &#123;</span><br><span class="line">        hash[kn[<span class="number">0</span>]] = kn[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> j <span class="keyword">int</span> = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j &lt; n &amp;&amp; s[j] != <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">                j ++</span><br><span class="line">            &#125;</span><br><span class="line">            k := s[i + <span class="number">1</span>:j]</span><br><span class="line">            <span class="keyword">if</span> key, ok := hash[k]; ok &#123;</span><br><span class="line">                ans += key</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="string">&quot;?&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += <span class="keyword">string</span>(s[i])</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。</p><p>空间复杂度：$O(N)$，其中 $N$ 为 $knowledge$ 数组的长度。</p><h1 id="T4：好因子的最大数目"><a href="#T4：好因子的最大数目" class="headerlink" title="T4：好因子的最大数目"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></h1><p>非常复杂的一道题，了解结论的话很容易做。</p><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>我们需要构造一个数 $x$ ，它的质因子数量最大不会超过 $primeFactors$ 个。</p><p>好因子：我们必须从这个数 $x$ 的 $n$ 个不同质因子 $a_i(1 \le i \le n)$，并假设其数量分别对应为 $b_i(1 \le i \le n)$。</p><p>举例子：比如当 $x = 200$，$primeFactors = 5$ 时，</p><p>存在一个满足的条件的质因子数组：$[2,2,2,5,5]$ ，其中质因子一共有两种，分别是 $a_1=2$ 和 $a_2=5$ ，它们的数量分别为 $b_1=3$ 和 $b_2=2$。</p><p>根据题目定义，我们在构造<strong>好因子</strong>的过程中，对于每一个质因子 $a_i$ 就必须选择 $b_i$ 个。</p><p>对于质因子 $a_1=2$ 而言，我们必须要拿 $1 \le b_1 \le 3$ 个，对于质因子 $a_2=5$ 也是同理 $1 \le b_2 \le 2$。 </p><p>我们开始构造<strong>好因子</strong>：</p><p>$b_1= 1, b_2=1$ 时，好因子数量：$[10]$</p><p>$b_1=2, b_2=1$ 时，好因子数量：$[10,20]$</p><p>$….$</p><p>注意到，当 $b_1 = 3$ 和 $b_2 = 2$ ，我们可以构造出 $b_1 \times b_2 =6$ 个好因子。分别为 $[10, 20,40,50,100,200]$ 。</p><h3 id="整理一下"><a href="#整理一下" class="headerlink" title="整理一下"></a>整理一下</h3><p>对于 $n$ 个质因子 $a_i$ 及其数量 $b_i$：<br>$$<br>a_1, \ a_2, \ a_3, \ a_4, \ …, \ a_n<br>$$<br>对于质因子的数量 $b_i$：<br>$$<br>b_1 + b_2 + b_3 + b_4 + … + b_n = primeFactors<br>$$</p><p>对于 $x$ ：<br>$$<br>a_1^{b_1} \times a_2^ {b_2} \times a_3^{b_3} \times…\times a_n^{b^n} = x<br>$$<br>对于最大的 <strong>好因子</strong> 数量：<br>$$<br>b_1 \times b_2 \times b_3 \times … \times b_n = ans<br>$$</p><p>我们可以得出一个结论：<strong>把一个数分出更多的质因子数量，使得它们数量的乘积尽可能的大，这样我们就可以构造出更多的好因子。</strong></p><p>此时，请思考一个问题？</p><blockquote><p>我们应该选择哪一个 质因子 才可以使一个数划分出更多份？</p></blockquote><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p><strong>函数极值证明法</strong></p><p>我们假设 $f(x)$ 为一个正整数 $n$ 按照 $x$ 划分时的最大乘积，则有 $x$ 项  $\frac{n}{x}$。即 $f(x) = x ^\frac{n}{x}$。</p><p>目标是求 $f(x)$ 的最大值，我们可以将式子变形一下：<br>$$<br>f(x) = x^\frac{n}{x} = e^{\frac{n \times lnx}{x}}<br>$$<br>令 $g(t) = e ^t$ ，$h(x) = \frac{lnx}{n}$ ，那么 $f(x) = g(n \times h(x))$，由于 $g(t)$ 是单调递增的，$n \gt 0$，所以 $f(x)$ 与 $h(x)$ 单调性相同。</p><p>我们计算 $h(x)$ 的驻点，$h’(x) = \frac{1 - lnx}{x^2} = 0$，得到 $x = e$ 。</p><p>得到驻点 $x = e$，当 $0 \lt x \lt e$ 时， $h’(x) \gt 0$ ，所以在 $0 \lt x \lt e$ 时，$h(x)$ 是单调递增的。</p><p>当 $x \gt e$ 时，$h’(x) \lt 0$ ，所以在 $x \gt e$ 时，$h(x)$是单调递减的。由此可知 $x = e$ 为 $h(x)$ 和 $f(x)$ 的极大值点。由于 $f(x)$ 在定义域连续，因此 $x =e $ 为 $f(x)$ 的最大值点。</p><p>那么， $e = 2.71…$ 并不是一个正整数，因此我们还需要比较 $f(2)$ 和 $f(3)$ 的大小，直接计算 $f(2) / f(3)$ 的值即可。<br>$$<br>\frac{f(2)}{f(3)} = \frac{e^{\frac{nln2}{2}}}{e^{\frac{nln3}{3}}} = e ^ {\frac{nln2}{2} - \frac{nln3}{3}} = e ^ \frac{n \times ln8-ln9}{6}<br>$$<br>由于 $ln8 \lt ln9$，$n &gt; 0$ ，所以 $f(2) \lt f(3)$ 。因此当 $x = 3$ 时，$f(x)$ 可以取得最大值。</p><p>上述过程为正整数 $n$ 可以整除 $3$ 时，当不够整除时，我们还需要用 $2$ 来凑。</p><p>因此，我们对于 $n$ 和 $3$ 的余数进行讨论：</p><ul><li>当余数为0时，即$n = 3m (m \ge 2)$，将 $n$ 拆分成 $m$ 个 $3$</li><li>当余数为1时，即$n = 3m+1 (m \ge 1)$ ，由于$2\times2 \gt 3 \times 1$，所以将 $n$ 拆分成 $m - 1$ 个 $3$ 和 $2$ 个 $2$</li><li>当余数为2时，即$n=3m+2(m \ge 1)$，将 $n$ 拆分成 $m$ 个 $3$ 和 $1$ 个 $2$</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>上述证明，我们以及得知当一个正整数 $x$ 按照 $3$ 拆分，然后补充 $2$ 时，可以使得其数量的乘积最大。也就是可以构造更多的好因子数量。</p><p>那么，对于本题已经给出了质因子的数量，我们反向冲一下，就可以求出最大值 $x$ ，也就是本题的答案。</p><p>注意由于 $n$ 的范围相当的大，因此在快速幂的过程中需要边取模边运算，否则会爆数据范围。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_pow</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> y &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ret *= x</span><br><span class="line">            ret %= MOD</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x</span><br><span class="line">        x %= MOD</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % MOD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxNiceDivisors</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m, quot <span class="keyword">int</span> = n / <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> quot == <span class="number">0</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> quot == <span class="number">1</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m) * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(lgN)$，其中 $N$ 最大为 $10^9$ 。</p><p>空间复杂度：$O(1)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/&quot;&gt;字符串中不同整数的数目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a hre
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="哈希表" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="数组" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="https://qybit.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动技术支持实习面经</title>
    <link href="https://qybit.gitee.io/2021/04/01/1024/"/>
    <id>https://qybit.gitee.io/2021/04/01/1024/</id>
    <published>2021-04-01T07:18:59.000Z</published>
    <updated>2021-09-23T13:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔试：-3-7"><a href="#笔试：-3-7" class="headerlink" title="笔试： 3.7"></a>笔试： 3.7</h2><p><strong>T1</strong>：给定一个数组，对于数组中的每一个元素为，打印出数组中下一个更大的数，如果没有下一个更大的数，则打印-1。<br><strong>思路</strong>：单调栈。由于数据范围很小，所以暴力即可。</p><p><strong>T2</strong>：N 个小朋友围成一圈，你可以调整任意两个小朋友的位置。使得相邻小朋友的最大身高差的值最小。<br><strong>思路</strong>：单调栈</p><p><strong>T3</strong>：你现在是一名图书管理员，你可以处理两种指令。<br>指令格式如下：</p><ol><li><p><code>1 x y</code> 表示可以将图书x和图书y放在同一个书架上。</p></li><li><p><code>2 x y</code> 表示图书x和图书y不能放在同一个书架。</p></li></ol><p>现存在一个用户，向你提供了 $N$ 条指令。并询问这些指令的执行情况。<br>输出格式：</p><ol><li>如果所有指令，都可以正常执行，输出 YES</li><li>如果不能全部执行，且不能执行的 2 号指令，恰好为 3 条，请输出 3</li><li>请输出不能执行的指令数量</li></ol><p><strong>思路</strong>：并查集模板题，如果用数组模拟的话，数据范围很大 $10^9$ 直接就报错了。我认为改用 $unorderd_map$ 后理论上和数组是一致的，但是实际操作时忘记初始化了(我是SB)。</p><p><strong>T4</strong>：变态版 <a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a> (可以查看<a href="https://qybit.gitee.io/2021/03/20/72/">我的题解</a>)。</p><p>本题是给定不定长的字符串，要求从任意一个节点出发，经过若干次操作后可以变化的最大步长。<br><strong>思路</strong>：BFS（求最大步长），DP（DP效率似乎不怎么好，我在牛客上看的反馈还没我BFS过的多）</p><h2 id="一面-3-23-60mins"><a href="#一面-3-23-60mins" class="headerlink" title="一面 3.23 60mins"></a>一面 3.23 60mins</h2><ol><li>自我介绍</li><li>用过哪些集合？</li><li>说说 ArrayList、HashSet 和 HashMap 的常用方法。</li><li>你刚刚说ArrayList的底层是数组，那么我们为什么不使用数组？</li><li>说说ArrayList的扩容机制？具体是如何扩容的？</li><li>ArrayList 和 HashSet 的区别？</li><li>你用 HashSet 都存放过哪些数据类型？你是如何写这个自定义对象的？</li><li>为什么要重写 hashcode 和 equals 方法？</li><li>我看你用的是 MySQL，MySQL 和 Redis的区别？，说说 MySQL 的存储引擎吧？它们有什么区别？</li><li>你知道事务吗？说说事务的四大特性？</li><li>说说事务的隔离级别？</li><li>你都用过哪些数据类型？char 和 varchar 的区别是什么？</li><li>Redis有哪些数据类型？</li><li>说说 Spring 的事务。</li><li>你使用 MyBatis 是怎么写 SQL 语句的？</li><li>你写的 mapper 文件里都用过哪些标签，是怎么写的？</li><li>定义的 mapper 接口中的方法是如何执行的？</li><li>做题：<ol><li>统计数字的出现次数；</li><li>反转链表</li></ol></li><li>说说 static 和 final 关键字</li><li>JAVA虚拟机的内存模型是怎样的？（不是JAVA程序的运行内存模型）</li><li>类是如何加载的？</li><li>说说栈内存和堆内存，什么是栈帧？</li><li>假如遇到深层次的递归函数，会发生什么事情？你是如何解决的？</li><li>你遇到过 OOM 吗？你是如何解决的？</li><li>反问环节</li></ol><h2 id="二面：3-26-25mins"><a href="#二面：3-26-25mins" class="headerlink" title="二面：3.26 25mins"></a>二面：3.26 25mins</h2><ol><li>  自我介绍</li><li>介绍岗位工作职责</li><li>介绍项目</li><li>描述项目细节</li><li>MVC 软件架构了解吗？</li><li>反馈说上一面表现不错</li><li>做题：<ol><li>给定一个按钮，点击修改其内容</li><li>使用调试工具，比如 Postman 调用 API</li><li>手撕快速排序</li><li>反转字符串，空间 $O(1)$</li></ol></li><li>  如果一个网页，打开很慢的话，说说可能的原因？</li><li>  get 和 post 请求的区别。</li><li>  说说 http 和 https 的区别。</li><li>  说说三次握手和四次挥手。</li><li>  写一个 sql 语句吧，查询表中 100 个 id 大于 10 的记录。</li><li>  今天的面试就到这里了，你已经通过了，等 HR 电话吧。</li><li>  反问环节</li></ol><h2 id="HR面：3-30-20mins"><a href="#HR面：3-30-20mins" class="headerlink" title="HR面：3.30 20mins"></a>HR面：3.30 20mins</h2><ol><li>   HR自我介绍（我以为是技术面）</li><li>询问成绩</li><li>介绍项目</li><li>你为什么选择前端专业？</li><li>我看你是前端专业，为什么要选择后端？</li><li>关于在留心科技实验室当前端组长的一些问题</li><li>你为什么选择上海和杭州这两个城市？</li><li>你从出生到现在感受到最为挫折的一次经历？</li><li>   你未来的规划是怎么样的？</li><li>   你为什么选择字节跳动？你有投递其它公司吗？</li><li>   什么时候可以来实习？你能实习多久？</li><li>   同学和老师对你的评价中最多的关键词</li><li>   反问环节</li></ol><h2 id="已-OC：4-1"><a href="#已-OC：4-1" class="headerlink" title="已 OC：4.1"></a>已 OC：4.1</h2><p>最后是催着 HR 小姐姐给发的offer。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;笔试：-3-7&quot;&gt;&lt;a href=&quot;#笔试：-3-7&quot; class=&quot;headerlink&quot; title=&quot;笔试： 3.7&quot;&gt;&lt;/a&gt;笔试： 3.7&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;T1&lt;/strong&gt;：给定一个数组，对于数组中的每一个元素为，打印出数组中下一个更
      
    
    </summary>
    
    
      <category term="技术交流" scheme="https://qybit.gitee.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="字节跳动" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>第 48 场双周赛</title>
    <link href="https://qybit.gitee.io/2021/03/21/259/"/>
    <id>https://qybit.gitee.io/2021/03/21/259/</id>
    <published>2021-03-21T02:58:00.000Z</published>
    <updated>2021-09-23T13:18:44.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目清单：</p><ul><li><a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></li><li> <a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></li><li> <a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></li><li> <a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/"> N 次操作后的最大分数和</a></li></ul><h1 id="T1：字符串中第二大的数字"><a href="#T1：字符串中第二大的数字" class="headerlink" title="T1：字符串中第二大的数字"></a>T1：<a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></h1><p>注意到，这里给出的混合字符串中的数字，仅仅是指 $0-9$ 之间的数字。</p><p>方法一：我们使用有序的 $set$ 集合，插入后取倒数第二个元素即可。</p><p>$Java$ 中使用 $TreeSet$ 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                st.insert(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = st.end();</span><br><span class="line">        it --, it --;</span><br><span class="line">        <span class="keyword">return</span> *(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。</p><p>空间复杂度：$O(1)$，其中 $set$ 集合，使用的空间最大仅为 $10$ 个元素。</p><h1 id="T2：设计一个验证系统"><a href="#T2：设计一个验证系统" class="headerlink" title="T2：设计一个验证系统"></a>T2：<a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目描述非常的长。实际上，我们只需要关注如下信息即可。</p><ul><li>$tokenId$ 具有唯一性，且数据级别是 $N$ ，那么我们的查找时间复杂度就尽可能的要满足 $O(1)$，不难想到哈希表</li><li>$token$ 的存活时间为 $currentTime + timeToLive$，我们在进行查询存活数量时，只需要检查当前时间是否小于存活时间即可</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// int[] life = &#123;live -&gt; dead&#125;</span></span><br><span class="line">    <span class="keyword">int</span> liveTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthenticationManager</span><span class="params">(<span class="keyword">int</span> timeToLive)</span> </span>&#123;</span><br><span class="line">        liveTime = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        map.put(tokenId, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;currentTime, currentTime + liveTime&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(tokenId)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] life = map.get(tokenId);</span><br><span class="line">        <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">            <span class="comment">// 还没死</span></span><br><span class="line">            life[<span class="number">0</span>] = currentTime;</span><br><span class="line">            life[<span class="number">1</span>] = currentTime + liveTime;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(tokenId, life);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, <span class="keyword">int</span>[]&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] life = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为 $Map$ 中所有 $tokenId$ 的数量</p><ul><li><code>AuthenticationManager#generate</code> 操作时间复杂度为 $O(1)$</li><li><code>AuthenticationManager#renew</code> 操作时间复杂度为 $O(1)$</li><li><code>AuthenticationManager#countUnexpiredTokens</code> 操作时间复杂度为 $O(N)$，我们需要遍历 $Map$ 集合。</li></ul><p>空间复杂度：$O(N)$</p><h1 id="T3：你能构造出连续值的最大数目"><a href="#T3：你能构造出连续值的最大数目" class="headerlink" title="T3：你能构造出连续值的最大数目"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></h1><h2 id="方法一：数学推导"><a href="#方法一：数学推导" class="headerlink" title="方法一：数学推导"></a>方法一：数学推导</h2><p>我们对数组进行排序，使得我们选择下一个元素时，尽可能的接近。</p><p>子问题：</p><p>假如连续整数为 $[0, 0]$ ，那么下一个元素必须满足为 $coins[0] \le 1$ ，才能保证整数连续。</p><p>归纳：</p><ul><li>对于连续整数 $[0, 1]$，那么 $coins[1] \le 2$ 使得整数为 $[0, 1 + coins[1]]$才能保证整数连续。</li><li>对于连续整数 $[0, x]$，那么 $coins[i] \le x + 1$ 使得整数为 $[0, x + coins[i]]$ 才能保证整数连续。</li></ul><p>证明：</p><p>假设前 $i$ 个元素已经构成连续整数 $[0, n]$ ，且下一个数为 $m$ 时：</p><p>若 $m &gt; n + 1$ 时，此时可以构成的整数分别为 $[0, n]$ ， $[m, m + n + 1]$ 。存在 $m \gt n + 1 \gt n$。则整数不连续。</p><p>因此要想整数连续递增，必须保证 $m \le n + 1$，使得整数连续为 $[0, n + m + 1]$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        sort(coins.begin(), coins.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + <span class="number">1</span> &lt; coin) <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">            now += coin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlogN)$，其中 $N$ 为数组长度。</p><p>空间复杂度：$O(logN)$</p><h1 id="T4：N-次操作后的最大分数和"><a href="#T4：N-次操作后的最大分数和" class="headerlink" title="T4：N 次操作后的最大分数和"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/">N 次操作后的最大分数和</a></h1><h2 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h2><p>首先看看题目是如何定义第 $i$ 次操作（$i$ 从 <strong>1</strong> 开始）：</p><ul><li>选择两个元素 $x$ 和 $y$</li><li>获得分数 $i \times gcd(x, y)$</li><li>删除 $x$ 和 $y$</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>我们也不必再关注 $nums$ 数组本身，因为我们的分数计算实际上是 $ i \times gcd(x,y)$，即与 $x$ 和 $y$ 的<strong>最大公约数和操作次数</strong>有关的。因此，我们可以<strong>预处理</strong> $nums$ 数组所有下标 $i$ 和 $j$ 的组合对应的最大公约数。</p><p>我们需要选择任意两个元素，也就是任意两个未使用过的下标，直到用完所有的操作次数。</p><p>那么，我们就可以尝试所有可能的起点，并使用一个 $path$ 数组记录我们选择元素对应的最大公约数。</p><p>当我们的操作数全部用完时，对选择的最大公约数进行排序处理（因为并没有限制操作的顺序），使得 <strong>较大的操作次数 * 较大的最大公约数</strong> 来获得最大的分数。</p><h3 id="具体实现如下："><a href="#具体实现如下：" class="headerlink" title="具体实现如下："></a>具体实现如下：</h3><p>对于任意一次操作 $i$ ，我们有：</p><ul><li>选择一个从未使用过的下标作为元素 $x$，对应下标为 $s$</li><li>再选择一个从未使用过的下标作为元素 $y$，对应下标为 $u$</li><li>我们将其对应的最大公约数 $g[s][u]$ 加入到 $path$ 数组</li><li>当我们的操作次数使用完毕时，此时 $path$ 数组中已经存在 $n / 2$ 个元素，我们获得分数的理念是 <strong>较大的操作次数 * 较大的最大公约数</strong> 。因此对 $path$ 进行备份，然后排序计算此轮获得的最大分数并更新<strong>历史最大值</strong>。</li><li>我们再回溯到选择元素 $y$ 的场景。此时我们将不再选择元素 $y$ ，将下标 $u$ 标记为未使用。如果没有元素可供选择时。</li><li>我们再次回溯到选择元素 $x$ 的场景。与选择元素 $y$ 同理。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1e9</span>; <span class="comment">// 历史最大值</span></span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">20</span>]; <span class="comment">// 标记数组</span></span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">// 预处理 最大公约数</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">// 数组长度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q, path; <span class="comment">// q 为 nums 备份，path 为选择路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = path;</span><br><span class="line">            sort(t.begin(), t.end());</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &gt;&gt; <span class="number">1</span>; i ++) &#123;</span><br><span class="line">                res += (i + <span class="number">1</span>) * t[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                s = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        used[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[u]) &#123;</span><br><span class="line">                used[u] = <span class="literal">true</span>;</span><br><span class="line">                path.push_back(g[s][u]);</span><br><span class="line">                dfs(cnt + <span class="number">1</span>);</span><br><span class="line">                used[u] = <span class="literal">false</span>;</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        used[s] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        n = nums.size();</span><br><span class="line">        q = nums;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                g[i][j] = g[j][i] = gcd(nums[i], nums[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q.begin(), q.end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N^2 + N!)$，其中 $N$ 为数组的长度。</p><ul><li>我们需要预处理 $nums$ 数组</li><li>回溯的时间复杂度大致是这个级别，推测出来的量级</li></ul><p>空间复杂度：$O(N^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/second-largest-digit-in-a-string/&quot;&gt;字符串中第二大的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="周赛" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="哈希表" scheme="https://qybit.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="回溯" scheme="https://qybit.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="字符串" scheme="https://qybit.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="https://qybit.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="设计" scheme="https://qybit.gitee.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="动态规划" scheme="https://qybit.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="递归" scheme="https://qybit.gitee.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>72. 编辑距离</title>
    <link href="https://qybit.gitee.io/2021/03/20/72/"/>
    <id>https://qybit.gitee.io/2021/03/20/72/</id>
    <published>2021-03-20T05:09:15.000Z</published>
    <updated>2021-09-23T13:18:43.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>我们要求 $word1$ 变成 $word2$ 的最少操作次数。</p><p>操作如下：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>基本指导思想，对于 $word1$ 中所有的下标，我们尝试所有可能的操作，期望可以达到 $word2$ 。但是这样的时间复杂度将会达到 指数级。因此是不可能通过本题的。但我们也可以使用记忆化的方式优化。</p><h2 id="方法一：DFS-剪枝"><a href="#方法一：DFS-剪枝" class="headerlink" title="方法一：DFS + 剪枝"></a>方法一：DFS + 剪枝</h2><p>使用两个指针分别为 $i$ 和 $j$ ，分别指向 $word1$ 和 $word2$ ，我们借助指针的移动来对 $word1$ 模拟上述的 $3$ 种操作。</p><p>这里我们可以假设 $word1[0, i-1]$ 的字符 和 $word2[0, j-1]$ 已经完全相等了，此时我们的指针分别指向 $word1$ 的第 $i$ 个字符 和 $word2$  和 第 $j$ 个字符。 对于下述的操作，我们始终是在 <strong>操作</strong> $word1$ 。</p><p>具体实现如下：</p><ul><li>当 $word1[i] = word2[j]$ 时，我们同时移动指针 $i$ 和 $j$ 向右一位。</li><li>当 $word1[i] \neq word2[j]$ 时：<ul><li>当我们选择 【删除】时，我们移动指针 $i$ 向右一位。这里实际上对于 $word1$ 而言是 【跳过】 当前字符，让 $word1$ 的下一个字符和 $word2$ 的第 $j$ 个字符得以匹配相等，而在 $word2$ 看来，我们好像是多了一个字符。因此对于 $word2$ 而言，$word2$ 是多了一个字符。</li><li>当我们选择 【插入】时，我们移动指针 $j$ 向右一位。实际上对于 $word2$ 而言是 【跳过】当前字符，让 $word2$ 的下一个字符和 $word1$ 的第 $i$ 个字符得以匹配相等。对于 $word2$ 同理，在 $j$ 的位置进行 $word2$  的 【删除】操作。</li><li>当我们选择 【替换】时，实际上是和 $word1[i] = word2[j]$ 情况一致的。我们把指针 $i$ 和 $j$ 同时向右移动一位。</li></ul></li><li>在指针 $i$ 和 $j$ 没有把 $word1$ 或者 $word2$ 扫描完毕之前，我们重复上述操作。</li><li>当任意一个指针到达字符串末尾时，即说明我们存在一个方案使得 $word1 = word2$，。因为对于任意一个 $i (0 \le i \le word1.length, j同理)$ ，我们都存在最多可以有 $3$ 种选择分支。因此，我们需要在 【删除】、【插入】和【替换】三种操作取最小值。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>由上述搜索的思路，我们可以发现。虽然我们可能的操作一共是 $6$ 种。但是对于 $word1$ 的【删除】操作，等效于对 $word2$ 进行【插入】操作。所以我们的最终操作方案实际上是 $3$ 种。</p><ul><li>$word1$ 的【插入】操作，等效于 $word2$ 的【删除】操作</li><li>$word1$ 的【删除】操作，等效于 $word2$ 的【插入】操作</li><li>$word1$ 的【替换】操作，等效于 $word2$ 的【替换】操作。</li></ul><p>公式化描述：</p><p>前提条件是，$word1[0, i-1]$ 和 $word2[0, j-1]$ 已经完全相等了。$f(i, j)$ 表示 $word1$ 的前 $i (0 \le i \le word1.length)$ 个字符转变成 $word2$ 前 $j(0 \le j \le word2.length)$ 个字符所需的最小操作次数。那么存在<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>PS：不相等时，加 $1$ 是因为我们选择了任意一个操作。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> word1, <span class="keyword">int</span> i, <span class="built_in">string</span> word2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= word1.size() || j &gt;= word2.size()) &#123;</span><br><span class="line">            mem[i][j] = word1.size() - i + word2.size() - j;</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">            mem[i][j] = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> increased = dfs(word1, i, word2, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> deleted = dfs(word1, i + <span class="number">1</span>, word2, j);</span><br><span class="line">        <span class="keyword">int</span> modify = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">        mem[i][j] = min(increased, min(deleted, modify)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">        <span class="keyword">return</span> dfs(word1, <span class="number">0</span>, word2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(3^{max{n, m}})$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p><ul><li>但是由于我们存在缓存数组，因此时间复杂度是远远小于这个级别的。具体的时间复杂度我也没有办法分析。</li></ul><p>空间复杂度：$O(n \times m)$，我们要缓存字符串所有可能状态的最小操作数。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>由上一步，我们通过 【自顶向下】的一顿分析，递推出来的式子。进行改造<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>我们需要注意的点，就是边界问题，也就是当 $i=0$ 或者 $j = 0$ 时，当任意一个字符串为空串时，我们的改变次数等于不为空的字符串的长度。</p><p>我们的动态规划转移公式仍然定义为： $f[i][j]$，表示 $word1[0,i]$ 与 $word2[0,j]$ 完全相等的最小操作次数。 </p><p>因此，动态规划的转移方程为：</p><ul><li>当 $word1[i] = word2[j]$ ，$f[i][j] = f[i-1][j-1]$，相等时，不需要任何操作。</li><li>当 $word1[i] \ne word2[j]$，$f[i][j] = min{f[i-1][j], f[i-1][j-1], f[i][j-1]} + 1$，我们从三种操作中，选择最小的一种进行一次操作。</li></ul><p>解释：</p><ul><li>$f[i-1][j]$ 表示将 $word1[0, i -1]$ 的第 $i$ 个字符【删除】后，使得 $word1[0,i] = word2[0, j]$</li><li>$f[i-1][j-1]$ 表示将 $word1[0,i-1]$ 的第 $i$ 个字符进行【修改】后，使得 $word1[0,i] = word2[0,j]$</li><li>$f[i][j-1]$ 表示在 $word1[0,i]$ 【插入】一个字符后，使得 $word1[0, i] = word2[0,j]$</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.size(), m = word2.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) </span><br><span class="line">            f[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) </span><br><span class="line">            f[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j], min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n \times m)$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p><p>空间复杂度：$O(n \times m)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;我们要求 $word1$ 变成 $word2$ 的最少操作次数。&lt;/p&gt;
&lt;p&gt;操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://qybit.gitee.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="DP" scheme="https://qybit.gitee.io/tags/DP/"/>
    
      <category term="DFS" scheme="https://qybit.gitee.io/tags/DFS/"/>
    
  </entry>
  
</feed>
