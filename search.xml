<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.两数之和</title>
    <url>/2021/02/18/1/</url>
    <content><![CDATA[<p>当年我的劝退题目~，第一次做力扣被这道题卡到劝退。半天憋不出来一个可以 <code>AC</code> 的代码。</p>
<p>今天有必要给它写个题解，来纪念一下。</p>
<p>本文，将会分别从不同的时间复杂度来解决问题，如下 $O(N^2)$、$O(NlogN)$、$O(N)$ 的解决思路。</p>
<a id="more"></a>

<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>我们需要在一个数组中，找到两个不同的下标使得下标对应的元素和等于 $targert$。</p>
<p>假设存在两个下标 $i$ 和 $j$ （$i \ne j$），使得 $nums[i] + nums[j] = target (i \ne j)$，其中 $nums$ 表示为数组。</p>
<h1 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h1><p>思路如下：</p>
<ul>
<li>第一层循环，我们固定一个下标 $i$。</li>
<li>第二层循环，我们在下标 $i$ 固定的前提下，再寻找一个下标 $j$，使得 $nums[i] + nums[j] = target (i \ne j)$。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) </span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N^2)$，其中 $N$ 为数组的长度。对于数组中的每个元素，我们在最坏的情况下需要访问 $N$ 次。</p>
<p>空间复杂度：$O(1)$</p>
<h1 id="方法二：排序-双指针"><a href="#方法二：排序-双指针" class="headerlink" title="方法二：排序 + 双指针"></a>方法二：排序 + 双指针</h1><p>我们先将数组排序后，再使用双指针分别从数组 <strong>头部</strong> 和 <strong>尾部</strong> 夹逼寻找符合条件的两个元素。</p>
<p>由于排序后会打乱其原本的信息，因此我们必须要重新存储一下数组的元素，并维护其原本的位置。这一步我们可以使用结构体或者类来实现。</p>
<p>那么为什么可以使用双指针呢？证明如下：</p>
<ul>
<li>对于数组中的两个指针 $left(left \ge 0)$ 和 $right(right \le n - 1)$，其中 $n$ 为数组长度。存在如下情况：<ul>
<li>​    $q[left] + q[right] \gt target$，那么此时指针 $right$ 必不可能是向右移动的，因为对于 $q[right] \le q[right + 1] (right \le n -2)$ 一定成立。为了使得 $left$ 和 $right$ 所指元素 <strong>等于</strong> $target$  ，$right$ 只能单调向左移动。</li>
<li>$q[left] + q[right] \lt target$，对于 $left$ 指针而言也是同理。对于 $q[left - 1] \le q[left](left &gt; 0)$ 一定成立。为了使得 $left$ 和 $right$ 所指元素 <strong>等于</strong> $target$。$left$ 只能单调向右移动。</li>
<li>$q[left] + q[right] = target$ ，那么皆大欢喜，我们找到两个符合条件的下标。返回 $left$ 和 $right$ 所指元素的原本下标位置即可。</li>
</ul>
</li>
<li>只有满足了指针移动的单调性，我们才可以使用双指针来解决此类问题。</li>
</ul>
<p>类似题目推荐：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/container-with-most-water/">力扣 11.盛最多水的容器</a></li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ele</span> &#123;</span></span><br><span class="line">    <span class="comment">// a 表示数组元素， k 表示该元素在原数组的位置</span></span><br><span class="line">    <span class="keyword">int</span> a, k;</span><br><span class="line">    <span class="comment">// 重载操作符，方便排序 </span></span><br><span class="line">    <span class="comment">// 按照数组元素大小升序排列</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Ele &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; t.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            q[i] = &#123;nums[i], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q, q + n);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = q[left].a + q[right].a;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;q[left].k, q[right].k&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(NlogN)$，其中 $N$ 为数组的长度。</p>
<ul>
<li>我们第一次遍历数组，备份各元素原本下标的位置。时间复杂度$O(N)$。</li>
<li>我们对<strong>新数组</strong>元素进行排序操作，此处的时间复杂度为 $O(NlogN)$。</li>
<li>我们还要双指针遍历<strong>新数组</strong>，来寻找符合条件的两个下标，并返回<strong>原本</strong>的下标位置。时间复杂度$O(N)$。</li>
<li>我们对于所有数组中的任意一个元素，在最坏的情况下都不会访问到达 $N$ 次。因此时间复杂度为 $O(NlogN)$。</li>
</ul>
<p>空间复杂度：$O(N)$，我们需要备份原来的数组的信息。</p>
<h1 id="方法三：哈希表-这个方法应该是最优解"><a href="#方法三：哈希表-这个方法应该是最优解" class="headerlink" title="方法三：哈希表 (这个方法应该是最优解)"></a>方法三：哈希表 (这个方法应该是最优解)</h1><p>假设存在两个下标 $i$ 和 $j$ $(i \ne j)$，满足 $a = nums[i], b = nums[j]$，那么此时 $a + b = target$。</p>
<p>对于数组中的元素，我们固定一个下标并假设其为 $i$ ，如下图</p>
<p><img src="https://img.imgdb.cn/item/602e232d99aa8726f2955d70.jpg"></p>
<p>那么我们的最终目标其实是，询问 $b (nums[j])$ 是否存在于区间 $[0, i - 1]$ 中，并且这个操作必须是 $O(1)$ 时间复杂度的。</p>
<p>因此我们不难想到用 <strong>哈希表</strong> 来优化。考虑到本题中，存在负数，因此不可以使用数组来充当哈希表，我们只能使用 <code>Map</code> 结构来实现。</p>
<p>类似题目推荐：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/">961. 重复 N 次的元素</a></li>
<li> <a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></li>
<li> <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (f.find(x) != f.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, f[x]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            f[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为数组长度。我们至多只会遍历一遍数组。</p>
<p>空间复杂度：$O(N)$，其中 $N$ 为数组长度。我们需要使用 <strong>哈希表</strong> 维护数组元素和下标。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 正则表达式匹配</title>
    <url>/2021/03/11/259/</url>
    <content><![CDATA[<h1 id="方法一：递归-双指针"><a href="#方法一：递归-双指针" class="headerlink" title="方法一：递归 + 双指针"></a>方法一：递归 + 双指针</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于只存在 <code>.</code> 的字符，我们很容易去判断字符串 $p$ 是否可以匹配 $s$。</p>
<p>对于 <code>*</code> 字符，我们必须结合前一个字符来判断是否可以完成匹配。</p>
<p>具体实现：</p>
<ul>
<li>使用两个指针 $i$  和 $j$，分别指向字符串 $s$ 和 字符串 $p$。当字符串 $p$ 匹配完毕时，若指针 $i$ 未能走完整个字符串 $s$ ，那么表示当前路径不能成功匹配字符串 $s$ 。</li>
<li>对于特殊字符  <code>.</code>  和 <code>*</code> 而言，我们必须分情况讨论：<ul>
<li>对于单个字符而言，当 $s[i] = p[j]$ 时，或者 $p[j] = ‘.’$  时，此时我们是可以正常匹配的，我们还需要存储当前的结果，因为我们下一个字符可能是 <code>*</code></li>
<li>如果下一个字符为 <code>*</code> 时，我们必须要联系字符串 $s$ 的前一个字符，因此我们这里有两种选择方式：<ul>
<li>我们可以使用 <code>*</code>  ，将指针 $i$ 移动到下一位，去匹配下一个<strong>相同的</strong>字符。</li>
<li>还有就是跳过这个 <code>*</code> ，我们将指针 $j$ 移动两位，跳过 <code>*</code>。选择不匹配</li>
</ul>
</li>
<li>如果当前指针 $j$ 的下一个字符并不是 <code>*</code> 时，我们可以尝试去同时移动指针 $i$ 和 指针 $j$，当指针 $j$ 走完时，即停止递归。</li>
</ul>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>PS：时空复杂度实际上我并不会分析，只知道这个递归的时间复杂度非常之大。<strong>C++</strong> 是直接超时的。<strong>Java</strong> 在力扣由于没有记录 <strong>JVM</strong> 的启动时间，所以是可以骗过的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) </span><br><span class="line">            <span class="keyword">return</span> i == s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> first = i &lt; s.length() &amp;&amp; (p.charAt(j) == <span class="string">&#x27;.&#x27;</span> || s.charAt(i) == p.charAt(j));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j)) || dfs(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O((n + m) \times 2 ^ {n + m})$，其中 $n$ 和 $m$ 分别为字符串 $s$ 和 字符串 $m$ 的长度。</p>
<ul>
<li>我们至少需要遍历完字符串 $s$ 和 字符串 $p$ 。</li>
<li>对于存在 <code>*</code> 的情况下，我们存在两个递归路径，而每一个递归路径都必须等待指针 $j$  或者指针 $i$ 扫描完毕才可以退出。</li>
</ul>
<p>空间复杂度：$O(1)$，我们使用双指针递归操作，并没有使用额外的存储空间。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>添加备忘录似乎可以减轻时间上的复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        <span class="keyword">if</span> (j == p.size()) <span class="keyword">return</span> i == s.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> first = i &lt; s.size() &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.size() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            mem[i][j] = (first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j)) || dfs(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        mem[i][j] = first &amp;&amp; dfs(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>C++</strong> 也能通过。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>1128 等价多米诺骨牌对的数量</title>
    <url>/2021/01/26/cku5fjrrz000790v440q4fjtk/</url>
    <content><![CDATA[<p>一道比较有意思的题目，足够简单但是时间复杂度卡得很紧。</p>
<p>原题链接：<a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/">等价多米诺骨牌对的数量</a></p>
<a id="more"></a>

<p><strong>开头</strong></p>
<p>形式上，$dominoes[i] = [a, b]$ 和 $dominoes[j] = [c,d]$ ，等价的前提是 $a==b$ 且 $c == d$ ，或者是 $a == d$ 且 $b==c$ 。</p>
<p>原题是存在两个情况去判断是否等价，那么我们可以直接预处理一下，如果 $a &lt; b$ ，那么 $swap(a, b)$ 。交换$a,b$ ，使得判断条件只有一种情况 $a==b$ 且 $c == d$ 。</p>
<p><strong>思路</strong></p>
<p>我们直接无脑暴力循环一下，在 $0 \le i \lt j \lt dominoes.length$ 的前提条件下，这个做法是正确的。</p>
<p>但是由于数据量很大的原因，$1 \le dominoes.length \le 4 * 10^4$。$O(N^2)$ 的时间复杂度会超时。</p>
<p>所以，我们的时间复杂度必须是 $O(NlogN)$ 及以下的才行。</p>
<p>假设我们找到了 $N$ 个数对 $[a_i, b_i]$，且这些数对都是满足 $a_i == b_i$，在满足前提条件下（$i \lt j$），我们可以任意的挑出两个符合题意的数对。因为它们的下标在原数组中一定是不相同的。由于 $i \lt j$，所以一个数对可以提供一个答案，那么上述 $N$ 个数对$[a_i,b_i]$可以推出 $C_n^2$ 个答案。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEquivDominoPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : dominoes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">0</span>] &gt; x[<span class="number">1</span>]) swap(x[<span class="number">0</span>], x[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : dominoes) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = to_string(x[<span class="number">0</span>]) + to_string(x[<span class="number">1</span>]);</span><br><span class="line">            hash[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : hash) &#123;</span><br><span class="line">            res += v * (v<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码实际上是可以继续优化的。因为我们还忽略了一个条件，<code>1 &lt;= dominoes[i] &lt;= 9</code></p>
<p>所以，<code>hash</code> 可以不必使用字符串，而是使用 <code>int</code> 来替代。那么我们又可以注意到，当 $[a, b]$ 作为 <code>key</code> 时，实际大小是不会超过 <code>100</code> 的并且，<code>map</code> 的 <code>key</code> 在计算过程并没有用处。因此，我们可以不使用 <code>unordered_map</code> ，而直接使用数组来作为 <code>hash表</code>。那么数组索引作为 <code>key</code>, 数组值统计次数。</p>
<p><strong>最终优化代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEquivDominoPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : dominoes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">0</span>] &gt; x[<span class="number">1</span>]) swap(x[<span class="number">0</span>], x[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(hash, <span class="number">0</span>, <span class="keyword">sizeof</span> hash);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : dominoes) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = x[<span class="number">0</span>] * <span class="number">10</span> + x[<span class="number">1</span>];</span><br><span class="line">            hash[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;v : hash) &#123;</span><br><span class="line">            res += v * (v<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为 $dominoes$ 的长度</p>
<p>空间复杂度：$O(1)$，我们只使用了常数级的空间</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>1208 尽可能使字符串相等</title>
    <url>/2021/02/05/cku5fjrs0000990v4fofo1ube/</url>
    <content><![CDATA[<p>力扣链接：<a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">尽可能使字符串相等</a></p>
<p>昨晚睡前没仔细读题，以为挺难做的，没想到也不难做。</p>
<a id="more"></a>

<h1 id="1、方法一：双指针"><a href="#1、方法一：双指针" class="headerlink" title="1、方法一：双指针"></a>1、方法一：双指针</h1><h3 id="1、开头"><a href="#1、开头" class="headerlink" title="1、开头"></a>1、开头</h3><p>首先确定，字符串<code>s</code> 和 <code>t</code> 的长度是相同，而且不存在 <code>SB</code> 的用例。数据范围是 $10^5$ 级别。那么，我们的算法时间复杂度上限为 $O(NlogN)$ ，至少 $N^2$ 是没法过的。</p>
<p>题目说的 <strong>开销(cost)</strong> 是指：<code>s</code>中的第<code>i</code>个字符转变为<code>t</code>中第<code>i</code>个字符，即<code>s[i]</code> 转变为 <code>t[i]</code> 时，<code>|s[i] - t[i]|</code>  两个字符 <strong>ASCII</strong> 的差的绝对值。这里的隐含信息就是，<strong>我们的开销中都是非负正整数</strong>。</p>
<p>在不超过预算 <code>maxCost</code> 下，可以转变的最大字符串长度。这里面的隐含信息就是，<strong>我们转变连续的字符串一定是连续的</strong>。</p>
<h3 id="2、编码思路"><a href="#2、编码思路" class="headerlink" title="2、编码思路"></a>2、编码思路</h3><p>上述分析，在$cost \le maxCost$ 的前提下（其中 $cost$ 为转变的开销），我们要转变一段连续最大长度的字符串。</p>
<p>我们可以使用双指针来维护一个区间，$left$ 和 $right$ 分别表示子数组的左端点和右端点，这个子数组的元素转变开销满足 $\sum_{left}^{right}|s[i] - t[i]| \le maxCost$  ，那么区间长度就是 $right - left + 1$ 。</p>
<p>我们要根据这个子数组内的开销总和，来决定如何移动指针。</p>
<p>为了得到最大长度的子数组，我们在移动过程中应该遵循以下原则：</p>
<ul>
<li>当左端点 $left$ 的值固定时，右端点 $right$ 的值尽可能的大；</li>
<li>当右端点 $right$ 的值固定时，左端点 $left$ 的值要尽可能的小。</li>
</ul>
<h3 id="3、代码思路"><a href="#3、代码思路" class="headerlink" title="3、代码思路"></a>3、代码思路</h3><p>基于上述原则，双指针的具体做法如下：</p>
<ul>
<li>使用一个变量 $cost$ 记录子数组内的开销总和，$cost += abs(s[i]-t[i])$</li>
<li>如果 $cost \le maxCost$ ，当前子数组的长度为 $right-left+1$，我们更新为最大子数组长度</li>
<li>如果 $cost \gt maxCost$， 此时不满足条件，需要移动左端点的指针 $left$ ，并更新 $cost$ 的值，直到 $cost \le maxCost$ ，此时子数组的长度为 $right-left+1$， 我们更新为最大子数组长度</li>
<li>移动右端点指针 $right$， 重复上述操作，直至遍历整个字符串。</li>
</ul>
<p>遍历结束后，就可以得到最大子数组的长度。即字符串可以转变的最大长度。</p>
<h3 id="4、代码"><a href="#4、代码" class="headerlink" title="4、代码"></a>4、代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            cost += <span class="built_in">abs</span>(s[right] - t[right]);</span><br><span class="line">            <span class="keyword">while</span> (cost &gt; maxCost) &#123;</span><br><span class="line">                cost -= <span class="built_in">abs</span>(s[left] - t[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为数组长度。数组中的任意一个元素，我们访问最多都不会超过 $N$ 次。</p>
<p>空间复杂度：$O(1)$，我们只使用了常数级的空间。</p>
<h1 id="2、方法二：前缀和-二分"><a href="#2、方法二：前缀和-二分" class="headerlink" title="2、方法二：前缀和+二分"></a>2、方法二：前缀和+二分</h1><h2 id="1、开头-1"><a href="#1、开头-1" class="headerlink" title="1、开头"></a>1、开头</h2><p>这个思路就比较难想到，脑洞大开。</p>
<p>设 $diff[i] = abs(s[i] - t[i])$ 表示第 <code>i</code> 个位置 <code>s[i]</code> 转变为 <code>t[i]</code> 的开销。</p>
<p>当 $1\le i \le n$，定义数组 $accDiff[i]$ 为字符串前 $i$ 个的开销总和，即<br>$$<br>diff[i] = \sum_{j=0}^{i-1}|diff[j]|<br>$$<br>我们借助 <strong>两数之和</strong> 的思想，当有一个下标 $j$ 固定时，我们希望找到一个更小的下标 $k (k \le j)$ ，使得 $diff$ 从下标 $k$ 到 $j$ 的元素和不超过 $maxCost$  ，此时子数组的长度为 $j-k+1$，我们已经计算出了 $diff$ 的前缀和数组 $accDiff$ ，因为可以推导出 $diff$ 从下标 $k$ 到 $j$ 的前缀和：<br>$$<br>\begin {align}<br>&amp;\sum_{i=k}^j diff[k] \\<br>=&amp; \sum_{i=0}^jdiff[i] - \sum_{i=0}^{k-1}diff[i] \\<br>=&amp; accDiff[j + 1] - accDiff[k]<br>\end {align}<br>$$<br>因为找 $diff$ 从下标 $k$ 到 $j$ 的前缀和，不超过 $maxCost$ ，就等价于 $accDiff[j + 1] - accDiff[k] \le maxCost$。</p>
<h3 id="2、编码思路-1"><a href="#2、编码思路-1" class="headerlink" title="2、编码思路"></a>2、编码思路</h3><p>由上述推到，我们可以得出对于一个固定下标 $j$ ，我们希望可以找到一个下标 $k(k \le j)$，使得 $accDiff[j+1] - accDiff[k] \le maxCost$。</p>
<p>对于下标$j$， 我们要在前缀和数组$accDiff$中寻找这样一个下标$k$，满足 $accDiff[k] \ge maxCost - accDiff[j+1]$。由于 $accDiff$ 前缀和数组是单调递增的，因此我们可以直接在 $accDiff$ 内进行二分查找，来找到最小的一个下标 $k$。</p>
<h3 id="3、代码思路-1"><a href="#3、代码思路-1" class="headerlink" title="3、代码思路"></a>3、代码思路</h3><p>遍历整个数组，对于每一个下标 $i$ ，我们都将其作为子数组的右端点，然后希望能找到最小的一个 $k$， 那么此时的子数组长度为 $i - k$。</p>
<p>我们查找的条件为 $accDiff[k] \ge accDiff[i] - maxCost$，每找到一个符合条件的下标 $k$，我们更新子数组的最大长度。换句话说，我们要在 $accDiff$ 中找到第一个大于等于 $x = accDiff[i] - maxCost$ 的下标。</p>
<h3 id="4、代码-1"><a href="#4、代码-1" class="headerlink" title="4、代码"></a>4、代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">accDiff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            accDiff[i] = accDiff[i<span class="number">-1</span>] + <span class="built_in">abs</span>(s[i<span class="number">-1</span>] - t[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = accDiff[i] - maxCost;</span><br><span class="line">            <span class="keyword">int</span> k = binary_search(accDiff, x);</span><br><span class="line">            res = max(res, i - k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(NlogN)$ ，其中 $N$ 为数组的长度，计算前缀和数组时间复杂度$O(N)$，遍历数组再做 $N$ 次二分查找，每一次二分查找时间复杂度为 $O(logN)$，所以最终时间复杂度 $O(NlogN)$。</p>
<p>空间复杂度：$O(N)$，其中$N$为前缀和数组的长度。我们需要存储前缀和数组的值。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>127 单词接龙</title>
    <url>/2021/02/06/cku5fjrs1000b90v49qsoadeq/</url>
    <content><![CDATA[<p>力扣链接：<a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙</a></p>
<p>这是一道求最短路径的题目，BFS 是我们用来解决最短路问题的强心剂。</p>
<a id="more"></a>

<h1 id="方法一：BFS"><a href="#方法一：BFS" class="headerlink" title="方法一：BFS"></a>方法一：BFS</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>拿这个例子来举例如何建图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：beginWord = <span class="string">&quot;hit&quot;</span>, endWord = <span class="string">&quot;cog&quot;</span>, wordList = [<span class="string">&quot;hot&quot;</span>,<span class="string">&quot;dot&quot;</span>,<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;lot&quot;</span>,<span class="string">&quot;log&quot;</span>,<span class="string">&quot;cog&quot;</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一个最短转换序列是 <span class="string">&quot;hit&quot;</span> -&gt; <span class="string">&quot;hot&quot;</span> -&gt; <span class="string">&quot;dot&quot;</span> -&gt; <span class="string">&quot;dog&quot;</span> -&gt; <span class="string">&quot;cog&quot;</span>, 返回它的长度 <span class="number">5</span>。</span><br></pre></td></tr></table></figure>
<p>上述用例所示的图如下，构建的图是一个无向（无权）图。特意画成一颗”树“的形状。</p>
<p><img src="https://img.imgdb.cn/item/601e63323ffa7d37b36de88f.jpg"></p>
<p>我们需要找到 从 <code>hit</code> 出发到 <code>cog</code> 的最短路径</p>
<h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们不必从一开始就要把这个图全部构建完毕，如果一开始建图完毕再去遍历的话，时间开销会非常的大。这样建图的具体做法为：枚举一个字符串，然后和剩余所有的字符串进行比较，如果相差为一个字符的话，那么我们就可以创建一条边，时间复杂度为 $O(N \times C)$，其中 $N$ 为字符串的数量，$C$ 为字符串的长度。我们不推荐这么做。</p>
<p>我们的做法是，一边遍历一边建图。我们每一次转换只能改变一个字母，对于一个字符串我们枚举出所有可能的改变情况那么这个时间复杂度为 $O(26 \times C)$，其中$C$ 为字符串的长度。如 <code>hit</code> 举例，我们枚举出 <code>*it</code> 、<code>h*t</code> 和 <code>hi*</code> 的所有可能情况。尽可能的枚举出在单词表中出现过的字符串，然后延伸到下一个点。</p>
<h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ul>
<li>当 $endWord$ 不在 $wordList$ 时，我们不必进行下一步，此时不存在转换序列，直接返回 $0$；</li>
<li>我们还需要一个 $vis$ 哈希表，来记录我们走过的节点，防止死循环。</li>
<li>在图的遍历中，保险起见最好都增加一个 $vis$ 哈希表来记录走过的节点，这点空间开销代价不算太大。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!wordSet.count(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        vis.insert(beginWord);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line">            step ++;</span><br><span class="line">            <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i ++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c = p[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k ++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (c == k) <span class="keyword">continue</span>;</span><br><span class="line">                        p[i] = k;</span><br><span class="line">                        <span class="keyword">if</span> (p == endWord) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!vis.count(p)) &#123;</span><br><span class="line">                            vis.insert(p);</span><br><span class="line">                            <span class="keyword">if</span> (wordSet.count(p)) &#123;</span><br><span class="line">                                q.push(p);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p[i] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N \times C^2)$，其中 $N$ 为 $wordList$ 的长度，$C$ 为列表中单词的长度（列表中单词长度相同）。</p>
<ul>
<li>建图过程中，我们从一个字符串枚举出另一个在字典序存在的字符串，此过程时间复杂度为 $O(C)$（常数很小可忽略），还要将这些节点都加入到哈希表中记录 $O(N \times C)$，总时间复杂度为 $O(N \times C)$.</li>
<li>广度优先搜索的最坏情况是 $O(N \times C)$。我们对于每个节点都需要枚举出个 $O(C)$ 个新节点，因此时间复杂度为 $O(N \times C)$。</li>
</ul>
<p>空间复杂度：$O(N \times C^2)$，其中 $N$ 为 $wordList$ 的长度，$C$ 为列表中单词的长度。哈希表中包含 $O(N \times C)$ 个节点，每个节点包含 $O(C)$ 个空间，因此空间复杂度为 $O(N \times C^2)$。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>1540 K次操作转变字符串</title>
    <url>/2021/02/02/cku5fjrs3000f90v4cs954ff6/</url>
    <content><![CDATA[<p>原题链接：<a href="https://leetcode-cn.com/problems/can-convert-string-in-k-moves/">K 次操作转变字符串</a></p>
<p>我人傻了，A了这题就立马回小学重修语文。</p>
<a id="more"></a>

<h2 id="方法一：统计操作次数"><a href="#方法一：统计操作次数" class="headerlink" title="方法一：统计操作次数"></a>方法一：统计操作次数</h2><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>我们第 <code>i</code> 次操作，必须切换 <code>i</code> 次。</p>
<p>拿一组数据举例， <code>s = aab, t =bbb, k = 27</code></p>
<p>第一次操作时：针对 <code>s[0]</code> 和 <code>t[0]</code> ， <code>a -&gt; b</code> 这是一次操作。此次操作后，对于 <code>s[1]</code> 和 <code>t[1]</code>  而言，由于操作次数是 <code>1</code> ，所以我们必须等待 <code>26</code> 次，在第 <code>27</code> 次操作时，才能切换 <code>a -&gt; b</code>。</p>
<p>我们总共的一共操作<code>27</code> 次，所以我们需要返回 <code>true</code></p>
<h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><p>我们切换字母时，只会改变原字符串的字母，并不会改变长度，因此当字符串长度不相同时，我们直接返回  $false$。</p>
<p>对于每一个字符下标来说，当它们不相同时，我们才会有切换操作。那么对于任意一个字符它的<strong>最小切换次数</strong>最多为 $25$。因此，我们可以统计所有字符要转换需要最小切换次数。</p>
<p>由于我们只能选择字符串中未被选过的任意一个下标，那么如果存在两个下标的最小切换次数相同，对于其中一个我们切换了 $i$ 次，那么另一个就需要等待 $ i + 26$ 次才能进行切换。如果存在多个下标的最小切换次数相同，那么每一个下标都需要等待前一个下标切换后 $26$ 次才能进行切换。</p>
<p>假设存在 $n$ 个下标相同的最小切换次数 $x$，其中 $1 \le x \le 25$ ，那么我们需要 $x + 26 * (n - 1)$ 次操作才能将 $n$ 个下标的字符都切换。如果 $x + 26*(n-1) \gt k$ ，那么我们无法在 $k$ 次操作转变所有字符，因此返回$false$ ，反之则为 $true$</p>
<h3 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h3><p>由于一个字符的<strong>最小切换次数</strong>最大为 $25$，因此我们可以使用一个长度为 $26$ 的数组来作为哈希表。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConvertString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() != t.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = s[i] - t[i];</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) diff += <span class="number">26</span>;</span><br><span class="line">            count[diff] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> need = i + <span class="number">26</span> * (count[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (need &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为字符串 $s$ 和 $t$ 的长度。我们至多需要遍历一次字符串</p>
<p>空间复杂度：$O(|\sum|)$，其中$\sum$ 为字符集的存储空间。我们需要记录所有不同字符的切换次数。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>131. 分割回文串</title>
    <url>/2021/03/07/259/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="方法一：回溯-剪枝优化"><a href="#方法一：回溯-剪枝优化" class="headerlink" title="方法一：回溯 + 剪枝优化"></a>方法一：回溯 + 剪枝优化</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于本题，我们要找出字符串 $s$ 中，所有可能的回文子串，因此我们需要搜索与回溯遍历所有可能的字串。</p>
<p>对于字符串中某个下标 $i$ ，我们可以假设其 $[0,i]$ 的部分，已经全部是回文子串并且加入答案数组 $res$ 中。那么，对于区间 $<a href="n%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6">i,n</a>$，我们可以枚举出所有可能的长度 $len (1 \le len \le n-i+1)$，并使用双指针检查是否为回文子串。</p>
<p>如果为回文子串，我们把该字串加入到答案数组，然后我们下一次搜索时就可以跳过这一个回文字串，从下标 $i + len$ 开始重复上述过程，直到 $i \ge n$ 为止。当以该字串为回文串的路径，搜索完毕后，我们再删除该字串，然后再重新以另一个可能存在的回文串重复上述过程。</p>
<p>直到，没有存在可能的回文串才会结束我们的算法。即我们从头扫到尾，都未发现回文串时。</p>
<h3 id="剪枝的体现："><a href="#剪枝的体现：" class="headerlink" title="剪枝的体现："></a>剪枝的体现：</h3><ul>
<li>当我们对于任意一个下标 $i$ 进行枚举时，我们会枚举出所有可能的切割长度所产生的字串，但是我们只会选择属于回文子串的路径进行搜索。而不是回文子串的路径，则会被抛弃。</li>
</ul>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>对于回溯的题目，我们脑海中需要有一颗递归树。请以 <strong>自行脑部/画出递归树</strong> 的方式来理解本题的解法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[n - <span class="number">1</span> - i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path, <span class="keyword">int</span> idx, <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - idx + <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">string</span> sub = s.substr(idx, i);</span><br><span class="line">            <span class="keyword">if</span> (check(sub)) &#123;</span><br><span class="line">                path.push_back(sub);</span><br><span class="line">                dfs(res, path, idx + i, s);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        dfs(res, path, <span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N \times 2^N)$，其中 $N$ 是字符串 $s$ 的长度。</p>
<ul>
<li><p>我们需要利用双指针检查是否为回文子串，时间复杂度为 $O(N)$。</p>
</li>
<li><p>在最坏的情况下，字符串 $s$ 是由 $N$ 个相同的字符所组成的。那么我们要面临的划分方案为 $2^{N-1} = O(2^N)$ 。而对于任意一个划分的字串，我们都必须要利用双指针检查是否为回文子串。所以时间复杂度为 $O(N \times 2^N)$。</p>
</li>
</ul>
<p>空间复杂度：$O(N \times 2^N)$，我们需要存储所有可能的回文子串。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>1625 执行操作后字典序最小的字符串</title>
    <url>/2021/02/06/cku5fjrs6000m90v4dasz2act/</url>
    <content><![CDATA[<p>广度优先搜索（BFS）的优势在于当问题存在最优解的情况下，一定可以找到最优解。因此常用于最短路问题。</p>
<p>这道题数据比较弱，所以暴力搜索也不会超时。</p>
<p>力扣链接：<a href="https://leetcode-cn.com/problems/lexicographically-smallest-string-after-applying-operations/">执行操作后字典序最小的字符串</a></p>
<p>相似题目推荐：</p>
<ol>
<li> <a href="https://leetcode-cn.com/problems/word-ladder/">力扣 127. 单词接龙</a></li>
<li><a href="https://www.acwing.com/problem/content/1103/">AcWing 1101.献给阿尔吉侬的花束</a></li>
<li> <a href="https://leetcode-cn.com/problems/word-transformer-lcci/">力扣 面试题 17.22. 单词转换</a></li>
</ol>
<a id="more"></a>

<h1 id="方法一：BFS爆搜"><a href="#方法一：BFS爆搜" class="headerlink" title="方法一：BFS爆搜"></a>方法一：BFS爆搜</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>我们将任意一个字符串都看成图中的一个点，不同点之间的边由 <strong>累加</strong> 和 <strong>轮转</strong>  两个操作产生。</p>
<p>在图中任意一个点可以有如下的操作：</p>
<ul>
<li>累加：给字符串下标为奇数的元素都加上 <code>a</code> ，如果超过 <code>9</code> 则归 <code>0</code></li>
<li>轮转：将字符串向右旋转 <code>b</code> 位</li>
</ul>
<p>首先要知道：</p>
<ol>
<li>任何一个数经过10次以内的累加操作，一定会循环；</li>
<li>原始字符串经过N次轮转之后，一定会循环。</li>
</ol>
<p>所以图中点的数量是有限可以确定的，而且数据比较弱，完全可以爆搜。</p>
<h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>无</p>
<h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>给出我个人最习惯写的一个 $BFS$ 模板</p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (q.size())</span><br><span class="line">&#123;</span><br><span class="line">   	<span class="comment">// 搜索树的层数 depth，也可以表示为搜索路径的步数</span></span><br><span class="line">    depth ++;</span><br><span class="line">    <span class="keyword">int</span> sz = q.size();</span><br><span class="line">    <span class="keyword">while</span> (sz--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    depth ++;</span><br><span class="line">    <span class="keyword">int</span> sz = q.size();</span><br><span class="line">    <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用一个变量记录下，字典序最小的一个字符串。</p>
<p>或者使用有序的 $set$ 集合，然后返回 $set$ 集合的第一个元素。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLexSmallestString</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(s);</span><br><span class="line">        vis.insert(s);</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line">            <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">string</span> t = p;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">                    t[i] = (t[i] - <span class="string">&#x27;0&#x27;</span> + a) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!vis.count(t)) &#123;</span><br><span class="line">                    q.push(t);</span><br><span class="line">                    vis.insert(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> n = p.size();</span><br><span class="line">                t = p.substr(n - b) + p.substr(<span class="number">0</span>, n - b);</span><br><span class="line">                <span class="keyword">if</span> (!vis.count(t)) &#123;</span><br><span class="line">                    q.push(t);</span><br><span class="line">                    vis.insert(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *vis.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>（存疑，仅供参考）</p>
<p>时间复杂度：$O(N * 2^{depth})$ ，其中$N$ 为字符串的长度， $depth$ 为第二层循环的次数，最差的情况下，我们的搜索树到最后一层才能找到字典序最小的那个字符串。所以我们的 $depth$ 是不确定的，但是我们开头说了两个操作是存在循环的，因此不会存在一个字符串经过操作后可以无限的产生新的点，再加上数据范围很弱，所以理想上是可以通过本题。</p>
<p>空间复杂度：$O(N * 2^{depth})$，我们要存储这颗完全二叉树的所有字符串信息。</p>
<ul>
<li>我们爆搜枚举出来搜索树的是一颗完全二叉树。</li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>376 摆动序列</title>
    <url>/2020/12/12/cku5fjrs7000p90v47yplcfrw/</url>
    <content><![CDATA[<p><strong>开头</strong></p>
<p><strong>摆动序列：</strong></p>
<ul>
<li><code>[1,7,4,9,2,5]</code> 是一个摆动序列，指不会出现连续的上升或者下降的序列，对于元素 7，可以称之为 [峰] ，因为它的前后元素都是<strong>严格小于</strong>自身。对于元素 4 ，可以称之为 [谷] ， 因为它的前后元素都是<strong>严格大于</strong>自身</li>
<li><code>[1,4,7,2,5]</code> 不是摆动序列，因为 <code>[1,4,7]</code> 子序列是连续递增的。</li>
<li><code>[1,7,4,5,5]</code> 不是摆动序列，因为 <code>[4,5,5]</code> 子序列也是连续递增的。 </li>
<li>如果数组中只存在一个元素，那么这个元素它即是 [谷] ，也是 [峰]。</li>
<li>注意，我们需要在数组中找出最长的这样的一个子序列，而非要求连续的数组</li>
</ul>
<a id="more"></a>

<p><strong>方法一：</strong>动态规划</p>
<p>对于选择的元素，要么是正在上升要么是正在下降的，这取决于前一个元素。我们可以分别记录以 [峰] 结尾和 [谷] 结尾的最长摆动子序列。</p>
<ul>
<li>$up[i]$ 为数组前 $i$ 个元素里，以某一元素结尾为 [峰] 的最长的摆动子序列。</li>
<li>$down[i]$ 为数组前 $i$ 个元素里，以某一元素结尾为 [谷] 最长的摆动子序列。</li>
</ul>
<p>对于$up[i]$ 时的任意一个元素有</p>
<ul>
<li>$nums[i] \le nums[i-1]$ ，我们无法选取任何元素，因为对于 $nums[i-1]$ 和 $nums[i]$ 都是合法的，即 $up[i] = up[i-1]$ 。</li>
<li>$nums[i] \gt nums[i-1]$ ，我们可以从 $up[i-1]$ 转移，也可以从 $down[i-1]$ 转移。此时仅需要考虑，哪一方可以提供更长的摆动序列即可。</li>
</ul>
<p>对于 $down[i]$ 同理。</p>
<p>最终答案在 $up[n-1]$ 和 $down[n-1]$ 之间取最大值，n 为序列的长度。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 峰</span></span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">                up[i] = Math.max(up[i-<span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 谷</span></span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = Math.max(down[i-<span class="number">1</span>], up[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度</p>
<p>空间复杂度：$O(N)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>410 分割数组的最大值</title>
    <url>/2021/02/02/cku5fjrs8000t90v40cgs0uh9/</url>
    <content><![CDATA[<p>力扣410链接：<a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a></p>
<a id="more"></a>

<h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>我们需要对一个非负整数数组进行划分操作，将其划分为 <code>m</code> 个非空的<strong>连续子数组</strong>。</p>
<p>使得 <code>m</code> 个子数组各自和的最大值最小</p>
<h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><p>由于我们无法确定数组的 $m$ 个 “割点” 位置在哪里，但是我们可以确定 $m$ 个连续子数组的和。</p>
<p>子数组的和范围不难可以确定为 $[max\{nums[i]\}, \sum_0^nnums[i]]$</p>
<p>设 $left = max\{nums[i]\}$， $right = \sum_i^nnums[i]$，每一次枚举一个 $x$ ，使得 $x = \frac{left +right}{2}$</p>
<p>再统计我们枚举的出 $x$ 可以将数组划分成多少个区间。使得每个区间和，尽可能的接近 $x$ 。</p>
<ul>
<li>如果划分的区间多于 $m$ 个，那么我们枚举的 $x$ 太小了，因此需要放大区间。 $left = x + 1$</li>
<li>如果划分的区间小于等于 $m$ 个，那么我们枚举的 $x$ 是大于等于最优解的，因此需要缩小区间。$right = x$</li>
</ul>
<h3 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h3><p>注意我们划分的区间至多也会有一个，此时是整个数组，不需要划分。因此统计时的边界 $cnt = 1$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 检查数组是否可以划分成最多m个和为x的区间 </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; x) &#123;</span><br><span class="line">                sum = num;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : nums) &#123;</span><br><span class="line">            right += x;</span><br><span class="line">            left = max(left, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, m)) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度分析：$O(N * log(sum-maxn) )$，其中 $N$ 为数组的长度， $sum$ 为数组的总和，$maxn$ 为数组的最大值。我们每枚举一个 $mid$ ，就需要遍历一次数组，时间复杂度为 $O(N)$，我们需要遍历 $log(sum-maxn)$ 次数组，因此时间复杂度为 $O(N * log(sum-maxn))$</p>
<p>空间复杂度：$O(1)$，我们只使用了常数空间。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>460 LFU缓存</title>
    <url>/2020/12/14/cku5fjrs9000x90v4b17nh1zx/</url>
    <content><![CDATA[<p><strong>开头</strong></p>
<p>采用自定义的双向链表来实现</p>
<p>Node：存储每一个 key, value, freq </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> freq = <span class="number">1</span>;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node next;</span><br><span class="line">    DoublyLinkedList linkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>DoublyLinkedList：存储所有 freq 相同频率的节点对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    DoublyLinkedList pre;</span><br><span class="line">    DoublyLinkedList next;</span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoublyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoublyLinkedList</span><span class="params">(<span class="keyword">int</span> freq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.freq = freq;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.linkedList = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是算法实现的结构图：</p>
<p><img src="https://pic.downk.cc/item/5fd6d30e3ffa7d37b33e19f4.png"></p>
<p><strong>算法思路</strong></p>
<ul>
<li><p>初始化的时候，将 freq 链表的虚拟头尾节点全部初始化。</p>
</li>
<li><p>get 操作时，如果 HashMap 缓存中不存在 key 时，将返回 -1。如果存在，那么更新频率 freq ，此时需要考虑</p>
<ul>
<li>如果未更新前 freq 链表移除这个 Node 节点后，链表为空，此时需要删除原链表。</li>
<li>如果更新后的 freq 没有对应的链表，此时需要创建新的 freq 链表，然后添加。</li>
</ul>
</li>
<li><p>put 操作时，先检查容量。再检查缓存中是否存在值，如果存在那么说明 freq 链表是一定存在的，所以直接更新频率即可。</p>
<ul>
<li>如果缓存中不存在值，那么有两种可能，如果缓存的容量满了，那么需要删除最后一个节点，如图中红色标识的节点，然后再添加进入 freq = 1 的链表</li>
<li>如果还可以加入节点的话，先检查是否存在 freq = 1的链表，如果不存在先创建 freq=1 的链表，然后加入节点。存在 freq = 1 的链表，就直接加入。</li>
</ul>
<p>  以上就是整个 LFU-缓存 算法的详细思路。</p>
<p>  <strong>代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qybit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-12-14 9:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Node&gt; cache;</span><br><span class="line">    DoublyLinkedList firstLinkedList;</span><br><span class="line">    DoublyLinkedList lastLinkedList;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        firstLinkedList = <span class="keyword">new</span> DoublyLinkedList();</span><br><span class="line">        lastLinkedList = <span class="keyword">new</span> DoublyLinkedList();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        firstLinkedList.next = lastLinkedList;</span><br><span class="line">        lastLinkedList.pre = firstLinkedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问频率 +1</span></span><br><span class="line">        freInc(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">// 频率 +1</span></span><br><span class="line">            freInc(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若 key 不存在</span></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果容量满了，此时需要移除最小访问频率的那个key</span></span><br><span class="line">                cache.remove(lastLinkedList.pre.tail.pre.key);</span><br><span class="line">                lastLinkedList.removeNode(lastLinkedList.pre.tail.pre);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="comment">// 如果为空了，此时需要删除链表</span></span><br><span class="line">                <span class="keyword">if</span> (lastLinkedList.pre.head.next == lastLinkedList.pre.tail) &#123;</span><br><span class="line">                    removeDoublyLinkedList(lastLinkedList.pre);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新节点，如果没有 freq == 1的链表则添加，</span></span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (lastLinkedList.pre.freq != <span class="number">1</span>) &#123;</span><br><span class="line">                DoublyLinkedList doublyLinkedList = <span class="keyword">new</span> DoublyLinkedList(<span class="number">1</span>);</span><br><span class="line">                addDoublyLinkedList(doublyLinkedList, lastLinkedList.pre);</span><br><span class="line">                doublyLinkedList.addNode(newNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastLinkedList.pre.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDoublyLinkedList</span><span class="params">(DoublyLinkedList doublyLinkedList, DoublyLinkedList preLinkedList)</span> </span>&#123;</span><br><span class="line">        doublyLinkedList.next = preLinkedList.next;</span><br><span class="line">        doublyLinkedList.next.pre = doublyLinkedList;</span><br><span class="line">        doublyLinkedList.pre = preLinkedList;</span><br><span class="line">        preLinkedList.next = doublyLinkedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeDoublyLinkedList</span><span class="params">(DoublyLinkedList doublyLinkedList)</span> </span>&#123;</span><br><span class="line">        doublyLinkedList.pre.next = doublyLinkedList.next;</span><br><span class="line">        doublyLinkedList.next.pre = doublyLinkedList.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">freInc</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从原链表中 移除 node ，然后放入前一个节点，如果移除后，链表为空则删除，如果前一个链表不存在则创建新链表</span></span><br><span class="line">        DoublyLinkedList doublyLinkedList = node.linkedList;</span><br><span class="line">        DoublyLinkedList preDoublyLinkedList = doublyLinkedList.pre;</span><br><span class="line">        doublyLinkedList.removeNode(node);</span><br><span class="line">        <span class="keyword">if</span> (doublyLinkedList.head.next == doublyLinkedList.tail) &#123;</span><br><span class="line">            removeDoublyLinkedList(doublyLinkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        node.freq++;</span><br><span class="line">        <span class="keyword">if</span> (preDoublyLinkedList.freq != node.freq) &#123;</span><br><span class="line">            DoublyLinkedList linkedList = <span class="keyword">new</span> DoublyLinkedList(node.freq);</span><br><span class="line">            addDoublyLinkedList(linkedList, preDoublyLinkedList);</span><br><span class="line">            linkedList.addNode(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preDoublyLinkedList.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> freq = <span class="number">1</span>;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node next;</span><br><span class="line">    DoublyLinkedList linkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    DoublyLinkedList pre;</span><br><span class="line">    DoublyLinkedList next;</span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoublyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoublyLinkedList</span><span class="params">(<span class="keyword">int</span> freq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.freq = freq;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.linkedList = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LFU</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>424 替换后的最长重复字符</title>
    <url>/2021/02/02/cku5fjrsa001090v42trn8000/</url>
    <content><![CDATA[<p>力扣424链接：<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">替换后的最长重复字符</a></p>
<a id="more"></a>

<h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><p>我们枚举每一个字符作为区间右端点，然后找到相同字符对应的最远左端点，统计左右端点区间内存在的不同于当前字符的数量。那么此时的区间，就是一个符合答案的区间。</p>
<p><img src="https://img.imgdb.cn/item/6018c0d33ffa7d37b340a782.jpg"></p>
<p>我们继续尝试扩大区间，右端点移动一格。当不满足条件时（即区间内非当前字符的数量大于K），我们将左端点至多移动一格。移动过程中，右端点是不断右移，左端点只有不满足条件时移动。</p>
<h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a><strong>代码思路</strong></h3><p>由于仅包含大写字母，所以我们可以使用一个长度26的数组来统计字符的出现次数</p>
<p>使用一个变量记录下，历史的最大区间长度</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s[right];</span><br><span class="line">            hash[c1 - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            mx = max(mx, hash[c1 - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (right - left - mx + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = s[left];</span><br><span class="line">                hash[c2 - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            res = max(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为字符串 <code>s</code> 的长度。我们至多会遍历一次字符串</p>
<p>空间复杂度：$O(|\sum|)$ ，其中 $\sum$ 为各个字符出现次数的总和。我们要统计所有大写字符的数量</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>480 滑动窗口中位数</title>
    <url>/2021/02/03/cku5fjrsb001490v4b7ve086v/</url>
    <content><![CDATA[<p><em>官方题解十分的鬼畜，但是这道题用二分也是可以做的</em></p>
<p>力扣链接： <a href="https://leetcode-cn.com/problems/sliding-window-median/">滑动窗口中位数</a></p>
<p>相似题目推荐：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></li>
</ul>
<a id="more"></a>

<h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>给定数组，给定一个 <code>k</code> ，有一个长度为 <code>k</code> 的窗口会从最左端滑动到最右端。求出每个窗口的中位数。</p>
<h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><p>由于我们需要求每个区间的中位数，那么我们就必须要动态的维护每个窗口的单调性。由于窗口是滑动的，所以我们每一次在删除一个元素和添加一个元素时，都不能破坏其单调性。</p>
<p>对于<strong>删除</strong>和<strong>插入</strong>元素时，仍可以保持区间单调性，我们不难想到这些数据结构：优先队列、平衡二叉树等。</p>
<p>上述数据结构可能对于一些语言实现上存在一定的困难，尤其是平衡二叉树的实现。</p>
<p>那么，我们还有方法也可以做到<strong>删除</strong>和<strong>插入</strong>时保证其单调性，但是会牺牲更多的时间代价。即删除和插入时，对原本已经单调的数组进行二分查找来尽可能的降低时间消耗。</p>
<h3 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h3><p>本题解决方法将会选择 $Java$ 中使用数组实现的 $ArrayList$ 动态数组来实现动态维护区间。</p>
<p>$ArrayList$ 将会使用到如下的两个方法。代码均节选自 <code>jdk1.8</code> 源代码</p>
<h4 id="1、add"><a href="#1、add" class="headerlink" title="1、add"></a>1、add</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对选定下标的 $add$ 方法，其时间复杂度是 $O(N)$ 的，即自 $[index, N]$ 都会复制后移一位。</p>
<h4 id="2、remove"><a href="#2、remove" class="headerlink" title="2、remove"></a>2、remove</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于删除的下标，其时间时间复杂度也是 $O(N)$ 的，自 $[index, N]$ 都会向前移动一位。</p>
<p>有了上述两个操作，我们就可以手动的维护区间了。</p>
<h3 id="代码思路-1"><a href="#代码思路-1" class="headerlink" title="代码思路"></a>代码思路</h3><p>对于第一个窗口，我们需要优先加入$k$ 个元素后，然后开始滑动窗口动态维护这个 $k$ 个元素。</p>
<ol>
<li>维护大小为 $k$ 的 $ArrayList$</li>
<li>删除操作时，我们需要二分查找到窗口最左端的元素，这里 $Arrays$ 提供的方法，但是我们也可以手写一个</li>
<li>插入操作时，为了保证插入后区间仍然是单调性，我们需要找到第一个大于等于待插入元素</li>
<li>计算中位数，考虑 $k$ 的奇偶性计算即可。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; k) &#123;</span><br><span class="line">            list.add(nums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        res[idx++] = getMid(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            remove(list, nums[i - k]);</span><br><span class="line">            add(list, nums[i]);</span><br><span class="line">            res[idx ++] = getMid(list);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMid</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = list.size();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)list.get((n-<span class="number">1</span>)/<span class="number">2</span>)+list.get(n/<span class="number">2</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(n/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) == x) &#123;</span><br><span class="line">                list.remove(mid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.get(mid) &gt; x) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = list.size();</span><br><span class="line">        <span class="comment">// 数组为空，或者最大的元素比要插入的还小 直接加在后面</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || list.get(n - <span class="number">1</span>) &lt;= x) &#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.get(<span class="number">0</span>) &gt;= x) &#123;</span><br><span class="line">            list.add(<span class="number">0</span>, x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择插入点，找到第一个大于等于的数</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) &lt;= x) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(l + <span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(KlogK) + O(N *(K + logK))$，其中 $N$ 为窗口的数量，最多有 $N$ 个，$K$ 为窗口内元素的数量。其中$O(KlogK)$ 为第一次对窗口排序初始化，$O(logK)$ 对已经呈现单调性的数组进行二分查找，然后$O(N)$ 是删除和添加元素的时间消耗，$O(N * (K + logK))$ 一共存在 $N$ 个窗口，我们最多需要做 $N$ 次二分查找和添加、删除操作。</p>
<p>空间复杂度：$O(N + K)$ ，其中 $N$ 是窗口的数量， $K$ 是每个窗口里的元素数量。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>567. 字符串的排列</title>
    <url>/2021/02/10/567/</url>
    <content><![CDATA[<p>力扣链接：<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></p>
<p>相似题目推荐：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></li>
</ul>
<a id="more"></a>

<h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>题目的意思很清楚，我们需要在字符串 <code>s2</code> 中找到一段连续的子数组包含字符串 <code>s1</code> 中所有的字符，不论顺序。</p>
<h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>双指针的具体做法：</p>
<ul>
<li>我们要求的是排列，因此我们只需要考虑<strong>种类</strong>和<strong>数量</strong>；</li>
<li>使用两个指针$left$ 和 $right$，表示我们在$s2$上遍历的区间$[left,right]$，使用一个变量$count$ 表示当遍历区间时，区间内字符出现在$s1$的种类数：<ul>
<li>如果一个字符的出现次数恰好等于字符串$s1$的出现次数，那么 $count+=1$</li>
<li>当左端点移动时，某个字符出现次数减少了，恰好小于$s1$的出现次数，那么 $count-=1$</li>
<li>当区间$[left, right]$内出现的字符种类数和$s1$的字符种类数相同时，我们固定$right$。然后移动$left$，使得$right-left == |s1|$，其中$|s1|$为字符串$s1$的长度。这样我们就找到了$s1$在$s2$的一个排列。</li>
</ul>
</li>
</ul>
<p>暴力是否可行？</p>
<p>这道题的数据范围比较小，才 $10^4$，因此暴力的时间复杂度是$O(N^2)$，计算量是 $10^8$，在力扣应该够用的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s1.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="keyword">int</span> preCount = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">need</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s1) need[x - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (need[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                preCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s2[right++];</span><br><span class="line">            <span class="keyword">if</span> (need[c1 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                hash[c1 - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                <span class="keyword">if</span> (hash[c1 - <span class="string">&#x27;a&#x27;</span>] == need[c1 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == preCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left == len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> c2 = s2[left++];</span><br><span class="line">                <span class="keyword">if</span> (need[c2 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    hash[c2 - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    <span class="keyword">if</span> (hash[c2 - <span class="string">&#x27;a&#x27;</span>] &lt; need[c2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(|s1| + |s2| + |\sum|)$，其中 $|s1|$表示字符串$s1$的长度，$|s2|$表示字符串$s2$的长度，其中$\sum$表示我们存储的小写字母的数量，其中$\sum$表示我们存储的字母出现次数，其大小取决于出现的字母 $ASCII$ 的最大值和最小值。</p>
<ul>
<li>我们会遍历字符串$s1$，时间复杂度$O(|s1|)$</li>
<li>我们还会遍历字符串$s1$的哈希数组，时间复杂度$O(|\sum|)$</li>
<li>双指针需要遍历字符串$s2$，时间复杂度$O(|s2|)$</li>
</ul>
<p>空间复杂度：$O(|\sum|)$</p>
<h2 id="暴力代码"><a href="#暴力代码" class="headerlink" title="暴力代码"></a>暴力代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.size() &gt; s2.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s1.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s1) hash[x - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.size() - len; i ++) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + len; j++) &#123;</span><br><span class="line">                f[s2[j] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j] != hash[j]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(|s1| + |s2| \times |s1|)$</p>
<ul>
<li>我们需要在字符串$s2$ 上，暴力枚举 $|s2| - |s1|$ 次，来找子区间是否为字符串$s1$的一个排列。</li>
</ul>
<p>空间复杂度：$O(\sum)$，其中$\sum$为字符集大小。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>665 非递减数列</title>
    <url>/2021/02/07/cku5fjrsd001b90v472ljaeo3/</url>
    <content><![CDATA[<p>力扣链接：<a href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></p>
<p>这道题很坑，虽然是 <code>easy</code>，但是测试用例很好。</p>
<a id="more"></a>

<h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>在本题中，我们只能修改一个元素的大小。这也就意味着我们给定的数组中，<strong>至多</strong>只能存在一个 <code>i(0 &lt;= i &lt;= n - 2)</code> 满足 <code>nums[i] &gt; nums[i+1]</code> 。</p>
<p>证明如下：</p>
<p>假设存在两个不同的下标 $i$ 和 $j$ 满足上述式子，使得 $i \lt j$：</p>
<p>若 $i + 1 \lt j$ ，此时我们修改 $nums[i]$ 或 $nums[i+1]$，对于 $nums[j]$ 和 $nums[j+1]$ 之间的关系都不会造成影响；对于 $nums[j]$ 或 $nums[j+1]$ 也是同理，当我们修改其中一个时，对于 $nums[i]$ 和 $nums[i+1]$ 之间的关系都不会造成影响；</p>
<p>若 $i + 1 = j$，则有 $nums[i] \gt nums[i+1] \gt nums[i+2]$。无论我们如何修改其中一个数，都无法使得 $nums[i] \le nums[i+1] \le nums[i+2]$。</p>
<p>因此，至多只能存在一个下标 $i$ ，满足 $nums[i] \gt nums[i+1]$。</p>
<h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>由上述证明，我们只需要简单的统计一下这样的下标存在多少个即可。</p>
<p>前面说了，这道题的数据很强。存在这样一个用例 $[3,4,2,3]$ 可以推翻我们上述的思路。</p>
<p>我们在编码的过程中，如果找到一个下标满足 $nums[i] \gt nums[i+1]$ ，我们修改了 $nums[i]$ 或 $nums[i+1]$ 后，还需要检查一下整个数组是否满足非递减。</p>
<p>对于 $nums[i]$ 而言我们希望 $nums[i] \le nums[i+1]$，但 $nums[i]$ 还要不小于之前的数，所以$nums[i]$ 越大越好。因此将 $nums[i]$ 修改为 $nums[i+1]$ 更合适。同理，对于 $nums[i+1]$ 我们将 $nums[i+1]$  修改成 $nums[i]$ 最合适。</p>
<p>上述思路我们需要遍历两遍数组，我们也不必遍历两遍数组。</p>
<p>当找到这样的一个下标后，我们会修改 $nums[i]$ 或 $nums[i+1]$，还需要保证 $nums[i-1] \le nums[i]$ 成立，即 $nums[i-1] \le nums[i+1]$。若不等式不成立，那么我们需要修改 $nums[i+1]$ 为 $nums[i]$。那么此时，数组仍然是非递减的，我们可以继续遍历数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>,    <span class="number">4</span>,	<span class="number">2</span>,	<span class="number">3</span>]</span><br><span class="line">i<span class="number">-1</span>    i   i+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>$nums[i] \gt nums[i+1]$，假设我们修改了 $nums[i]$ 为 $nums[i+1]$ 后，此时 <code>[3,2,2,3]</code>。</p>
<p>因此，当 $nums[i-1] &gt; nums[i+1]$ 时，我们需要修改 $nums[i+1]$ 为 $nums[i]$，此时 <code>[3,4,4,3]</code>。</p>
<h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>值得注意的是，当我们找到多个下标 $i$ 满足 $nums[i] \gt nums[i+1]$，此时是无法构造非递减数列。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] &gt;  nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p>
<p>空间复杂度：$O(1)$</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>72. 编辑距离</title>
    <url>/2021/03/20/72/</url>
    <content><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>我们要求 $word1$ 变成 $word2$ 的最少操作次数。</p>
<p>操作如下：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>基本指导思想，对于 $word1$ 中所有的下标，我们尝试所有可能的操作，期望可以达到 $word2$ 。但是这样的时间复杂度将会达到 指数级。因此是不可能通过本题的。但我们也可以使用记忆化的方式优化。</p>
<h2 id="方法一：DFS-剪枝"><a href="#方法一：DFS-剪枝" class="headerlink" title="方法一：DFS + 剪枝"></a>方法一：DFS + 剪枝</h2><p>使用两个指针分别为 $i$ 和 $j$ ，分别指向 $word1$ 和 $word2$ ，我们借助指针的移动来对 $word1$ 模拟上述的 $3$ 种操作。</p>
<p>这里我们可以假设 $word1[0, i-1]$ 的字符 和 $word2[0, j-1]$ 已经完全相等了，此时我们的指针分别指向 $word1$ 的第 $i$ 个字符 和 $word2$  和 第 $j$ 个字符。 对于下述的操作，我们始终是在 <strong>操作</strong> $word1$ 。</p>
<p>具体实现如下：</p>
<ul>
<li>当 $word1[i] = word2[j]$ 时，我们同时移动指针 $i$ 和 $j$ 向右一位。</li>
<li>当 $word1[i] \neq word2[j]$ 时：<ul>
<li>当我们选择 【删除】时，我们移动指针 $i$ 向右一位。这里实际上对于 $word1$ 而言是 【跳过】 当前字符，让 $word1$ 的下一个字符和 $word2$ 的第 $j$ 个字符得以匹配相等，而在 $word2$ 看来，我们好像是多了一个字符。因此对于 $word2$ 而言，$word2$ 是多了一个字符。</li>
<li>当我们选择 【插入】时，我们移动指针 $j$ 向右一位。实际上对于 $word2$ 而言是 【跳过】当前字符，让 $word2$ 的下一个字符和 $word1$ 的第 $i$ 个字符得以匹配相等。对于 $word2$ 同理，在 $j$ 的位置进行 $word2$  的 【删除】操作。</li>
<li>当我们选择 【替换】时，实际上是和 $word1[i] = word2[j]$ 情况一致的。我们把指针 $i$ 和 $j$ 同时向右移动一位。</li>
</ul>
</li>
<li>在指针 $i$ 和 $j$ 没有把 $word1$ 或者 $word2$ 扫描完毕之前，我们重复上述操作。</li>
<li>当任意一个指针到达字符串末尾时，即说明我们存在一个方案使得 $word1 = word2$，。因为对于任意一个 $i (0 \le i \le word1.length, j同理)$ ，我们都存在最多可以有 $3$ 种选择分支。因此，我们需要在 【删除】、【插入】和【替换】三种操作取最小值。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>由上述搜索的思路，我们可以发现。虽然我们可能的操作一共是 $6$ 种。但是对于 $word1$ 的【删除】操作，等效于对 $word2$ 进行【插入】操作。所以我们的最终操作方案实际上是 $3$ 种。</p>
<ul>
<li>$word1$ 的【插入】操作，等效于 $word2$ 的【删除】操作</li>
<li>$word1$ 的【删除】操作，等效于 $word2$ 的【插入】操作</li>
<li>$word1$ 的【替换】操作，等效于 $word2$ 的【替换】操作。</li>
</ul>
<p>公式化描述：</p>
<p>前提条件是，$word1[0, i-1]$ 和 $word2[0, j-1]$ 已经完全相等了。$f(i, j)$ 表示 $word1$ 的前 $i (0 \le i \le word1.length)$ 个字符转变成 $word2$ 前 $j(0 \le j \le word2.length)$ 个字符所需的最小操作次数。那么存在<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>PS：不相等时，加 $1$ 是因为我们选择了任意一个操作。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> word1, <span class="keyword">int</span> i, <span class="built_in">string</span> word2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= word1.size() || j &gt;= word2.size()) &#123;</span><br><span class="line">            mem[i][j] = word1.size() - i + word2.size() - j;</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">            mem[i][j] = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> mem[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> increased = dfs(word1, i, word2, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> deleted = dfs(word1, i + <span class="number">1</span>, word2, j);</span><br><span class="line">        <span class="keyword">int</span> modify = dfs(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">        mem[i][j] = min(increased, min(deleted, modify)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">        <span class="keyword">return</span> dfs(word1, <span class="number">0</span>, word2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(3^{max{n, m}})$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p>
<ul>
<li>但是由于我们存在缓存数组，因此时间复杂度是远远小于这个级别的。具体的时间复杂度我也没有办法分析。</li>
</ul>
<p>空间复杂度：$O(n \times m)$，我们要缓存字符串所有可能状态的最小操作数。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>由上一步，我们通过 【自顶向下】的一顿分析，递推出来的式子。进行改造<br>$$<br>f(i,j)=<br>\begin{cases}<br>&amp; f(i + 1, j + 1) , word1[i] = word2[j] \\<br>&amp; min{f(i+1, j), f(i+1,j+1), f(i, j +1)} + 1, word1[i] \ne word2[j]<br>\end{cases}<br>$$<br>我们需要注意的点，就是边界问题，也就是当 $i=0$ 或者 $j = 0$ 时，当任意一个字符串为空串时，我们的改变次数等于不为空的字符串的长度。</p>
<p>我们的动态规划转移公式仍然定义为： $f[i][j]$，表示 $word1[0,i]$ 与 $word2[0,j]$ 完全相等的最小操作次数。 </p>
<p>因此，动态规划的转移方程为：</p>
<ul>
<li>当 $word1[i] = word2[j]$ ，$f[i][j] = f[i-1][j-1]$，相等时，不需要任何操作。</li>
<li>当 $word1[i] \ne word2[j]$，$f[i][j] = min{f[i-1][j], f[i-1][j-1], f[i][j-1]} + 1$，我们从三种操作中，选择最小的一种进行一次操作。</li>
</ul>
<p>解释：</p>
<ul>
<li>$f[i-1][j]$ 表示将 $word1[0, i -1]$ 的第 $i$ 个字符【删除】后，使得 $word1[0,i] = word2[0, j]$</li>
<li>$f[i-1][j-1]$ 表示将 $word1[0,i-1]$ 的第 $i$ 个字符进行【修改】后，使得 $word1[0,i] = word2[0,j]$</li>
<li>$f[i][j-1]$ 表示在 $word1[0,i]$ 【插入】一个字符后，使得 $word1[0, i] = word2[0,j]$</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.size(), m = word2.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) </span><br><span class="line">            f[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) </span><br><span class="line">            f[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j], min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n \times m)$，其中 $n$ 和 $m$ 分别是指字符串 $word1$ 和 $word2$ 的长度。</p>
<p>空间复杂度：$O(n \times m)$</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>848. 字母移位</title>
    <url>/2021/02/20/848/</url>
    <content><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>给定一个字符串和数组，且二者长度是相同的。</p>
<p>移位过程中，字母表是环绕的，即超过 <code>z</code> 的部分，将会从 <code>a</code> 重新开始计数。</p>
<p><code>shifts[i] = x</code> ，表示的是我们将 <code>S</code> 中的前 <code>i + 1</code> 个字母移位 <code>x</code> 次。</p>
<p><strong>移位</strong>操作我们定义为 $shift$ 函数处理。</p>
<h1 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h1><p>我们发现了数据范围，实际上是 $2 \times 10 ^ 4$，而我们的暴力做法时间复杂度将会达到 $N^2$ ，也就是 $4 \times 10^8$ 计算次数。那么对于一道中等题，显而易见是会 $TLE$ 超时的。</p>
<p>先看看暴力的做法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = shifts.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = shifts[i] % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">                s[j] = shift(s[j], k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">shift</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c + k - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：$O(N^2)$，其中 $N$ 表示数组和字符串的长度。</p>
<p>空间复杂度：$O(1)$</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>对于 $shifts[i] \ (0 \le i \le n-1)，其中 n 为数组长度$ 而言，我们的<strong>移位</strong>操作次数实际上是<br>$$<br>\sum_{k=i}^{n-1} shift(S[k], shifts[k])，其中 \ S \ 为字符串<br>$$<br>因此，我们可以采用<strong>后缀和</strong>来优化这一过程。</p>
<p>与前缀和最好相反，后缀和 我们定义为 $Sum[i]$，表示为区间 $[i, n -1]$ 的总和。</p>
<h1 id="方法二：后缀和"><a href="#方法二：后缀和" class="headerlink" title="方法二：后缀和"></a>方法二：后缀和</h1><p>我们定义 $Sum[i]$ 表示为<br>$$<br>\sum_{k=i}^{n-1}arr[k]<br>$$<br>这样就可以在 $O(1)$ 时间复杂度，获得第 $i$ 个字符一共<strong>移位</strong>多少次。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = shifts.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            shifts[i] %= <span class="number">26</span>;</span><br><span class="line">            shifts[i] += shifts[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) S[i] = shift(S[i], shifts[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">shift</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> + (c + k - <span class="string">&#x27;a&#x27;</span>) % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：$O(N)$，其中 $N$ 为数组和字符串的长度。</p>
<ul>
<li>我们会遍历一次 $shifts$ 数组，计算出后缀和。时间复杂度 $O(N)$</li>
<li>我们遍历字符串，给每一个字符进行<strong>移位</strong>操作，<strong>移位</strong>操作时间复杂度为 $O(1)$。所以遍历字符串的时间复杂度为 $O(N)$。</li>
<li>我们对于数组或者字符串中的任意一个元素，至多只会遍历一次。</li>
</ul>
<p>空间复杂度：$O(1)$，我们直接使用的 $shifts$ 数组的空间。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>978. 最长湍流子数组</title>
    <url>/2021/02/08/978/</url>
    <content><![CDATA[<p>力扣链接：<a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">最长湍流子数组</a></p>
<p>相似题目推荐：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/wiggle-subsequence/">力扣376. 摆动序列</a></li>
</ul>
<h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>设数组 $arr$的长度为 $n$，存在一个子数组区间$[left, right]$，定义为<em>湍流子数组</em> 。</p>
<p>根据题意 <em>湍流子数组</em> 的定义如下，假设 $0\lt right \lt n - 1$：</p>
<ul>
<li>如果 $arr[right - 1] \gt arr[right]$ 且 $arr[right] \lt arr[right + 1]$，则$[left, right + 1]$ 构成湍流子数组，右指针$right$可以右移一位。湍流子数组长度加1;</li>
<li>如果 $arr[right - 1] \gt arr[right]$ 且 $arr[right] \lt arr[right+1]$，则 $[left, right+1]$ 也构成湍流子数组，同理$right$需要右移一位。</li>
<li>否则，$[right-1,right+1]$无法构成湍流子数组，此时我们需要移动左指针$left$，使得$left=right$。</li>
</ul>
<h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>值得注意的是，当 $left == right$，也就是湍流子数组的长度为 $1$ 时。只要$arr[right] \neq arr[right+1]$不相等，我们就可以移动右指针，否则$left$和$right$都要移动。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[left] == arr[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left ++;</span><br><span class="line">                &#125;</span><br><span class="line">                right ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[right - <span class="number">1</span>] &lt; arr[right] &amp;&amp; arr[right] &gt; arr[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                    right ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[right - <span class="number">1</span>] &gt; arr[right] &amp;&amp; arr[right] &lt; arr[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                    right ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            res = max(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。对于数组的任意一个元素，我们至多不会访问 $N$ 次。</p>
<p>空间复杂度：$O(1)$</p>
<h1 id="方法二：动态规划-DP"><a href="#方法二：动态规划-DP" class="headerlink" title="方法二：动态规划(DP)"></a>方法二：动态规划(DP)</h1><p>类似题目：<a href="https://leetcode-cn.com/problems/wiggle-subsequence/">力扣376. 摆动序列</a></p>
<h2 id="开头-1"><a href="#开头-1" class="headerlink" title="开头"></a>开头</h2><p><strong>状态定义：</strong></p>
<ul>
<li>$increased[i]$ 表示以 $i$ 结尾的，并且 $arr[i-1] &lt; arr[i]$的子数组长度</li>
<li>$decreased[i]$表示以 $i$ 结尾的，并且 $arr[i-1] &gt; arr[i]$ 的子数组长度</li>
</ul>
<p><strong>状态转移：</strong></p>
<p><strong>伪代码(风格采用Python)</strong></p>
<p>对于 $increased[i]$：<br>$$<br>\begin{align}<br>if &amp;\ \ \ i \gt 0 \ and \ arr[i-1] \lt arr[i]: \\<br>&amp; increased[i] = decreased[i-1] + 1 \<br>\end{align}<br>$$<br>对于 $decreased[i]$：<br>$$<br>\begin{align}<br>if &amp;\ \ \ i \gt 0 \ and \ arr[i-1] \gt arr[i]: \\<br>&amp; decreased[i] = increased[i-1] + 1 \<br>\end{align}<br>$$</p>
<h2 id="编码思路-1"><a href="#编码思路-1" class="headerlink" title="编码思路"></a>编码思路</h2><p>注意边界情况：</p>
<ul>
<li>初始值时 $increased[0] = decreased[0] = 1$；</li>
<li>当都不满足转移条件时，此时应该将$increased[0] = decreased[0] = 1$，都置为 $1$，以方便后续转移。</li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        vector&lt;int&gt; increased(n), decreased(n);</span><br><span class="line">        increased[<span class="number">0</span>] = decreased[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">                decreased[i] = increased[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                increased[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt; arr[i]) &#123;</span><br><span class="line">                increased[i] = decreased[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                decreased[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                increased[i] = decreased[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, max(increased[i], decreased[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码优化：</p>
<ul>
<li>我们注意到了对于数组中的元素，我们每次只会使用到上一次的状态，因此可以对空间进行优化</li>
</ul>
<p><strong>优化后的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> increased = <span class="number">1</span>, decreased = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">                decreased = increased + <span class="number">1</span>;</span><br><span class="line">                increased = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt; arr[i]) &#123;</span><br><span class="line">                increased = decreased + <span class="number">1</span>;</span><br><span class="line">                decreased = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                increased = decreased = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, max(increased, decreased));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。我们只会遍历一次数组。</p>
<p>空间复杂度：$O(1)$，我们只使用了常数空间。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>992. K 个不同整数的子数组</title>
    <url>/2021/02/09/992/</url>
    <content><![CDATA[<p>力扣链接：<a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a></p>
<p>相似题目推荐：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></li>
</ul>
<h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>按照我们做双指针题目的经验，可以很快的想到，定义两个指针一前一后的交替遍历数组，即可找出<strong>最大</strong>不同整数的子数组。</p>
<p>注意是<strong>最大</strong>，而本题中要询问的某个子数组中不同整数的个数<strong>恰好</strong>为 $K$ 的个数。</p>
<p>对于例子：$A = [1,2,1,2,3], K = 2$，你很快就可以发现，使用双指针的思路，是找不到子数组 $[2,1]$ 的。</p>
<p>这是因为一个符合要求的区间，当其左端点固定时，其右端点是不固定的。</p>
<p>当 左端点为 $left = 1$ 时，其右端点可以是 $right=2$ 也可以是$right=3$。因为子数组$[2,1,2]$ 也是符合要求的。</p>
<p>因此，我们需要转换思路，将问题转换一下。</p>
<h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们把原问题的<strong>恰好</strong>包含 $K$ 个不同整数，改成 <strong>最多</strong> 包含 $K$ 个不同整数的。那么要求的原问题，就成了一个子问题。它等价于 [最多包含$K$ 个不同整数] - [最多包含$K-1$个不同整数]。</p>
<p>可以确定集合 ${[最多包含K个不同整数] }$，是由 ${[恰好包含1种不同整数] , [恰好包含2种不同整数],… ,[恰好包含K种不同整数] }$等元素组成。</p>
<p>那么 $[恰好包含K个不同整数] = [最多包含K 个不同整数] - [最多包含K-1个不同整数]$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(A, K) - get(A, K - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">freq</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = A[right];</span><br><span class="line">            <span class="keyword">if</span> (freq[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            freq[x] ++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count &gt; K) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = A[left];</span><br><span class="line">                freq[y] --;</span><br><span class="line">                <span class="keyword">if</span> (freq[y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>EQ-2-两数相加</title>
    <url>/2021/09/27/2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></p>
<h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>由于两个链表都是<strong>逆序</strong>存储数字的位数，因此我们对于每一个相同位置的数字可以直接相加。</p>
<p>我们可以同时遍历链表，逐位计算每一位的和，并与当前进位的值和相加。如果当前位的数字分别为 $n1$ 和 $n2$ ，进位值 $carry$，那么当前位的和即表示为 $n1 + n2 + carry$，答案链表对应位置的数字即 $(n1 + n2 + carry) ; mod ; 10$，新的进位为 $\lfloor \frac{n1+n2+carry}{10} \rfloor$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        res -&gt; next = cur;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1 -&gt; val;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2 -&gt; val;</span><br><span class="line">            <span class="keyword">int</span> s = n1 + n2 + carry;</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            carry = s / <span class="number">10</span>;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1 -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(max(n, m))$，其中 $n$ 表示为链表1的长度，$m$ 表示为链表2的长度。我们会遍历两个链表的全部位置，且每个位置的处理时间为 $O(1)$。</p>
<p>空间复杂度：$O(max(n, m))$。</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>力扣</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>EQ-371-两整数之和</title>
    <url>/2021/09/26/371/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></p>
<h1 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>有符号整数在计算机中通常以补码的形式存储和表示，补码具有以下特征：</p>
<ol>
<li>正整数的补码与原码一致；负整数的补码为其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1</li>
<li>可以将减法运算转化为补码的加法运算来实现</li>
<li>补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算</li>
</ol>
<p>摘至：<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">百度百科-补码</a></p>
<h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>首先，题目不允许使用运算符 <code>+</code> 和 <code>-</code> 。因此我们可以使用位运算代替这两种运算符的方式，观察一下我们在做补码加法时有如下四种情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span>;(进位)</span><br></pre></td></tr></table></figure>
<p>对于整数 $a$ 和 $b$，我们可以总结出：</p>
<ol>
<li>在不考虑进位的情况下，我们得到<strong>无进位加法结果</strong> $a \bigoplus b$。</li>
<li> 而所有需要进位的位为 $a \&amp; b$ ，<strong>进位结果</strong>可以表示为 $a \&amp; b &lt;&lt; 1$</li>
</ol>
<p>我们要求得 $a + b$ ，就表示为 <strong>无进位结果</strong> 和 <strong>进位结果</strong> 之和。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(log(C))$，令 $C$ 为有符号整数的位数，题目数据范围为 $32$ 位整数，因此 $C$ 最大可取值 $32$。</p>
<p>空间复杂度：$O(1)$。</p>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>EQ-437-路径总和III</title>
    <url>/2021/09/28/437/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p>
<h1 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以遍历出所有的可能情况，对于某个节点 $node$ 我们穷举出所有可能的路径，只要满足和为 $target$ 我们就认为找到了一条路径。</p>
<p>对于任意一个节点 $node$，我们都需要计算其子节点存在的可能路径，一共有 $n$ 个节点，因为时间复杂度为 $O(n^2)$。观察数据范围节点范围最大是 $1000$，因此可行。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        getSum(root, <span class="number">0</span>, targetSum);</span><br><span class="line">        pathSum(root -&gt; left, targetSum);</span><br><span class="line">        pathSum(root -&gt; right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> cur, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        cur += root -&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        getSum(root -&gt; left, cur, target);</span><br><span class="line">        getSum(root -&gt; right, cur, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n^2)$，其中 $n$ 为二叉树节点的数量，对于某一个节点，我们要遍历其所有子节点，时间复杂度为 $O(n)$。一共有 $n$ 个节点，因此时间复杂度为 $O(n^2)$。</p>
<p>空间复杂度：$O(n)$，递归消耗的栈空间。</p>
]]></content>
      <categories>
        <category>每日一题</category>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>力扣</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>EQ-583-两个字符串的删除操作</title>
    <url>/2021/09/25/583/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>题目链接：<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p>
<a id="more"></a>

<h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><p>我们可以设置 $f[i][j]$ 表示使得 $word1$ 前 $i$ 个字符 和  $word2$ 前 $j$ 个字符相等时的最小操作次数。</p>
<ol>
<li><p>对于 $0 \le i \lt word1.length$ 和 $ 0 \le j \lt word2.length$ 存在时，且我们是可以判断字符串 $word1[0…i-1]$ 和 字符串 $word2[0…j-1]$ 一定相等，那么对于 $word1$ 中第 $i$ 个字符 和 $word2$ 中第 $j$ 个字符有以下情况：</p>
<ol>
<li><p>$word1[i] = word2[j]$ ：</p>
<p> 我们不需要任何操作，因此 我们可以继承前 $i-1$ 个 和  前 $j -1$ 个字符相等时的最小操作次数。即 $f[i][j]=f[i-1][j-1]$</p>
</li>
<li><p>$word1[i] \neq word2[j]$：</p>
<ul>
<li>​    我们选择删除 $word1$ 中第 $i$ 个字符，假设此时字符串 $word1[0…i-1]$ 与字符串 $word2[0…j]$ 相等，那么需要的操作次数为 $f[i][j] = f[i-1][j] + 1$ </li>
<li>同理我们选择删除 $word2$ 中的第 $j$ 个字符，假设此时字符串 $word2[0…j-1]$ 与字符串 $word1[0…i]$ 相等，那么需要的操作次数为 $f[i][j]=f[i][j-1]+1$</li>
<li>我们选择同时删除 $word1$ 中的第 $i$ 个字符和 $word2$ 中的第 $j$ 个字符，那么此时需要的操作次数为 $f[i][j]=f[i-1][j-1]+2$</li>
<li>综合上述三种操作时，我们取最小值</li>
</ul>
</li>
</ol>
</li>
<li><p>状态转移方程定义<br> $$<br> f[i][j] =<br> \begin{cases}<br> f[i - 1][j - 1]&amp;, word1[i] = word2[j] \\<br> min({ f[i-1][j] + 1, f[i][j-1]+1, f[i-1][j-1]+2 })&amp;, word1[i] \ne word2[j]<br> \end{cases}<br> $$</p>
</li>
<li><p>初始化 $f$ 数组，我们的边界值实际上是当 $word1$ 或 $word2$ 为空字符串时</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i; <span class="comment">// word2 为空字符串时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j; <span class="comment">// word1 为空字符串时、</span></span><br></pre></td></tr></table></figure></li>
<li><p>以 <code>word1=sea</code> 和 <code>word2=eat</code> 举例，展示 $f$ 数组的状态</p>
<p> <img src="https://pic.imgdb.cn/item/614f04932ab3f51d91e2c486.jpg"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) f[j][<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(&#123;f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>, f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p> 时间复杂度：$O(m \times n)$，其中 $m$ 为 $word1.length$，$n$ 为 $word2.length$ 。</p>
<p> 空间复杂度：$O(m \times n)$。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>力扣</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>每日一题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言实践-豆瓣TOP250</title>
    <url>/2021/04/07/doubantop250/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集中 学习+复习 Go 语言有一个多星期了，也该写点东西了。</p>
<p>说下使用的 Go 语言的感受吧，直观上来说。Go 刚上手是比较反人类的，比如变量名和变量类型的位置是反着的，已经函数和方法的返回值的位置就更加的奇怪了。但是，总体的上手难度不是很大。相反，我认为这些也是 Go 的一大特色吧 (笑)。总体的学习门槛是比较低的，而且 Go 身上也有很多 C/C++ 的影子 (比如指针类型，还有结构体)。最让我感到意外的就是，Go 语言中的接口的设计，真正的做到了低耦合。因为只要任意一个结构体或者类型实现了接口中的方法后，就算是真正意义上的实现了一个接口。而当我们从代码里 “拿走” 这个接口时，是不会影响到实现了该接口的结构体或者类型，因为那只是它们的方法而已。</p>
<p>你可能会疑惑，为什么要从爬虫开始实践？</p>
<p>我认为兴趣是最好的老师，我不喜欢死板的去写 ”xxx通讯录管理系统“ 或者 ”xxx管理系统“ 之类的无聊 demo。我是兴趣驱动，我更愿意从爬虫入手去学习。</p>
<p>本来打算拿我的看家本领 Senlium 呢，结果到官网一查还不支持 Go。</p>
<p>好的，说的有点多了，下面开始我们的 Go 语言爬虫实践吧。</p>
<p>项目地址：<a href="https://github.com/qybit/doubantop250">项目地址</a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>开发环境</p>
<ul>
<li>go version go1.16.2 windows/amd64</li>
<li>goland</li>
<li>第三方库 goquery（一个类似jQuery可以操作DOM的库）</li>
</ul>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>结构体</li>
<li>函数 / 方法</li>
<li>http</li>
<li>懂得 DOM 编程，至少会 JavaScript 中的 DOM 部分</li>
<li>正则表达式</li>
<li> 异常处理</li>
<li>json</li>
<li>io 处理</li>
</ul>
<h2 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h2><p>我们的工作目录长这样👇。Movie 应该写成 movie 的，写 Java 写顺手了 (笑)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/doubantop250_0.png"></p>
<h2 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h2><p>作为一只合格的网络爬虫，我们必须要可以发起基本的 http 请求获得网页数据。</p>
<p>正规的网站，一般最基础的防御就是通过 User-Agent / Agent 字段的校验，来检测是不是真人用户操作。我们只需要在请求头中加入这一字段，把自己 “伪装” 成真人用户，具体内容可以在浏览器查看。这里不在赘述。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">	request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用获取的响应内容，构建-DOM-树"><a href="#使用获取的响应内容，构建-DOM-树" class="headerlink" title="使用获取的响应内容，构建 DOM 树"></a>使用获取的响应内容，构建 DOM 树</h2><p>这一步，我们将会使用 goquery 库，它会帮助我们把网络请求的响应内容解析成一颗 DOM 树。并提供和 JavaScript 和 jQuery 类似的 API 供我们访问某个节点。</p>
<p>这里的 content 实际上就是 响应的Body 部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">	reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析单个页面的所有电影内容"><a href="#解析单个页面的所有电影内容" class="headerlink" title="解析单个页面的所有电影内容"></a>解析单个页面的所有电影内容</h2><p>我们拿到上面生成的 goquery.Document 对象， goquery 提供的选择器的功能和 jQuery 几乎一模一样。所以有过 jQuery 使用经验的话，上手 goquery 是非常容易的。这里的稍微麻烦点的就是我们处理字符串的时候。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">	doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">		cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">		title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">		subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">		subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">		other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">		other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">		desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">		DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">		desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">		movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">		year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">		area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">		tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">		star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">		comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">		compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">		comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">		quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">		movie := &amp;entity.Movie&#123;</span><br><span class="line">			Title:    title,</span><br><span class="line">			Subtitle: subtitle,</span><br><span class="line">			Other:    other,</span><br><span class="line">			Cover:    cover,</span><br><span class="line">			Desc:     desc,</span><br><span class="line">			Year:     year,</span><br><span class="line">			Area:     area,</span><br><span class="line">			Tag:      tag,</span><br><span class="line">			Star:     star,</span><br><span class="line">			Comment:  comment,</span><br><span class="line">			Quote:    quote,</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>这里将会调用上面的所有方法，然后根据用户输入的信息，进行决策。</p>
<p>比如从哪一页开始获取，以及是否需要持久化等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   content, err := fetchSinglePageContent(URL, start)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   dom, err := generatorDomTree(content)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   books, err := parseSinglePage(dom)</span><br><span class="line">   <span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">      fmt.Println(book)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      data, _ := json.Marshal(books)</span><br><span class="line">      err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/my/toubantop250.png"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module qybit.com/doubantop250</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require github.com/PuerkitoBio/goquery v1<span class="number">.6</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="entiy-包"><a href="#entiy-包" class="headerlink" title="entiy 包"></a>entiy 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title    <span class="keyword">string</span> <span class="string">`json:&quot;title&quot;`</span><span class="comment">// 中文名</span></span><br><span class="line">	Subtitle <span class="keyword">string</span> <span class="string">`json:&quot;subtitle&quot;`</span><span class="comment">// 英文名</span></span><br><span class="line">	Other    <span class="keyword">string</span> <span class="string">`json:&quot;other&quot;`</span><span class="comment">// 港澳台翻译名</span></span><br><span class="line">	Cover    <span class="keyword">string</span> <span class="string">`json:&quot;cover&quot;`</span><span class="comment">// 电影封面</span></span><br><span class="line">	Desc     <span class="keyword">string</span> <span class="string">`json:&quot;desc&quot;`</span><span class="comment">// 描述</span></span><br><span class="line">	Year     <span class="keyword">string</span> <span class="string">`json:&quot;year&quot;`</span><span class="comment">// 上映年份</span></span><br><span class="line">	Area     <span class="keyword">string</span> <span class="string">`json:&quot;area&quot;`</span><span class="comment">// 属于哪个国家</span></span><br><span class="line">	Tag      <span class="keyword">string</span> <span class="string">`json:&quot;tag&quot;`</span><span class="comment">// 属于哪一类型的电影</span></span><br><span class="line">	Star     <span class="keyword">string</span> <span class="string">`json:&quot;star&quot;`</span><span class="comment">// 评分</span></span><br><span class="line">	Comment  <span class="keyword">string</span> <span class="string">`json:&quot;comment&quot;`</span><span class="comment">// 参与评分的人数</span></span><br><span class="line">	Quote    <span class="keyword">string</span> <span class="string">`json:&quot;quote&quot;`</span><span class="comment">// 宣传标语</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spider-包"><a href="#spider-包" class="headerlink" title="spider 包"></a>spider 包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spider</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/PuerkitoBio/goquery&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;qybit.com/doubantop250/entity&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	URL          <span class="keyword">string</span> = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span></span><br><span class="line">	DefaultCover <span class="keyword">string</span> = <span class="string">&quot;https://img.imgdb.cn/item/601fdca33ffa7d37b326de61.jpg&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchSinglePageContent</span><span class="params">(url <span class="keyword">string</span>, start <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	request, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url+start, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&quot;</span>)</span><br><span class="line">	request.Header.Add(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://movie.douban.com/top250&quot;</span>)</span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的电影对应的 li 标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSinglePage</span><span class="params">(doc *goquery.Document)</span> <span class="params">([]*entity.Movie, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret []*entity.Movie</span><br><span class="line">	doc.Find(<span class="string">&quot;#content &gt; div &gt; div.article &gt; ol &gt; li&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">		cover, _ := s.Find(<span class="string">&quot;.pic a img&quot;</span>).Eq(<span class="number">0</span>).Attr(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"></span><br><span class="line">		title := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">0</span>).Text()</span><br><span class="line">		subtitle := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">1</span>).Text()</span><br><span class="line">		subtitle = strings.TrimLeft(subtitle, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">		other := s.Find(<span class="string">&quot;.hd a span&quot;</span>).Eq(<span class="number">2</span>).Text()</span><br><span class="line">		other = strings.TrimLeft(other, <span class="string">&quot;  /  &quot;</span>)</span><br><span class="line"></span><br><span class="line">		desc := strings.TrimSpace(s.Find(<span class="string">&quot;.bd p&quot;</span>).Eq(<span class="number">0</span>).Text())</span><br><span class="line">		DescInfo := strings.Split(desc, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">		desc = DescInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">		movieDesc := strings.Split(DescInfo[<span class="number">1</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">		year := strings.TrimSpace(movieDesc[<span class="number">0</span>])</span><br><span class="line">		area := strings.TrimSpace(movieDesc[<span class="number">1</span>])</span><br><span class="line">		tag := strings.TrimSpace(movieDesc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">		star := s.Find(<span class="string">&quot;.bd star .rating_num&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">		comment := strings.TrimSpace(s.Find(<span class="string">&quot;.bd star span&quot;</span>).Eq(<span class="number">3</span>).Text())</span><br><span class="line">		compile := regexp.MustCompile(<span class="string">&quot;[0-9]&quot;</span>)</span><br><span class="line">		comment = strings.Join(compile.FindAllString(comment, <span class="number">-1</span>), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">		quote := s.Find(<span class="string">&quot;.quote .inq&quot;</span>).Text()</span><br><span class="line"></span><br><span class="line">		movie := &amp;entity.Movie&#123;</span><br><span class="line">			Title:    title,</span><br><span class="line">			Subtitle: subtitle,</span><br><span class="line">			Other:    other,</span><br><span class="line">			Cover:    cover,</span><br><span class="line">			Desc:     desc,</span><br><span class="line">			Year:     year,</span><br><span class="line">			Area:     area,</span><br><span class="line">			Tag:      tag,</span><br><span class="line">			Star:     star,</span><br><span class="line">			Comment:  comment,</span><br><span class="line">			Quote:    quote,</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, movie)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析获取的内容为 DOM 树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatorDomTree</span><span class="params">(content io.Reader)</span> <span class="params">(*goquery.Document, error)</span></span> &#123;</span><br><span class="line">	reader, err := goquery.NewDocumentFromReader(content)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> reader, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析单一页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseOnePage</span><span class="params">(start <span class="keyword">string</span>, page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	content, err := fetchSinglePageContent(URL, start)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;获取内容时出错！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	dom, err := generatorDomTree(content)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解析成 DOM 树的过程中出错！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	books, err := parseSinglePage(dom)</span><br><span class="line">	<span class="keyword">for</span> _, book := <span class="keyword">range</span> books &#123;</span><br><span class="line">		fmt.Println(book)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		data, _ := json.Marshal(books)</span><br><span class="line">		err := ioutil.WriteFile(<span class="string">&quot;page&quot;</span>+strconv.Itoa(page)+<span class="string">&quot;.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(page <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> k <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= page; i++ &#123;</span><br><span class="line">		parseOnePage(strconv.Itoa(k), i, ok)</span><br><span class="line">		k += <span class="number">25</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;qybit.com/doubantop250/spider&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;请输入要爬取的页数，最大10页：&quot;</span>)</span><br><span class="line">	cin := bufio.NewScanner(os.Stdin)</span><br><span class="line">	cin.Scan()</span><br><span class="line">	page, err := strconv.Atoi(cin.Text())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;输入数据不合法，请按照要求输入！&quot;</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Print(<span class="string">&quot;是否需要持久化？（请输入 yes/y 或者 no/n）&quot;</span>)</span><br><span class="line">	cin.Scan()</span><br><span class="line">	ok := cin.Text()</span><br><span class="line">	isOk := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> ok == <span class="string">&quot;yes&quot;</span> || ok == <span class="string">&quot;y&quot;</span> &#123;</span><br><span class="line">		isOk = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	spider.Run(page, isOk)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术交流</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/2020/11/26/cku5fjrsk002990v43iq0bmqn/</url>
    <content><![CDATA[<p>Trie树是一种特殊的数据结构，它常用于在数据中检索字符串。也可以叫做字典树和前缀树等等。</p>
<a id="more"></a>

<h3 id="一、应用"><a href="#一、应用" class="headerlink" title="一、应用"></a>一、应用</h3><p>1、搜索引擎的搜索推荐</p>
<p><img src="https://pic.downk.cc/item/5fbf94b215e7719084174e71.png"></p>
<p>2、文档和文本检索功能</p>
<p><img src="https://pic.downk.cc/item/5fbf951b15e7719084176a14.png"></p>
<p>3、打字预测</p>
<p><img src="https://pic.downk.cc/item/5fbf864115e771908413a64d.jpg"></p>
<h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><p>检索字符串的操作中，我们大可以选择像<code>Set</code>, <code>HashMap</code>等高级数据结构，但是当数据量很大时，不同数据计算出的<code>hash</code>可能会存在重复的情况，导致时间复杂度不再是理想状态的$O(1)$，而是使查询效率退化至$O(n)$ ，<code>n</code>为查询次数（具体可以查看<code>HashMap</code>解决<code>hash</code>冲突的方法）。而且如果键长到一定情况时，查询任一字符串时都是$O(n)$效率的话，用<code>HashMap</code>的效率会显得很不尽人意。所以<code>HashMap</code>的缺点就显现出来了。</p>
<ul>
<li>无法应对大量的查询任务，存在<code>hash</code>冲突。</li>
<li>按字典序的多次查询任务。</li>
</ul>
<p>字典树的查询效率为$O(m)$，<code>m</code>为字符串的长度。</p>
<p>结构特点</p>
<p>字典树是一个有根节点的树：</p>
<ul>
<li>子节点是字母表中的所有的元素，本文的字母表仅限于26个小写字母。</li>
<li>布尔值，可以确定当前字母是否为一个完整的键。</li>
</ul>
<p><strong>TrieNode:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TireNode[] next; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        next = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next[c-<span class="string">&#x27;a&#x27;</span>] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TireNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c, TrieNode node)</span> </span>&#123;</span><br><span class="line">        next[c-<span class="string">&#x27;a&#x27;</span>] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字典树的最常用的方法就是插入和查找。</p>
<h3 id="3、方法实现"><a href="#3、方法实现" class="headerlink" title="3、方法实现"></a>3、方法实现</h3><h4 id="1、insert"><a href="#1、insert" class="headerlink" title="1、insert"></a>1、insert</h4><p>在树中插入一个新单词。现在树中存在的单词可能为$[“apply”, “a”, “abc”, “ab”]$ </p>
<p><img src="https://pic.downk.cc/item/5fbf8d1f15e7719084156686.png"></p>
<p>现插入新单词 <code>abandon</code>后。</p>
<p><img src="https://pic.downk.cc/item/5fbf8d9d15e7719084158c9d.png"></p>
<p><strong>具体操作：</strong></p>
<p>插入之前，先找到其根节点，从根节点出发找到第一个字母对应的节点，对于下一个字母有两种情况需要考虑：</p>
<ul>
<li>存在通路。即已存在节点，进行移动到下一层。</li>
<li>不存在通路。即不存在节点，创建一个新节点，然后移动到新节点</li>
</ul>
<p>重复这两步操作，直到这个单词被遍历完毕。当到达单词最后一个，将最后一个节点设置为结束标志。</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(m)$，<code>m</code>为字符串的长度，每一层在选择节点时的操作是$O(1)$，需要把所有的字母都走一遍。</p>
<p>空间复杂度：$O(m)$，<code>m</code>为字符串的长度，最差的情况需要创建<code>m</code>个节点，最好的情况是不需要创建新节点。</p>
<h4 id="2、search"><a href="#2、search" class="headerlink" title="2、search"></a>2、search</h4><p>在字典树中搜索字符。先字典树中存在单词有$[“apply”, “a”, “abc”, “ab”, “abandon”]$</p>
<p>例如，在字典树中搜索单词<code>abandon</code></p>
<p><img src="https://pic.downk.cc/item/5fbf913c15e77190841675ae.png"></p>
<p><strong>具体操作：</strong></p>
<p>对于待搜索的一个单词，我们先从根节点开始搜索，从单词的第一个字母开始查找节点，那么对于任意节点都有两种情况：</p>
<ul>
<li>存在通路。即已存在节点，移动到下一层。</li>
<li>不存在通路。说明节点不存在，那么搜索失败。树中并不存在此节点</li>
</ul>
<p>重复上述两种操作，直到读取结束标志时，才算是一次成功的搜索，即说明字符串已经存在。</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(m)$，<code>m</code>为字符串长度，最差为就是搜索成功的时候，即所有字母全部检索到。</p>
<p>空间复杂度：$O(1)$</p>
<h3 id="4、完整代码实现"><a href="#4、完整代码实现" class="headerlink" title="4、完整代码实现"></a>4、完整代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TrieNode[] next;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">            next = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next[c-<span class="string">&#x27;a&#x27;</span>] != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> c, TrieNode node)</span> </span>&#123;</span><br><span class="line">            next[c-<span class="string">&#x27;a&#x27;</span>] = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isEnd = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(c)) &#123;</span><br><span class="line">                node.put(c, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            node = node.get(c);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            node = node.get(c);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Trie</tag>
        <tag>数据结构</tag>
        <tag>Wheel</tag>
      </tags>
  </entry>
  <entry>
    <title>async/await原理学习笔记</title>
    <url>/2021/09/29/async-await-source/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="1、JS-是单线程"><a href="#1、JS-是单线程" class="headerlink" title="1、JS 是单线程"></a>1、JS 是单线程</h3><p>首先，JavaScript 的一大特色就是单线程语言，这种设计使得 JavaScript 在同一时刻只做一件事；作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，避免了复杂性，比如假设 JavaScript 有两个线程，那么在同一时刻进行添加和删除节点操作，为浏览器分辨以哪个线程为主带来了困难，所以单线程是它作为脚本语言的优势，也是核心所在。</p>
<h3 id="2、同步任务和异步任务"><a href="#2、同步任务和异步任务" class="headerlink" title="2、同步任务和异步任务"></a>2、同步任务和异步任务</h3><p>单线程也就意味所有的任务都需要排队，前一个任务结束后下一个任务才会执行，为了提高 CPU 的利用率，就把任务分为了同步任务和异步任务。同步任务会在主线程栈顺序执行，而异步任务则会先进入任务队列中。在主线程上会形成一个执行栈，等执行栈中所有任务执行完毕后，会到异步任务队列中查看有哪些事件，此时异步任务结束等待状态，进入执行栈中，开始执行。</p>
<h2 id="JS-异步编程方法"><a href="#JS-异步编程方法" class="headerlink" title="JS 异步编程方法"></a>JS 异步编程方法</h2><p>需求描述：假设我有一个 <code>db1.json</code> 存放用户的个人信息，有一个 <code>db2.json</code> 存放用户的订单信息。现在我要查找该用户的全部订单信息，我应该怎么做？</p>
<blockquote>
<p>首先我需要先根据前台的信息查找到用户的个人信息后，再去查找用户的订单信息。</p>
</blockquote>
<p>那么在业务代码上是如何体现的呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">&#x27;/db/db1.json&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err; <span class="comment">// error </span></span><br><span class="line"> 	<span class="comment">// success</span></span><br><span class="line">    readFile(<span class="string">&#x27;/db/db2.json&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       	<span class="comment">// do something </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以很明显的看到，我们的业务代码在不停的嵌套着这种回调函数风格，假如我在获取到 <code>bd1.json</code> 之后还有其他的事情，比如查看用户是不是满足打折优惠、满减和附赠优惠卷等活动时，那这个嵌套的深度将会 $\infty$ 大。</p>
<h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><ol>
<li><p>嵌套深度过大，代码难以阅读和维护，造成 “回调地狱”。</p>
</li>
<li><p>异步任务具有 “滞后性”，即它略过异步任务代码，直接执行同步代码。造成 undefined 错误。</p>
<p> 相信有很多用过 jQuery 的小伙伴，那么对于下面这种错误代码，应该都非常的熟悉</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://xxx.com/api/xxx&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: <span class="number">12</span>,  </span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        res = data; <span class="comment">// 上下文找不到该变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure>
<p> 原因此时很简单，因为 ajax 本身是一个异步任务，因此在执行时 ajax 函数的上下文已经发生了改变。因此找不到 res 变量，又由于 JS 会提升变量因此 res = undefined。</p>
<p> 解决办法：async: false，将 ajax 改为 同步任务</p>
</li>
<li><p>执行上下文发生改变。</p>
</li>
</ol>
<h2 id="Promise-链式调用解决-回调地狱"><a href="#Promise-链式调用解决-回调地狱" class="headerlink" title="Promise 链式调用解决 回调地狱"></a>Promise 链式调用解决 回调地狱</h2><p>我们改造异步编程中的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       	readFile(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       		<span class="comment">// do something </span></span><br><span class="line">            resolve(data);</span><br><span class="line">    	&#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 链式调用</span></span><br><span class="line">readFilePromise(<span class="string">&#x27;/db1.json&#x27;</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">&#x27;/db2.json&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(); <span class="comment">// .....</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是这样的代码可能看起来逻辑上是足够清晰了，但是我又不想嵌套这么多层的 <code>then</code>，而且每一层 <code>then</code> 里我还要返回一个 Promise ，才能保证调用链的正常执行。</p>
<h2 id="解决-回调地狱-的终极方法"><a href="#解决-回调地狱-的终极方法" class="headerlink" title="解决 回调地狱 的终极方法"></a>解决 回调地狱 的终极方法</h2><h3 id="async-await-关键字"><a href="#async-await-关键字" class="headerlink" title="async/await 关键字"></a>async/await 关键字</h3><p>可以通过 <code>async/await</code> 一对关键字，注意是一对，使用 <code>await</code> 时必须要先声明 <code>async</code> 。我们可以通过 <code>await</code> 阻塞同步任务，使得异步任务完成后再继续进行同步任务。</p>
<p>具体可看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       	readFile(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       		<span class="comment">// do something </span></span><br><span class="line">            resolve(data);</span><br><span class="line">    	&#125;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">;(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFilePromise(<span class="string">&#x27;/db1.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFilePromise(<span class="string">&#x27;/db2.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这样我们的异步任务代码就可以完美的嵌入到同步任务代码中了</p>
<h2 id="深挖原理"><a href="#深挖原理" class="headerlink" title="深挖原理"></a>深挖原理</h2><p>我们从最经典的异步任务 <code>setTimeout</code> 举例，把它改写成同步任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">await</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="comment">// 分别输出</span></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// p3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>async 和 await 处理异步任务都是基于 Promise 的，await 后面需要跟一个返回 Promise 对象的函数。</p>
</li>
<li><p>如果 await 后跟的是一个普通函数，await 会将其 Promise 化。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> otherTest();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">otherTest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherTest&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出 test start -&gt; otherTest -&gt; after test -&gt; test end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为其相当于变成了</span></span><br><span class="line"><span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test start&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        otherTest();</span><br><span class="line">    &#125;);</span><br><span class="line">    p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;test end&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>async/await是语法糖，用 async 标记的函数，在其内部遇到 await 标记的逻辑时，会被阻塞不执行后续的逻辑，等 await 内部的逻辑处理完毕后，再继续走await后面的逻辑，这个方式，其实就是 ES6 定义的 generator 函数。即 async 与 await 将标记的函数转换成了生成器。</p>
</li>
</ul>
<h3 id="手动实现一个-async-函数"><a href="#手动实现一个-async-函数" class="headerlink" title="手动实现一个 async 函数"></a>手动实现一个 async 函数</h3><p>将 函数 <code>p</code> 变成一个 generator 函数，其中遇到 await 的地方就改成 yield</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">p</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">yield</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续运行 p()，得到一个迭代器，调用  next()，我们需要手动调用这个 next 函数才会继续执行 函数p，所以我们需要一个自动执行的入口函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            next(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)(p);</span><br></pre></td></tr></table></figure>
<p>该函数会自动调用，我们执行了生成器 p 得到迭代器 gen，通过递归 next ，将 gen 自动执行到底（当 done =true 时，每次调用迭代器都会返回 <code>&#123;value: &#39;xxx&#39;, done: boolean&#125;</code> ）。</p>
<p>而当 yield 后面表达式返回 Promise 时，通过迭代器的 next 方法放到 Promise 的 then 中执行，使得 yield 后面的逻辑要等待 p1 完成后才能继续进行，即达到同步的效果。</p>
<p>可见 async/await 是通过将函数变为一个生成器函数，并使用自动执行函数来执行他，在执行过程中，有意地让生成的迭代器放到 Promise 的 then 中，即异步完成后才执行，从而达到的同步效果。</p>
<p>完整的流程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">        res(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">p</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">yield</span> p1();</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            next(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)(p);</span><br></pre></td></tr></table></figure>
<ul>
<li>首先自动执行函数，执行生成器 p 得到迭代器 gen</li>
<li>调用 next 函数，执行 gen.next，此时执行器执行到 p 函数的 yield p1()，返回了一个 Promise，该 Promise 在 1s 后打印 p1 后并返回 p2</li>
<li>在此之前，自动执行函数，在该 Promise 的回调中传入了 next 方法</li>
<li>则 1s 后，打印 p1，返回 p2，执行 next(p2)</li>
<li>迭代器继续执行 yield p1 后面的逻辑，并且把 p2 赋值给了 <code>p2</code></li>
<li>打印 p2，p3</li>
<li>async / await 的实现原比我们实现的 demo 要复杂，但是核心逻辑就是 generator 结合自动执行函数</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动技术支持实习面经</title>
    <url>/2021/04/01/1024/</url>
    <content><![CDATA[<h2 id="笔试：-3-7"><a href="#笔试：-3-7" class="headerlink" title="笔试： 3.7"></a>笔试： 3.7</h2><p><strong>T1</strong>：给定一个数组，对于数组中的每一个元素为，打印出数组中下一个更大的数，如果没有下一个更大的数，则打印-1。<br><strong>思路</strong>：单调栈。由于数据范围很小，所以暴力即可。</p>
<p><strong>T2</strong>：N 个小朋友围成一圈，你可以调整任意两个小朋友的位置。使得相邻小朋友的最大身高差的值最小。<br><strong>思路</strong>：单调栈</p>
<p><strong>T3</strong>：你现在是一名图书管理员，你可以处理两种指令。<br>指令格式如下：</p>
<ol>
<li><p><code>1 x y</code> 表示可以将图书x和图书y放在同一个书架上。</p>
</li>
<li><p><code>2 x y</code> 表示图书x和图书y不能放在同一个书架。</p>
</li>
</ol>
<p>现存在一个用户，向你提供了 $N$ 条指令。并询问这些指令的执行情况。<br>输出格式：</p>
<ol>
<li>如果所有指令，都可以正常执行，输出 YES</li>
<li>如果不能全部执行，且不能执行的 2 号指令，恰好为 3 条，请输出 3</li>
<li>请输出不能执行的指令数量</li>
</ol>
<p><strong>思路</strong>：并查集模板题，如果用数组模拟的话，数据范围很大 $10^9$ 直接就报错了。我认为改用 $unorderd_map$ 后理论上和数组是一致的，但是实际操作时忘记初始化了(我是SB)。</p>
<p><strong>T4</strong>：变态版 <a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a> (可以查看<a href="https://qybit.gitee.io/2021/03/20/72/">我的题解</a>)。</p>
<p>本题是给定不定长的字符串，要求从任意一个节点出发，经过若干次操作后可以变化的最大步长。<br><strong>思路</strong>：BFS（求最大步长），DP（DP效率似乎不怎么好，我在牛客上看的反馈还没我BFS过的多）</p>
<h2 id="一面-3-23-60mins"><a href="#一面-3-23-60mins" class="headerlink" title="一面 3.23 60mins"></a>一面 3.23 60mins</h2><ol>
<li>自我介绍</li>
<li>用过哪些集合？</li>
<li>说说 ArrayList、HashSet 和 HashMap 的常用方法。</li>
<li>你刚刚说ArrayList的底层是数组，那么我们为什么不使用数组？</li>
<li>说说ArrayList的扩容机制？具体是如何扩容的？</li>
<li>ArrayList 和 HashSet 的区别？</li>
<li>你用 HashSet 都存放过哪些数据类型？你是如何写这个自定义对象的？</li>
<li>为什么要重写 hashcode 和 equals 方法？</li>
<li>我看你用的是 MySQL，MySQL 和 Redis的区别？，说说 MySQL 的存储引擎吧？它们有什么区别？</li>
<li>你知道事务吗？说说事务的四大特性？</li>
<li>说说事务的隔离级别？</li>
<li>你都用过哪些数据类型？char 和 varchar 的区别是什么？</li>
<li>Redis有哪些数据类型？</li>
<li>说说 Spring 的事务。</li>
<li>你使用 MyBatis 是怎么写 SQL 语句的？</li>
<li>你写的 mapper 文件里都用过哪些标签，是怎么写的？</li>
<li>定义的 mapper 接口中的方法是如何执行的？</li>
<li>做题：<ol>
<li>统计数字的出现次数；</li>
<li>反转链表</li>
</ol>
</li>
<li>说说 static 和 final 关键字</li>
<li>JAVA虚拟机的内存模型是怎样的？（不是JAVA程序的运行内存模型）</li>
<li>类是如何加载的？</li>
<li>说说栈内存和堆内存，什么是栈帧？</li>
<li>假如遇到深层次的递归函数，会发生什么事情？你是如何解决的？</li>
<li>你遇到过 OOM 吗？你是如何解决的？</li>
<li>反问环节</li>
</ol>
<h2 id="二面：3-26-25mins"><a href="#二面：3-26-25mins" class="headerlink" title="二面：3.26 25mins"></a>二面：3.26 25mins</h2><ol>
<li>  自我介绍</li>
<li>介绍岗位工作职责</li>
<li>介绍项目</li>
<li>描述项目细节</li>
<li>MVC 软件架构了解吗？</li>
<li>反馈说上一面表现不错</li>
<li>做题：<ol>
<li>给定一个按钮，点击修改其内容</li>
<li>使用调试工具，比如 Postman 调用 API</li>
<li>手撕快速排序</li>
<li>反转字符串，空间 $O(1)$</li>
</ol>
</li>
<li>  如果一个网页，打开很慢的话，说说可能的原因？</li>
<li>  get 和 post 请求的区别。</li>
<li>  说说 http 和 https 的区别。</li>
<li>  说说三次握手和四次挥手。</li>
<li>  写一个 sql 语句吧，查询表中 100 个 id 大于 10 的记录。</li>
<li>  今天的面试就到这里了，你已经通过了，等 HR 电话吧。</li>
<li>  反问环节</li>
</ol>
<h2 id="HR面：3-30-20mins"><a href="#HR面：3-30-20mins" class="headerlink" title="HR面：3.30 20mins"></a>HR面：3.30 20mins</h2><ol>
<li>   HR自我介绍（我以为是技术面）</li>
<li>询问成绩</li>
<li>介绍项目</li>
<li>你为什么选择前端专业？</li>
<li>我看你是前端专业，为什么要选择后端？</li>
<li>关于在留心科技实验室当前端组长的一些问题</li>
<li>你为什么选择上海和杭州这两个城市？</li>
<li>你从出生到现在感受到最为挫折的一次经历？</li>
<li>   你未来的规划是怎么样的？</li>
<li>   你为什么选择字节跳动？你有投递其它公司吗？</li>
<li>   什么时候可以来实习？你能实习多久？</li>
<li>   同学和老师对你的评价中最多的关键词</li>
<li>   反问环节</li>
</ol>
<h2 id="已-OC：4-1"><a href="#已-OC：4-1" class="headerlink" title="已 OC：4.1"></a>已 OC：4.1</h2><p>最后是催着 HR 小姐姐给发的offer。</p>
]]></content>
      <categories>
        <category>技术交流</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
      </tags>
  </entry>
  <entry>
    <title>一文解决Tomcat开发中乱码的问题</title>
    <url>/2020/12/31/cku5fjrsn002k90v4ffhr9k8p/</url>
    <content><![CDATA[<p>开发环境：</p>
<ul>
<li>Windows 10，idea</li>
<li>tomcat 8.5.60，java8</li>
</ul>
<p>被乱码问题折磨了一上午，终于全部解决了前后端的乱码问题。</p>
<p><strong>备注</strong>：本篇仅适用于 Windows 下，使用 <code>IDEA</code> 开发 JavaWeb 项目遭遇乱码的情况。</p>
<a id="more"></a>

<p>从前端到开发环境逐步进行。</p>
<p><strong>开头</strong></p>
<p>Windows下的默认编码为 <code>GBK</code>，Linux下的默认编码为 <code>UTF-8</code>，Macbook下的默认编码为 <code>UTF-8</code>。我们的代码大部分为了兼容性，大多数都是 <code>UTF-8</code> 编码。因此在Windows下开发，难免不会遇到乱码问题。</p>
<h4 id="前端页面设置"><a href="#前端页面设置" class="headerlink" title="前端页面设置"></a>前端页面设置</h4><p>设置为 <code>UTF-8</code>, 通用编码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;text/html&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="IDE设置"><a href="#IDE设置" class="headerlink" title="IDE设置"></a>IDE设置</h4><p>先设置 <code>Tomcat</code> 启动项配置</p>
<p><img src="https://pic.downk.cc/item/5fed7d363ffa7d37b32b2d43.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-Dconsole.encoding=UTF-8</span><br></pre></td></tr></table></figure>
<p>配置完毕后，重启 <code>Tomcat</code> ，再打开页面。</p>
<p>此时应该是已经可以正常显示中文了。如果不能显示中文，那么说明你的文件本身不是 <code>UTF-8</code>。你需要修改 <code>IDE</code> 文件配置，因为 <code>IDE</code> 默认使用系统编码。</p>
<p>操作：<code>IDE -&gt; setting -&gt; file encoding</code></p>
<p><img src="https://pic.downk.cc/item/5fed7f1a3ffa7d37b32ec619.png"></p>
<p>如果页面正常显示，那就皆大欢喜。</p>
<p>然而此时在控制台输出从前端接收的数据时，控制台里仍不能正常显示中文，这是因为 <code>IDE</code> 的控制台是默认使用系统编码 <code>GBK</code>。</p>
<p>修改 <code>IDE</code> 控制台编码</p>
<p>操作：<code>IDE -&gt; setting -&gt; Console</code></p>
<p><img src="https://pic.downk.cc/item/5fed7f663ffa7d37b32f47ec.jpg"></p>
<p>此时，再控制台打印内容时。就可以正确的显示中文信息。</p>
<p>另外，如果你之前修改过 <code>Tomcat</code> 的日志信息为 <code>GBK</code>的话，此时控制台打印的 <code>Tomcat</code> 日志将会乱码，此时请将 <code>Tomcat</code> 日志信息的编码改回 <code>UTF-8</code> 即可。 目录为 <code>Tomcat安装目录/conf/logging.properties</code></p>
<p><img src="https://pic.downk.cc/item/5fed800a3ffa7d37b33065c2.jpg"></p>
<p>这样修改之后的弊端就是，在命令行模式下启动 <code>Tomcat</code> 是会乱码的。</p>
<p>Windows下应该很少人用命令行启动 <code>Tomcat</code> ，而不用 <code>IDE</code> 启动吧。（doge）</p>
<p>经过上述修改后，在 <code>IDE</code> 中，应该是不会再遇到乱码的问题了。 </p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现LinkedList</title>
    <url>/2020/11/25/cku5fjrso002n90v4clnj6e50/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>链表是与线性表相对应的一种特殊的数据结构，它的各个节点在物理内存上可以是连续的也可以是不连续的，逻辑上链表是连续的。</p>
<p><strong>优点</strong></p>
<ul>
<li>增删效率高</li>
<li>适合经常更改的应用场景</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>查询效率很低</li>
<li>不适合经常查询的应用场景</li>
</ul>
<p>优缺点是相当于线性表而言！</p>
<a id="more"></a>

<p>官方的提供的LinkedList就是链表实现的，双向链表数据结构。主要功能有，头插法，尾插法，头删除，尾删除等常用的操作。一般在应用中的体现就是，常用LinkedList来作为队列，甚至是栈等特殊需求。</p>
<h3 id="核心功能："><a href="#核心功能：" class="headerlink" title="核心功能："></a><strong>核心功能：</strong></h3><ul>
<li><code>offerFirst(val) / offerLast(val)</code></li>
<li><code>pollFirst() / pollLast()</code></li>
<li><code>peekFirst() / peekLast()</code></li>
</ul>
<h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a><strong>基本使用：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.offerLast(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">list.offerLast(<span class="number">2</span>); <span class="comment">// 1 -&gt; 2</span></span><br><span class="line"></span><br><span class="line">list.pollFirst(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">list.peekLast(); <span class="comment">// return 2</span></span><br></pre></td></tr></table></figure>
<h3 id="功能实现："><a href="#功能实现：" class="headerlink" title="功能实现："></a><strong>功能实现：</strong></h3><p>核心功能原理实现</p>
<h4 id="1、成员变量"><a href="#1、成员变量" class="headerlink" title="1、成员变量"></a>1、成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表每个节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">        val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node first; <span class="comment">// 头节点</span></span><br><span class="line">Node last; <span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">int</span> size; <span class="comment">// 链表长度</span></span><br></pre></td></tr></table></figure>
<h4 id="2、offerFirst-val"><a href="#2、offerFirst-val" class="headerlink" title="2、offerFirst(val)"></a>2、offerFirst(val)</h4><p>该方法是在链表的头节点，插入一个新的节点。</p>
<p><img src="https://pic.downk.cc/item/5fbe3b92b18d627113a1bca4.png" alt="头插入"></p>
<ul>
<li>先判断，头节点是否为空。如果为空，则说明链表此时为空。需要将首尾节点都赋值为新节点。</li>
<li>通过头节点进行操作<ul>
<li><code>newNode</code>的<code>next</code>指针指向 <code>first</code></li>
<li><code>first</code>的前驱指向 <code>newNode</code></li>
<li>再将头指针移动到<code>newNode</code></li>
</ul>
</li>
</ul>
<h3 id="3、offerLast-val"><a href="#3、offerLast-val" class="headerlink" title="3、offerLast(val)"></a>3、offerLast(val)</h3><p>该方法是在链表的尾部，加入一个新的节点。</p>
<p><img src="https://pic.downk.cc/item/5fbe3bcab18d627113a1cbf7.png"></p>
<ul>
<li>在插入时，仍需要考虑尾节点是否为空。如果为空，则说明链表此时为空。需要将首尾节点都赋值为新节点。</li>
<li>通过尾节点进行操作：<ul>
<li><code>newNode</code>的<code>prev</code>指针指向<code>last</code></li>
<li><code>last</code>的<code>next</code>指针指向<code>newNode</code></li>
<li>再将<code>last</code>指针指向<code>newNode</code></li>
</ul>
</li>
</ul>
<h3 id="4、pollLast"><a href="#4、pollLast" class="headerlink" title="4、pollLast"></a>4、pollLast</h3><p>移除链表的最后一个元素。</p>
<ul>
<li>首先会检查，链表是否为空。如果空，直接抛出异常。</li>
<li><code>last</code>指针前移，然后将<code>next</code>置为空。</li>
</ul>
<h3 id="5、pollFirst"><a href="#5、pollFirst" class="headerlink" title="5、pollFirst"></a>5、pollFirst</h3><p>移除链表的头一个元素。</p>
<ul>
<li>首先会检查，链表是否为空。如果空，直接抛出异常。</li>
<li><code>first</code>指针后移，然后将<code>prev</code>置为空。</li>
</ul>
<h3 id="6、peekLast-peekFirst"><a href="#6、peekLast-peekFirst" class="headerlink" title="6、peekLast / peekFirst"></a>6、peekLast / peekFirst</h3><p>在头尾节点不为空的情况，返回值<code>val</code>即可。</p>
<h3 id="7、get-index"><a href="#7、get-index" class="headerlink" title="7、get(index)"></a>7、get(index)</h3><p>该方法表示获取<code>index</code>位置的节点。</p>
<ul>
<li>$0 \le index &lt;= size-1$ </li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li><code>addAtIndex(index, val)</code> 表示可以在范围 $0 \le index \le size-1$ 上的任意位置之前，添加节点。</li>
<li><code>deleteAtIndex(index)</code>表示在范围$0 \le index \le size-1$上的任意位置的一个节点。</li>
</ul>
<h3 id="1、addAtIndex-index-val"><a href="#1、addAtIndex-index-val" class="headerlink" title="1、addAtIndex(index, val)"></a>1、addAtIndex(index, val)</h3><p>根据<code>index</code>进行分类讨论</p>
<ul>
<li><p>检查越界，即抛出异常。</p>
</li>
<li><p><code>index == 0</code>成立，即头插法。</p>
</li>
<li><p><code>index==size-1</code>成立，即尾插法。</p>
</li>
<li><p>在$[1, size-1)$范围上时</p>
<ul>
<li><p><img src="https://pic.downk.cc/item/5fbe419ab18d627113a3c414.png"></p>
</li>
<li><p>伪代码如下（类python代码）：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur = get(index=<span class="number">1</span>) // 索引对应的节点</span><br><span class="line">newNode = Node(val)</span><br><span class="line">// 对应序号<span class="number">1</span></span><br><span class="line">prev = cur.prev	// 前驱节点</span><br><span class="line">prev.<span class="built_in">next</span> = newNode</span><br><span class="line">// 对应序号<span class="number">2</span></span><br><span class="line">prev.<span class="built_in">next</span> = newNode</span><br><span class="line">newNode.prev = prev</span><br><span class="line">// 对应序号<span class="number">3</span></span><br><span class="line">newNode.<span class="built_in">next</span> = cur</span><br><span class="line">cur.prev = newNode</span><br><span class="line">size += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  ​    </p>
</li>
</ul>
</li>
</ul>
<h3 id="2、deleteAtIndex-index"><a href="#2、deleteAtIndex-index" class="headerlink" title="2、deleteAtIndex(index)"></a>2、deleteAtIndex(index)</h3><p>同样的根据<code>index</code>进行讨论：</p>
<ul>
<li><p>越界检查，如果越界抛出异常。</p>
</li>
<li><p><code>index==0</code>移除头节点</p>
</li>
<li><p><code>index==size-1</code>移除尾节点</p>
</li>
<li><p>在$[1, size-1)$时</p>
<ul>
<li><p><img src="https://pic.downk.cc/item/5fbe4403b18d627113a47233.png"></p>
</li>
<li><p>伪代码：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur = get(index=<span class="number">1</span>)</span><br><span class="line">// 获得前驱节点和后继节点</span><br><span class="line">prev = cur.prev</span><br><span class="line"><span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">// 前驱节点的后继指向后继的后继</span><br><span class="line">// 后继节点的前驱指向前驱的前驱</span><br><span class="line">prev.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="built_in">next</span>.prev = prev</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qybit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line">        Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            val = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node first;</span><br><span class="line">    Node last;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index [0, size-1]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回index处节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;the index out of the limited&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node(index).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果index &gt; size/2的话，此时从尾部开始搜索</span></span><br><span class="line"><span class="comment">     * 否则就从头部开始搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index [0, size]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从尾部开始搜索</span></span><br><span class="line">        Node x;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">                x = x.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                x = x.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在头部插入值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 待插入的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offerFirst</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(val);</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = first;</span><br><span class="line">            first.prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        first = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在尾部插入值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 待插入的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offerLast</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(val);</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = node;</span><br><span class="line">            node.prev = last;</span><br><span class="line">        &#125;</span><br><span class="line">        last = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在任意索引之前，加入节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index [0, size-1] 范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val   待插入节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;the index out of the limited&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            offerFirst(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            offerLast(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [1, size-1]</span></span><br><span class="line">        Node origin = node(index);</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(val);</span><br><span class="line">        Node prev = origin.prev;</span><br><span class="line">        origin.prev = node;</span><br><span class="line">        node.next = origin;</span><br><span class="line">        prev.next = node;</span><br><span class="line">        node.prev = prev;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定范围内的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 范围[0, size-1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;the index out of the limited&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            removeHead();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == size - <span class="number">1</span>) &#123;</span><br><span class="line">            removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [1, size-1]</span></span><br><span class="line">        Node node = node(index);</span><br><span class="line">        Node prev = node.prev;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将该节点置空</span></span><br><span class="line">        node.val = -<span class="number">1</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除尾部节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node l = last;</span><br><span class="line">        Node prev = l.prev;</span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除头部节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node f = first;</span><br><span class="line">        Node next = f.next;</span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>wheel</tag>
      </tags>
  </entry>
  <entry>
    <title>第 232 场周赛</title>
    <url>/2021/03/15/w232/</url>
    <content><![CDATA[<p>题目清单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/">仅执行一次字符串交换能否使两个字符串相等</a></li>
<li> <a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">找出星型图的中心节点</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li>
</ul>
<h1 id="T1：仅执行一次字符串交换能否使两个字符串相等"><a href="#T1：仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="T1：仅执行一次字符串交换能否使两个字符串相等"></a>T1：<a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/">仅执行一次字符串交换能否使两个字符串相等</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于数据范围比较小，$1 \le s1.length, s2.length \le 100$，我们可以直接暴力的枚举字符串 $s1$ 或者 字符串 $s2$ 的交换字符的下标，然后再判断是否相等即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAlmostEqual</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="keyword">if</span> (s2.size() != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                swap(s1[i], s1[j]);</span><br><span class="line">                <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                swap(s1[i], s1[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^3)$ ，其中 $N$ 为字符串 $s1$ 或者 $s2$ 的长度。</p>
<ul>
<li>字符串的下标交换方式一共存在 $N^2$ 种，我们每一次交换都需要判断字符串 $s1$ 和 $s2$ 是否相等。</li>
<li>判断字符串是否相等，只能遍历两字符串。因此时间复杂度一共为 $O(N^3)$。</li>
</ul>
<p>空间复杂度：$O(1)$</p>
<h1 id="T2：找出星型图的中心节点"><a href="#T2：找出星型图的中心节点" class="headerlink" title="T2：找出星型图的中心节点"></a>T2：<a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">找出星型图的中心节点</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一：dfs"><a href="#方法一：dfs" class="headerlink" title="方法一：dfs"></a>方法一：dfs</h3><p>直接对给定的边，建图进行 dfs，遍历。</p>
<p>从某一个节点出发，找到一个可以到达所有的节点的点。</p>
<p>时间复杂度为 $O(N^2)$，空间复杂度为 $O(N^2)$</p>
<h3 id="方法二：建图优化"><a href="#方法二：建图优化" class="headerlink" title="方法二：建图优化"></a>方法二：建图优化</h3><p>我们不必去写繁杂的 dfs 代码，建图的过程中我们可以选择 <strong>邻接矩阵</strong>，存储图。然后遍历每一行，判断该行与其他列，是否都存在边。</p>
<p>时间复杂度为 $O(N^2)$，空间复杂度为 $O(N^2)$</p>
<h3 id="方法三：统计每个点的度数"><a href="#方法三：统计每个点的度数" class="headerlink" title="方法三：统计每个点的度数"></a>方法三：统计每个点的度数</h3><p>我们甚至都不必去存储所有的图的节点信息，我们可以注意到<strong>星型图</strong>的中心节点，是与所有的点都存在边，当我们找到<strong>某个点的度数等于边数</strong>时，即表示该点为中心节点。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCenter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.size() + <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deg</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>];</span><br><span class="line">            deg[a] ++, deg[b] ++;</span><br><span class="line">            <span class="keyword">if</span> (deg[a] == n) <span class="keyword">return</span> a;</span><br><span class="line">            <span class="keyword">if</span> (deg[b] == n) <span class="keyword">return</span> b; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == edges.size()) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N)$，其中 $N$ 为点的数量。</p>
<p>空间复杂度：$O(N)$。</p>
<h1 id="T3：最大平均通过率"><a href="#T3：最大平均通过率" class="headerlink" title="T3：最大平均通过率"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></h1><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>对于某一个班级 $calsses[i] = [x_i, y_i]$ 而言，其原本的通过率为 $\frac{x}{y}$。那么我们加入一个保证能够过线学生后，存在<br>$$<br>\theta =  \frac{x + 1}{y + 1} - \frac{x}{y}，\theta (0 \lt \theta \lt1) \ 表示添加学生后，通过率增长幅度<br>$$<br>当我们在该班级继续加入学生后，存在<br>$$<br>\theta_1 = \frac{x_2 + 1}{y_2 + 1} - \frac{x_1}{y_1}， \<br>\theta_2 = \frac{x_4 + 1}{y_4 + 1} - \frac{x_3}{y_3}， \<br>\theta_2 \gt \theta_1<br>$$<br>即班级的通过率是单调递增的。</p>
<p>当某个班级的通过率呈现最大化后，即表示所有班级的平均通过率最大。</p>
<p>贪心的体现为：</p>
<p>当所有的班级都呈现通过率 $\theta$ 单调递增时，假设我们现在将一个学生加入班级，那么我们需要在 $N$ 个班级中，快速选择出一个 $\theta$ 最大的班级(借助堆优化)。这样就可以使所有班级的平均通过率最大。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> w;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((x + <span class="number">1.0</span>) / (y + <span class="number">1.0</span>)) - ((<span class="keyword">double</span>)x / y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Node&gt; heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : classes) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[<span class="number">0</span>], y = c[<span class="number">1</span>];</span><br><span class="line">            ans += (<span class="keyword">double</span>)x / y;</span><br><span class="line">            heap.push(&#123;cal(x, y), x, y&#125;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (extraStudents --) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            ans += t.w;</span><br><span class="line">            <span class="keyword">int</span> x = t.a + <span class="number">1</span>, y = t.b + <span class="number">1</span>;</span><br><span class="line">            heap.push(&#123;cal(x, y), x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / classes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N logN)$，其中 $N$ 表示为额外添加的学生数量。</p>
<ul>
<li>我们需要预处理所有的班级，计算出最初始的增长幅度，然后加入到 <strong>堆</strong> 中维护。时间复杂度 $O(NlogN)$</li>
<li>我们要把这些额外的学生，分别都加入到 <strong>堆顶</strong> 的第一个班级里去，并且重新计算增长幅度。时间复杂度 $O(NlogN)$</li>
</ul>
<p>空间复杂度：$O(N)$，我们使用结构体存储班级，并维护额外的信息。</p>
<h1 id="T4：好子数组的最大分数"><a href="#T4：好子数组的最大分数" class="headerlink" title="T4：好子数组的最大分数"></a>T4：<a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/">好子数组的最大分数</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h2 id="方法二：双指针-贪心"><a href="#方法二：双指针-贪心" class="headerlink" title="方法二：双指针 + 贪心"></a>方法二：双指针 + 贪心</h2><p>子数组的定义为： $min{ nums[i], nums[i+1],…,nums[j]} \times (j - i + 1)$。且满足 $i \le k \le j$。</p>
<p>算法实现流程：</p>
<ul>
<li>我们直接以下标 $k$ 为可能区间 $[i, j]$ 的中心点，然后分别以指针 $left$, 指令 $right$ 左右扩展<ul>
<li>当 $ left &gt;= 0 \ 时 \ nums[k] \le nums[left]$，指针 $left$ 恒向左扫描。</li>
<li>当 $right &lt; n \ 时 \ nums[k] \le nums[right]$，指针 $right$ 恒向右扫描。</li>
<li>当 指针 $left \lt 0 \ 且 \ right \gt n$ 时，表示我们已经扫描完整个数组。</li>
<li>当 $left \ge 0 \ 且 \ right \lt n$ ， 表示我们还未扩展到边界，为了求得最大值，我们以左右边界中任意一个最大值，作为中心点继续扩展。</li>
<li>当 $left \lt 0$ ，表示左边界已经没有元素，将右边界定义为中心点。</li>
<li>当 $right \ge n$ ，表示右边界已经没有元素，同理。</li>
<li>我们循环上述操作，直至在数组中找到一个最小值，然后扩展至整个数组后退出。</li>
</ul>
</li>
</ul>
<p>贪心的体现：</p>
<p>当我们扫描到边界值时 (且满足 $left \ge 0 \ 或 \ right \lt n$)，我们会在左右边界选择一个最大值，作为新区间的中心点。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = k, r = k, mi = nums[k];</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; nums[r] &gt;= nums[k]) r ++;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l] &gt;= nums[k]) l --;</span><br><span class="line">            ans = max(ans, (r - l - <span class="number">1</span>) * nums[k]);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span> &amp;&amp; r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n) nums[k] = max(nums[l], nums[r]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">0</span>) nums[k] = nums[r];</span><br><span class="line">            <span class="keyword">else</span> nums[k] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p>
<ul>
<li>对于数组中的元素任意一个元素，我们在最坏的情况下，都不会访问达到 $N$ 次。</li>
</ul>
<p>空间复杂度：$O(1)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>图</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>第 234 场周赛</title>
    <url>/2021/04/03/259/</url>
    <content><![CDATA[<p>题目清单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></li>
<li> <a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></li>
<li> <a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></li>
</ul>
<p>换电脑(原来的破电脑显示屏不亮了。)导致题解丢失，这是重写的一份。┭┮﹏┭┮</p>
<h1 id="T1：字符串中不同整数的数目"><a href="#T1：字符串中不同整数的数目" class="headerlink" title="T1：字符串中不同整数的数目"></a>T1：<a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接模拟截取数字部分即可，注意前导 $0$ 。</p>
<p>不可以转成数字 $int$ 或者 $long$ 等 64 位的整形数字，可能会爆掉。因此直接使用字符串即可。</p>
<p>$Go$ 语言中并不存在 $Set$ 集合，因此我们在使用 $Map$ 时，给 $Value$ 随便赋一个值即可。这里取得 $0x3f3f3f3f$ 意义为“无限大”。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isDigit</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDifferentIntegers</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    st := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> isDigit(word[i]) &#123;</span><br><span class="line">            <span class="keyword">var</span> num []<span class="keyword">byte</span></span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; word[i] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i &lt; n &amp;&amp; isDigit(word[i]) &#123;</span><br><span class="line">                num = <span class="built_in">append</span>(num, word[i])</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            st[<span class="keyword">string</span>(num)] = INF</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(st)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。我们只会扫描一次字符串。</p>
<p>空间复杂度：$O(\sum)$ ，其中 $\sum$ 表示数字集的大小。</p>
<h1 id="T2：还原排列的最少操作步数"><a href="#T2：还原排列的最少操作步数" class="headerlink" title="T2：还原排列的最少操作步数"></a>T2：<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>纯模拟题</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reinitializePermutation</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    perm := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        perm[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> flag <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> flag &#123;</span><br><span class="line">        ans ++</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                arr[i] = perm[i / <span class="number">2</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i] = perm[n / <span class="number">2</span> + (i - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(arr) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">            perm[i] = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(k \times N)$ ，其中 $k$ 为最小执行次数，$N$ 为数组的长度。</p>
<p>空间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p>
<h1 id="T3：替换字符串中的括号内容"><a href="#T3：替换字符串中的括号内容" class="headerlink" title="T3：替换字符串中的括号内容"></a>T3：<a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不存在嵌套的括号，因此我们可以直接遍历字符串当遇到一个 $()$ 时，截取 $()$ 内的内容，然后到 $knowledge$ 数组里找到对应的 $Value$ 即可。</p>
<p>直接在 $knowledge$ 里查找 $Value$ 的时间复杂度是 $O(N)$ 的，$N$ 为 $knowledge$ 数组的长度。因此，我们可以要尽可能的优化这一步的时间复杂度操作。</p>
<p>不难想到使用 哈希表 来实现 $O(1)$ 查找。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(s <span class="keyword">string</span>, knowledge [][]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, kn := <span class="keyword">range</span>(knowledge) &#123;</span><br><span class="line">        hash[kn[<span class="number">0</span>]] = kn[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> i, n <span class="keyword">int</span> = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> j <span class="keyword">int</span> = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j &lt; n &amp;&amp; s[j] != <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">                j ++</span><br><span class="line">            &#125;</span><br><span class="line">            k := s[i + <span class="number">1</span>:j]</span><br><span class="line">            <span class="keyword">if</span> key, ok := hash[k]; ok &#123;</span><br><span class="line">                ans += key</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="string">&quot;?&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += <span class="keyword">string</span>(s[i])</span><br><span class="line">            i ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。</p>
<p>空间复杂度：$O(N)$，其中 $N$ 为 $knowledge$ 数组的长度。</p>
<h1 id="T4：好因子的最大数目"><a href="#T4：好因子的最大数目" class="headerlink" title="T4：好因子的最大数目"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></h1><p>非常复杂的一道题，了解结论的话很容易做。</p>
<h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>我们需要构造一个数 $x$ ，它的质因子数量最大不会超过 $primeFactors$ 个。</p>
<p>好因子：我们必须从这个数 $x$ 的 $n$ 个不同质因子 $a_i(1 \le i \le n)$，并假设其数量分别对应为 $b_i(1 \le i \le n)$。</p>
<p>举例子：比如当 $x = 200$，$primeFactors = 5$ 时，</p>
<p>存在一个满足的条件的质因子数组：$[2,2,2,5,5]$ ，其中质因子一共有两种，分别是 $a_1=2$ 和 $a_2=5$ ，它们的数量分别为 $b_1=3$ 和 $b_2=2$。</p>
<p>根据题目定义，我们在构造<strong>好因子</strong>的过程中，对于每一个质因子 $a_i$ 就必须选择 $b_i$ 个。</p>
<p>对于质因子 $a_1=2$ 而言，我们必须要拿 $1 \le b_1 \le 3$ 个，对于质因子 $a_2=5$ 也是同理 $1 \le b_2 \le 2$。 </p>
<p>我们开始构造<strong>好因子</strong>：</p>
<p>$b_1= 1, b_2=1$ 时，好因子数量：$[10]$</p>
<p>$b_1=2, b_2=1$ 时，好因子数量：$[10,20]$</p>
<p>$….$</p>
<p>注意到，当 $b_1 = 3$ 和 $b_2 = 2$ ，我们可以构造出 $b_1 \times b_2 =6$ 个好因子。分别为 $[10, 20,40,50,100,200]$ 。</p>
<h3 id="整理一下"><a href="#整理一下" class="headerlink" title="整理一下"></a>整理一下</h3><p>对于 $n$ 个质因子 $a_i$ 及其数量 $b_i$：<br>$$<br>a_1, \ a_2, \ a_3, \ a_4, \ …, \ a_n<br>$$<br>对于质因子的数量 $b_i$：<br>$$<br>b_1 + b_2 + b_3 + b_4 + … + b_n = primeFactors<br>$$</p>
<p>对于 $x$ ：<br>$$<br>a_1^{b_1} \times a_2^ {b_2} \times a_3^{b_3} \times…\times a_n^{b^n} = x<br>$$<br>对于最大的 <strong>好因子</strong> 数量：<br>$$<br>b_1 \times b_2 \times b_3 \times … \times b_n = ans<br>$$</p>
<p>我们可以得出一个结论：<strong>把一个数分出更多的质因子数量，使得它们数量的乘积尽可能的大，这样我们就可以构造出更多的好因子。</strong></p>
<p>此时，请思考一个问题？</p>
<blockquote>
<p>我们应该选择哪一个 质因子 才可以使一个数划分出更多份？</p>
</blockquote>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p><strong>函数极值证明法</strong></p>
<p>我们假设 $f(x)$ 为一个正整数 $n$ 按照 $x$ 划分时的最大乘积，则有 $x$ 项  $\frac{n}{x}$。即 $f(x) = x ^\frac{n}{x}$。</p>
<p>目标是求 $f(x)$ 的最大值，我们可以将式子变形一下：<br>$$<br>f(x) = x^\frac{n}{x} = e^{\frac{n \times lnx}{x}}<br>$$<br>令 $g(t) = e ^t$ ，$h(x) = \frac{lnx}{n}$ ，那么 $f(x) = g(n \times h(x))$，由于 $g(t)$ 是单调递增的，$n \gt 0$，所以 $f(x)$ 与 $h(x)$ 单调性相同。</p>
<p>我们计算 $h(x)$ 的驻点，$h’(x) = \frac{1 - lnx}{x^2} = 0$，得到 $x = e$ 。</p>
<p>得到驻点 $x = e$，当 $0 \lt x \lt e$ 时， $h’(x) \gt 0$ ，所以在 $0 \lt x \lt e$ 时，$h(x)$ 是单调递增的。</p>
<p>当 $x \gt e$ 时，$h’(x) \lt 0$ ，所以在 $x \gt e$ 时，$h(x)$是单调递减的。由此可知 $x = e$ 为 $h(x)$ 和 $f(x)$ 的极大值点。由于 $f(x)$ 在定义域连续，因此 $x =e $ 为 $f(x)$ 的最大值点。</p>
<p>那么， $e = 2.71…$ 并不是一个正整数，因此我们还需要比较 $f(2)$ 和 $f(3)$ 的大小，直接计算 $f(2) / f(3)$ 的值即可。<br>$$<br>\frac{f(2)}{f(3)} = \frac{e^{\frac{nln2}{2}}}{e^{\frac{nln3}{3}}} = e ^ {\frac{nln2}{2} - \frac{nln3}{3}} = e ^ \frac{n \times ln8-ln9}{6}<br>$$<br>由于 $ln8 \lt ln9$，$n &gt; 0$ ，所以 $f(2) \lt f(3)$ 。因此当 $x = 3$ 时，$f(x)$ 可以取得最大值。</p>
<p>上述过程为正整数 $n$ 可以整除 $3$ 时，当不够整除时，我们还需要用 $2$ 来凑。</p>
<p>因此，我们对于 $n$ 和 $3$ 的余数进行讨论：</p>
<ul>
<li>当余数为0时，即$n = 3m (m \ge 2)$，将 $n$ 拆分成 $m$ 个 $3$</li>
<li>当余数为1时，即$n = 3m+1 (m \ge 1)$ ，由于$2\times2 \gt 3 \times 1$，所以将 $n$ 拆分成 $m - 1$ 个 $3$ 和 $2$ 个 $2$</li>
<li>当余数为2时，即$n=3m+2(m \ge 1)$，将 $n$ 拆分成 $m$ 个 $3$ 和 $1$ 个 $2$</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>上述证明，我们以及得知当一个正整数 $x$ 按照 $3$ 拆分，然后补充 $2$ 时，可以使得其数量的乘积最大。也就是可以构造更多的好因子数量。</p>
<p>那么，对于本题已经给出了质因子的数量，我们反向冲一下，就可以求出最大值 $x$ ，也就是本题的答案。</p>
<p>注意由于 $n$ 的范围相当的大，因此在快速幂的过程中需要边取模边运算，否则会爆数据范围。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_pow</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> y &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ret *= x</span><br><span class="line">            ret %= MOD</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x</span><br><span class="line">        x %= MOD</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % MOD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxNiceDivisors</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m, quot <span class="keyword">int</span> = n / <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> quot == <span class="number">0</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> quot == <span class="number">1</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = quick_pow(<span class="number">3</span>, m) * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(lgN)$，其中 $N$ 最大为 $10^9$ 。</p>
<p>空间复杂度：$O(1)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>第 235 场周赛</title>
    <url>/2021/04/05/259/</url>
    <content><![CDATA[<p>题目清单：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></li>
<li><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></li>
<li> <a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></li>
</ul>
<h1 id="T1：截断句子"><a href="#T1：截断句子" class="headerlink" title="T1：截断句子"></a>T1：<a href="https://leetcode-cn.com/problems/truncate-sentence/">截断句子</a></h1><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不同单词之间是按照空格隔开的，因此我们统计空格数量即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">truncateSentence</span><span class="params">(s <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cnt <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            cnt ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == k &#123;</span><br><span class="line">            <span class="keyword">return</span> s[:i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(\sum)$，其中 $\sum$ 为前 $k$ 个单词的长度。</p>
<p>空间复杂度：$O(1)$，我们只使用了常数的空间</p>
<h1 id="T2：查找用户活跃分钟数"><a href="#T2：查找用户活跃分钟数" class="headerlink" title="T2：查找用户活跃分钟数"></a>T2：<a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></h1><p>典型的阅读理解</p>
<h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先看看我们要返回的答案到底是什么。</p>
<p>$answer[j] (1 \le j \le k )$ 表示 <strong>用户活跃分钟数</strong>  等于 $j$ 的用户数。老谜语人了，其实说白了就是：<strong>一个用户总共的活跃分钟数恰好等于 $j$ 的人数</strong>。</p>
<p>另外，一个用户在同一个分钟可以活跃多次，也就是说我们还要处理去重。</p>
<p>我们的解决方法很简单，使用 哈希表 即可实现去重。</p>
<p>那么，还存在一个问题，如何知道一个用户一共活跃了多少次呢？</p>
<p>我们仍然可以使用 哈希表 来实现，那么这就是一个嵌套的 哈希表 结构，如果不熟练这样的写法的话，说明基础语法还有待加强。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INF <span class="keyword">int</span> = <span class="number">0x3f3f3f3f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findingUsersActiveMinutes</span><span class="params">(logs [][]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, log := <span class="keyword">range</span>(logs) &#123;</span><br><span class="line">        id, time := log[<span class="number">0</span>], log[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> _, ok := count[id]; !ok &#123;</span><br><span class="line">            count[id] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        count[id][time] = INF </span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> _, cnt := <span class="keyword">range</span>(count) &#123;</span><br><span class="line">        ans[<span class="built_in">len</span>(cnt) - <span class="number">1</span>] ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p>
<ul>
<li>我们会遍历一次数组，收集所有用户的活跃信息</li>
<li>我们还会遍历一次哈希表，这个取决于存在的用户数量，用户数量最大不会超过数组长度。</li>
<li>因此我们的最终时间复杂度为 $O(2\times N) = O(N)$</li>
</ul>
<p>空间复杂度：$O(N)$，我们会存储所有用户的信息</p>
<h1 id="T3：绝对差值和"><a href="#T3：绝对差值和" class="headerlink" title="T3：绝对差值和"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">绝对差值和</a></h1><h2 id="方法一：排序-二分查找"><a href="#方法一：排序-二分查找" class="headerlink" title="方法一：排序 + 二分查找"></a>方法一：排序 + 二分查找</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目定义：</p>
<p>绝对差值和：$\sum_{i=0}^n |nums1[i] - nums2[i]|$</p>
<p>再搞清楚我们的目的：我们可以选用 $nums1$ 中的任意一个元素替换 $nums1$ 中的至多一个元素，使得绝对值差和最小化。</p>
<p>具体做法：</p>
<ol>
<li>我们可以预先计算好未 <strong>替换</strong> 元素前的绝对值差</li>
<li>尝试 <strong>替换</strong> 操作，我们在 $nums1$ 中找到一个<strong>最逼近</strong> $nums2[i]$ 的一个元素<ol>
<li>快速查找的话，我们可以想到二分查找，因此需要对 $nums1$ 进行排序操作</li>
<li>对于 $nums2$ 中的每一个元素，都尝试查找元素值相近的一个下标 $p$</li>
<li>替换完毕后，计算 $nums1[p] - nums2[i]$ 的最小值，这样可以说明两个元素很相近</li>
<li>再计算出偏移量 $shrink$ ，使得 $shrink$ 的值最大化，这样可以使得 绝对值差和 最小。</li>
</ol>
</li>
<li>我们第一步已经计算好了 <strong>未替换</strong> 元素的绝对值差，第二步我们模拟了 <strong>替换</strong> 操作后，找出了偏移量最大的替换方案，直接减去即可。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>值得注意的是，在 $Go$ 中 $int$ 默认是 $64$ 位的，因此其他语言在实现的过程中，建议使用 $64$ 位的整型变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD <span class="keyword">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="built_in">len</span>(nums1)</span><br><span class="line">    cnt := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">var</span> ans, shrink <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cnt[i] = abs(nums1[i] - nums2[i])</span><br><span class="line">        ans += cnt[i]</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(nums1)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        cost := cnt[i]</span><br><span class="line">        <span class="keyword">var</span> delta <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// p 是nums1中对应元素大于等于 nums2[i] 的一个下标</span></span><br><span class="line">        p := lowerBound(nums1, nums2[i])</span><br><span class="line">        <span class="comment">// fmt.Println(p)</span></span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 可能越界。</span></span><br><span class="line">            <span class="keyword">if</span> p == n &#123;</span><br><span class="line">                p --</span><br><span class="line">            &#125;</span><br><span class="line">            delta = min(abs(nums1[p] - nums2[i]), abs(nums1[p - <span class="number">1</span>] - nums2[i])) </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delta = abs(nums1[p] - nums2[i])</span><br><span class="line">        &#125;</span><br><span class="line">        shrink = max(shrink, abs(cost - delta))</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= shrink</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找出大于等于 x 的下标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= x &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p>
<ul>
<li>我们遍历一次数组预计算出未替换前的绝对值差和，时间复杂度 $O(N)$</li>
<li>对数组进行排序操作，$Go$ 实现的排序为快速排序时间复杂度为 $O(NlgN)$</li>
<li>我们会遍历 $nums2$ 数组，对于$nums2$ 数组中的任意一个元素都尝试去 $nums1$ 中找出一个最逼近的元素，二分查找的时间复杂度为 $O(lgN)$，因此总的时间复杂度为 $O(NlgN)$</li>
</ul>
<p>空间复杂度：$O(N)$，我们要存储未替换前的绝对值差。</p>
<h1 id="T4：序列中不同最大公约数的数目"><a href="#T4：序列中不同最大公约数的数目" class="headerlink" title="T4：序列中不同最大公约数的数目"></a>T4：<a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></h1><h2 id="方法一：数学"><a href="#方法一：数学" class="headerlink" title="方法一：数学"></a>方法一：数学</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们不必去找这个子序列，然后计算出最大公约数 $g$，我们直接枚举最大公约数 $g$ 去构造这个子序列。</p>
<p>假设一个数组存在最大公约数 $g$ ，那么数组中的任意一个元素都是最大公约数 $g$ 的倍数。</p>
<p>我们在构造这个子序列的过程中，选择的最大公约数 $g$ 的倍数必须存在于数组中，否则就不能称之为子序列。</p>
<p>具体做法：</p>
<ul>
<li>首先确定最大公约数 $g$ 的范围，设 $m$ 为数组 $nums$ 的最大值。那么 $1 \le g \le m$</li>
<li>我们假设最大公约数 $x (1 \le x \le m)$ ，然后枚举出所有不大于 $m$ 且存在与数组 $nums$ 中的所有 $x$ 的倍数 $y$ 。当且仅当所有 $y$ 的最大公约数等于 $x$ 时，说明我们找到一个可行的 子序列。</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> vis []<span class="keyword">bool</span> = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> y := x; y &lt;= m; y += x &#123;</span><br><span class="line">        <span class="keyword">if</span> vis[y] &#123;</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span> &#123;</span><br><span class="line">                t = y</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = gcd(t, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 全局遍历存在干扰，使用之前必须重置</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    vis = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">200005</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span>(nums) &#123;</span><br><span class="line">        m = max(m, v)</span><br><span class="line">        vis[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> check(i) &#123;</span><br><span class="line">            ans ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n^2)$，其中 $n$ 为数组 $nums$ 中的最大值。</p>
<p>空间复杂度：$O(n)$，其中 $n$ 为数组 $nums$ 中的最大值。</p>
]]></content>
      <categories>
        <category>周赛</category>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>第 236 场周赛</title>
    <url>/2021/04/12/w236/</url>
    <content><![CDATA[<p>题目清单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></li>
<li> <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></li>
<li> <a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></li>
<li> <a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></li>
</ul>
<h1 id="T1：数组元素积的符号"><a href="#T1：数组元素积的符号" class="headerlink" title="T1：数组元素积的符号"></a>T1：<a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力即可，但是不建议直接对数组进行乘法操作，可能会爆 $int$ 甚至是 $64$ 位的整形。</p>
<p>我们只需要统计 负数 的存在个数即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySign</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mask := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            mask ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mask % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。我们至多只会对数组扫描一遍。</p>
<p>空间复杂度：$O(1)$</p>
<h1 id="T2：找出游戏的获胜者"><a href="#T2：找出游戏的获胜者" class="headerlink" title="T2：找出游戏的获胜者"></a>T2：<a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一个裸的约瑟夫环问题。由于数据范围不大，所以直接模拟也是可行的</p>
<p>具体证明本文不再赘述，请参考博客：<a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环问题公式推导</a></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheWinner</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = (p + k) % i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为小伙伴的数量。</p>
<p>空间复杂度：$O(1)$</p>
<h1 id="T3：最少侧跳次数"><a href="#T3：最少侧跳次数" class="headerlink" title="T3：最少侧跳次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-sideway-jumps/">最少侧跳次数</a></h1><h2 id="方法一：BFS-求最短路"><a href="#方法一：BFS-求最短路" class="headerlink" title="方法一：BFS 求最短路"></a>方法一：BFS 求最短路</h2><h3 id="问题转换"><a href="#问题转换" class="headerlink" title="问题转换"></a>问题转换</h3><p>我们可以把赛道想象成一个 $3 \times n$ 的一个矩阵，我们从 $(2, 0)$ 点出发，问到达最后一列所需要的最短步长？</p>
<p>当然，我们这里的步长是指到达当前点 $(x, y)$ 时，我们跳跃的最小步数。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们在每次选择下一次的 ”落脚点“ 时，总是贪心的选择最少跳跃次数的点。因此，我们可以当作一个迪杰斯特拉的最短路算法。</p>
<p>注意点：我们在构建矩阵时，为了更好的判断障碍物，我们将会构建 $4 \times n$ 的矩阵。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, x, y;</span><br><span class="line">    <span class="comment">// 重载运算符 &lt;，表示构建小根堆。每次弹出堆的都是 d 最小的一个</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pos&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; p.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSideJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Pos&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> col = obstacles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> d = p.d;</span><br><span class="line">            <span class="comment">// 到达最后一列</span></span><br><span class="line">            <span class="keyword">if</span> (p.y == col - <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p.x + dx[i], y = p.y + dy[i];</span><br><span class="line">                <span class="comment">// 越界检查</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 下一个点是障碍物</span></span><br><span class="line">                <span class="keyword">if</span> (obstacles[y] == x) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dx[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果跳了，就消耗一步</span></span><br><span class="line">                    cost = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d + cost &lt; dist[x][y]) &#123;</span><br><span class="line">                    dist[x][y] = d + cost;</span><br><span class="line">                    pq.push(&#123;dist[x][y], x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(4 \times N)$，其中 $N$ 为障碍物的长度。</p>
<ul>
<li>我们在最坏的情况下，可能要对整个矩阵进行扫描。</li>
</ul>
<p>空间复杂度：$O(4 \times N)$，我们需要存储所有可能的点。</p>
<h1 id="T4：求出-MK-平均值"><a href="#T4：求出-MK-平均值" class="headerlink" title="T4：求出 MK 平均值"></a>T4：<a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>$Python$ 可以偷税暴力过</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, m: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.m = m</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addElement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.nums.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMKAverage</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &lt; self.m:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        last = self.nums[-self.m :]</span><br><span class="line">        last.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(mean(last[self.k : -self.k]))</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^2)$，其中 $calculateMKAverage$ 方法会调用 $10^5$ 次。每一次操作的数组最大长度也是 $10^5$。因此时间复杂度为 $O(N^2)$</p>
<p>空间复杂度：$O(N)$，我们要存储原数组和临时数组。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>BFS</tag>
        <tag>DP</tag>
        <tag>设计</tag>
        <tag>堆</tag>
        <tag>数学</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>第 237 场周赛</title>
    <url>/2021/04/19/w237/</url>
    <content><![CDATA[<p>题目清单：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/"> 判断句子是否为全字母句</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></li>
<li> <a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></li>
<li> <a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></li>
</ul>
<h1 id="T1：判断句子是否为全字母句"><a href="#T1：判断句子是否为全字母句" class="headerlink" title="T1：判断句子是否为全字母句"></a>T1：<a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>全字母句就是一个字符串包含字母表中的 $26$ 个字母。我们只需要开一个 $26$ 长度的数组记录一下字母的出现次数即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfPangram</span><span class="params">(<span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : sentence) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : f) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度，我们需要扫描一遍字符串。</p>
<p>空间复杂度：$O(1)$。这里我们只使用了常数级别的数组空间。</p>
<h1 id="T2：雪糕的最大数量"><a href="#T2：雪糕的最大数量" class="headerlink" title="T2：雪糕的最大数量"></a>T2：<a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们的现金是固定的，而且我们可以按照任意的顺序去购买雪糕。</p>
<p>而且我们可以选择的仅有 $n$ 支雪糕，对于第 $i$ 支雪糕，我们要尽可能的选择定价更小的雪糕。只有我们每次都选择定价更小的雪糕，这样才可以买更多的雪糕。</p>
<p>所以我们可以对雪糕的定价进行排序，使得我们每次选择价格较小的雪糕。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        sort(costs.begin(), costs.end());</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cost : costs) &#123;</span><br><span class="line">            s += cost;</span><br><span class="line">            <span class="keyword">if</span> (s &lt;= coins) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 为数组的长度。</p>
<p>空间复杂度：$O(1)$。</p>
<h1 id="T3：单线程-CPU"><a href="#T3：单线程-CPU" class="headerlink" title="T3：单线程 CPU"></a>T3：<a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</p>
<ul>
<li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态</li>
<li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 <strong>执行时间最短</strong> 的任务开始执行。</li>
<li>如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li>
<li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li>
<li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li>
</ul>
<p>具体实现：</p>
<ul>
<li>我们需要自定义一个数据结构来增强 $Task$，增加一个数组的下标</li>
<li>对于 $Task$ 数组，我们需要找出最早入队执行的任务，因此对 $Task$ 数组按照入队时间排序</li>
<li>我们还需要一个数据结构来模拟 CPU，可以使用 堆 实现<ul>
<li>对于堆中的任务，我们总是选择执行时间最短的任务开始执行</li>
<li>如果有多个执行时间相同的任务，我们选择下标最小的任务</li>
</ul>
</li>
<li>当 CPU空闲 / 堆为空 时，直接把开始执行小于等于时间戳的任务顺序入队</li>
<li>每次都执行一个任务，统计时间戳的累计时间</li>
<li>当我们把任务都入队时，即表示 CPU 可以按照顺序把任务执行完毕</li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> ep;</span><br><span class="line">        <span class="keyword">int</span> pt;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            id = a;</span><br><span class="line">            ep = b;</span><br><span class="line">            pt = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getOrder(<span class="keyword">int</span>[][] t) &#123;</span><br><span class="line">        List&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = t.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> Task(i, t[i][<span class="number">0</span>], t[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按入队时间升序排序</span></span><br><span class="line">        Collections.sort(tasks, (t1, t2) -&gt; t1.ep - t2.ep);</span><br><span class="line">        PriorityQueue&lt;Task&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行时间相同，id 升序</span></span><br><span class="line">            <span class="keyword">if</span> (t1.pt == t2.pt) &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.id - t2.id;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行时间升序</span></span><br><span class="line">            <span class="keyword">return</span> t1.pt - t2.pt;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 时间戳</span></span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 把小于等于当前时间戳的任务都入队</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                heap.offer(tasks.get(i ++));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CPU 空闲</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty()) &#123;</span><br><span class="line">                now = (<span class="keyword">long</span>)tasks.get(i).ep;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; tasks.get(i).ep &lt;= now) &#123;</span><br><span class="line">                    heap.offer(tasks.get(i ++));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行一个任务</span></span><br><span class="line">            Task task = heap.poll();</span><br><span class="line">            ans[p ++] = task.id;</span><br><span class="line">            now += task.pt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有任务都进入 待执行状态，顺序执行即可</span></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            ans[p ++] = heap.poll().id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(NlgN)$，其中 $N$ 表示任务的数量。</p>
<ul>
<li>我们对任务按照入队时间进行排序，时间复杂度 $O(NlgN)$。</li>
<li>在最坏的情况下，所有的任务都会进入 堆 中，此时堆的调整次数为 $N$ 次，每次调整的时间复杂度为 $O(lgN)$。因此时间复杂度为 $O(NlgN)$。</li>
</ul>
<p>空间复杂度：$O(N)$。最坏的情况下，我们建堆的空间和任务数量一致。</p>
<h1 id="T4：所有数对按位与结果的异或和"><a href="#T4：所有数对按位与结果的异或和" class="headerlink" title="T4：所有数对按位与结果的异或和"></a>T4：<a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>从 $arr1$ 中任意取一个数 $a$，从 $arr2$ 中任意取两个数 $b_1, b_2$，则有：<br>$$<br>\begin{align}<br>(a &amp; b_1) \bigoplus (a &amp; b_2) = &amp; [(a | \lnot b_1)&amp;(\lnot a | b_2)] | [(a | b_1) &amp; (\lnot a | \lnot b_2)] \\<br> = &amp; (\lnot a &amp; \lnot b_1 &amp; b_2) | (a &amp; b_1 &amp; \lnot b_2) \\<br> = &amp; a &amp; [(\lnot b_1 &amp; b_2) | (b_1 &amp; \lnot b_2)] \\<br> = &amp; a &amp; (b_1 \bigoplus b_2)<br>\end{align}<br>$$<br>推广到 $arr2$ 中的所有数 $0 \le i \le m$<br>$$<br>[(a &amp; b_1) \bigoplus (a &amp; b_2) \bigoplus (a &amp; b_3) … (a &amp; b_m)] = [a &amp; (b_1 \bigoplus b_2 \bigoplus b_3 \bigoplus … \bigoplus b_m)]<br>$$<br>同理，推广到 $arr1$ 中的所有的数 $0 \le i \le n$<br>$$<br>\begin{align}<br>[(a_1 &amp; b_1) \bigoplus (a_2 &amp; b_2) \bigoplus (a_3 &amp; b_3) \bigoplus … \bigoplus (a_i &amp; b_j)] = &amp; [[a_1 &amp; (b_1  \bigoplus … \bigoplus b_j)]  \bigoplus … \bigoplus [a_i &amp; (b_1  \bigoplus … \bigoplus b_j)]] \\<br>= &amp; [a_1 \bigoplus a_2 \bigoplus … \bigoplus a_i] &amp; [b_1 \bigoplus b_2 \bigoplus …\bigoplus b_j]<br>\end{align}<br>$$<br>因此，我们只需要分别计算 $s_1 = \sum_{i=0}^n xor(a[i])$ 和 $s_2 = \sum_{j=0}^m xor(b[j])$。再计算  $s_1 &amp; s_2$ 即为本题的答案。 </p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr1) s1 ^= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr2) s2 ^= n;</span><br><span class="line">        <span class="keyword">return</span> s1 &amp; s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(n + m)$，其中 $n$ 和 $m$ 分别为数组 $arr1$ 和 $arr2$ 的长度。</p>
<p>空间复杂度：$O(1)$。</p>
]]></content>
      <categories>
        <category>字符串</category>
        <category>数组</category>
        <category>排序</category>
        <category>堆</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>第 239 场周赛</title>
    <url>/2021/05/06/259/</url>
    <content><![CDATA[<p>题目清单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></li>
<li> <a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></li>
<li> <a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></li>
<li> <a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></li>
</ul>
<h1 id="T1：到目标元素的最小距离"><a href="#T1：到目标元素的最小距离" class="headerlink" title="T1：到目标元素的最小距离"></a>T1：<a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">到目标元素的最小距离</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题目模拟一遍即可。</p>
<p>我们使用 $int32$ 的最大值$INT_MAX$ ，当 $nums[i] = target$ 时，保证 $abs(i - start)$ 的值最小即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ans =  min(ans, <span class="built_in">abs</span>(i - start)); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。</p>
<p>空间复杂度：$O(1)$。</p>
<h1 id="T2：将字符串拆分为递减的连续值"><a href="#T2：将字符串拆分为递减的连续值" class="headerlink" title="T2：将字符串拆分为递减的连续值"></a>T2：<a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">将字符串拆分为递减的连续值</a></h1><p>注意到：当我们确定了第一个数之后，后面的数也就随之确定下来了。因此我们在搜索的过程中，是可以避免过多的冗余计算。</p>
<h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>具体做法</p>
<ul>
<li>对于每一次递归：<ul>
<li>我们需要记录的状态如下：$idx$ 表示当前字符串的位置，$prev$ 表示上一个数的大小，$cnt$ 表示当前连续降序数字的数量。</li>
<li>我们尝试去确定第一个数，从下标 $0$ 开始增加这个数。枚举每一个可能的数（不包括全部的字符串），因为连续的字符串至少存在两个。</li>
<li>对于已经确定的上一个数，我们总是想要寻找下一个数，因此需要记录<strong>当前数</strong> $cur$ 的大小，当且仅当 $cur = prev - 1$ 时，我们才会继续寻找下一个数。</li>
<li>当我们搜索到字符串的末尾时，只有存在两个连续数字时才符合要求，此时可以返回 $True$。</li>
</ul>
</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 字符串的长度是 20 位，一定会爆 int32</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitString</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        s = str;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, ULL prev, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            <span class="comment">// 连续的数字，至少要存在两个</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ULL cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; n; i ++) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 当前数已经大于上一个数，此时直接退出即可。</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; prev - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span> || prev - cur == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>, cur, cnt + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(2^n)$，其中 $n$ 为字符串的长度且最大为 $20$。</p>
<p>空间复杂度：$O(n)$，递归消耗的栈内存。</p>
<h2 id="方法二：枚举"><a href="#方法二：枚举" class="headerlink" title="方法二：枚举"></a>方法二：枚举</h2><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于字符串 $s$，我们可以枚举出所有可能的字串。</p>
<p>按照递归的思路去改写我们的代码</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第一个整数不能是自身</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            start = start * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">            preVal = start</span><br><span class="line">            curVal = <span class="number">0</span></span><br><span class="line">            curIdx = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> preVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">all</span>(s[k] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(curIdx, n)):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                curVal = curVal * <span class="number">10</span> + <span class="built_in">int</span>(s[j])</span><br><span class="line">                <span class="comment"># 枚举的下一个字串超过前一个整数</span></span><br><span class="line">                <span class="keyword">if</span> curVal &gt; preVal - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> preVal - curVal == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == n - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    preVal = curVal</span><br><span class="line">                    curVal = <span class="number">0</span></span><br><span class="line">                    curIdx = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="T3：邻位交换的最小次数"><a href="#T3：邻位交换的最小次数" class="headerlink" title="T3：邻位交换的最小次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">邻位交换的最小次数</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol>
<li>先找到当前字符串的第 $k$ 个排列（我们称之为<strong>妙数</strong>）</li>
<li>原字符串 $s$ 与 妙数 $num$ 进行对比，如果在下标 $i$ 的位置不相同：<ol>
<li>我们在 妙数 的下标 $i$ 之后寻找一个下标 $j$ 使得 $s[i] = num[j]$ ，再将 $j$ 对应的元素相邻的交换到 $i$ 的位置。</li>
<li>每一次交换都是我们的最小交换次数</li>
</ol>
</li>
</ol>
<p>寻找下一个排序与 <a href="https://leetcode-cn.com/problems/next-permutation/">力扣31. 下一个排列</a> 相同。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i] &gt;= s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] &lt;= s[i]) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin() + i + <span class="number">1</span>, s.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = num;</span><br><span class="line">        <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">            nextPermutation(num);</span><br><span class="line">            <span class="comment">// c++ 内置的实现，同理</span></span><br><span class="line">            <span class="comment">// next_permutation(num.begin(), num.end());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != s[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; num[j] != s[i]) &#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                    swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">                    ans ++;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N \times K + N^2)$，其中 $N$ 为字符串的长度，$K$ 为给定的整数。</p>
<ul>
<li>我们先做 $K$ 次寻找下一个妙数，每一次寻找妙数的时间复杂度为 $O(N)$。</li>
<li>我们再寻找原字符串到达妙数的最小交换次数，最坏的情况下对于每一个元素我们要访问 $N$ 次，因此时间复杂度为 $O(N^2)$</li>
</ul>
<p>空间复杂度：$O(N)$，其中 $N$ 为字符串的长度。我们需要存储原字符串。</p>
<h1 id="T4：包含每个查询的最小区间"><a href="#T4：包含每个查询的最小区间" class="headerlink" title="T4：包含每个查询的最小区间"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">包含每个查询的最小区间</a></h1><h2 id="思路：离线算法"><a href="#思路：离线算法" class="headerlink" title="思路：离线算法"></a>思路：离线算法</h2><p>我们将区间的左端点和右端点以及查询视作 事件，然后对其按照左端点、查询和右端点进行排序：</p>
<ul>
<li>如果当前事件为左端点，我们将区间长度加入 有序集合 中</li>
<li>如果当前事件为查询，我们取出 有序集合 的最小值</li>
<li>如果当前事件为右端点，我们将当前区间的长度从 有序集合 中移除</li>
</ul>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="comment">// 0 表示左端点</span></span><br><span class="line">        <span class="comment">// 1 表示询问</span></span><br><span class="line">        <span class="comment">// 2 表示右端点</span></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="comment">// 事件的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="comment">// if type = 0: 区间右端点的位置</span></span><br><span class="line">        <span class="comment">// if type = 1: 询问在原数组的位置</span></span><br><span class="line">        <span class="comment">// if type = 2: 区间左端点的位置</span></span><br><span class="line">        <span class="keyword">int</span> para;</span><br><span class="line">		<span class="comment">// 如果位置相同，优先按照左端点</span></span><br><span class="line">        <span class="comment">// 按照左端点、询问、右端点的优先级排序</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Event&amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == t.pos) <span class="keyword">return</span> type &lt; t.type;</span><br><span class="line">            <span class="keyword">return</span> pos &lt; t.pos; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size(), m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Event&gt; events;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="comment">// 查询事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">1</span>, queries[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">            <span class="comment">// 左端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">0</span>, interval[<span class="number">0</span>], interval[<span class="number">1</span>]&#125;);</span><br><span class="line">			<span class="comment">// 右端点事件</span></span><br><span class="line">            events.push_back(&#123;<span class="number">2</span>, interval[<span class="number">1</span>], interval[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(events.begin(), events.end());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; seg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event : events) &#123;</span><br><span class="line">            <span class="comment">// 当前事件为左端点，把区间长度插入到 有序集合</span></span><br><span class="line">            <span class="keyword">if</span> (event.type == <span class="number">0</span>) &#123;</span><br><span class="line">                seg.insert(event.para - event.pos + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 查询事件</span></span><br><span class="line">                <span class="keyword">if</span> (seg.size()) &#123;</span><br><span class="line">                    <span class="comment">// 不为空的话，就取出最小值</span></span><br><span class="line">                    ans[event.para] = *seg.begin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 右端点，此时的小区间不必再查询，我们直接移除即可</span></span><br><span class="line">                <span class="keyword">int</span> len = event.pos - event.para + <span class="number">1</span>;</span><br><span class="line">                seg.erase(seg.find(len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O((m+n)log(m+n))$，其中 $m$ 为区间数组 $intervals$ 的长度，$n$ 为查询数组 $queries$ 的长度。我们将其合并成一个 事件 数组，容量大小为 $2m + n = O(m + n)$。然后进行了排序操作，因此时间复杂度为 $O((m + n)log(m+n))$。</p>
<p>空间复杂度：$O(m+n)$，我们需要存储所有的事件。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>第 48 场双周赛</title>
    <url>/2021/03/21/259/</url>
    <content><![CDATA[<p>题目清单：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></li>
<li> <a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/"> N 次操作后的最大分数和</a></li>
</ul>
<h1 id="T1：字符串中第二大的数字"><a href="#T1：字符串中第二大的数字" class="headerlink" title="T1：字符串中第二大的数字"></a>T1：<a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">字符串中第二大的数字</a></h1><p>注意到，这里给出的混合字符串中的数字，仅仅是指 $0-9$ 之间的数字。</p>
<p>方法一：我们使用有序的 $set$ 集合，插入后取倒数第二个元素即可。</p>
<p>$Java$ 中使用 $TreeSet$ 即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                st.insert(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = st.end();</span><br><span class="line">        it --, it --;</span><br><span class="line">        <span class="keyword">return</span> *(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 表示为字符串的长度。</p>
<p>空间复杂度：$O(1)$，其中 $set$ 集合，使用的空间最大仅为 $10$ 个元素。</p>
<h1 id="T2：设计一个验证系统"><a href="#T2：设计一个验证系统" class="headerlink" title="T2：设计一个验证系统"></a>T2：<a href="https://leetcode-cn.com/problems/design-authentication-manager/">设计一个验证系统</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目描述非常的长。实际上，我们只需要关注如下信息即可。</p>
<ul>
<li>$tokenId$ 具有唯一性，且数据级别是 $N$ ，那么我们的查找时间复杂度就尽可能的要满足 $O(1)$，不难想到哈希表</li>
<li>$token$ 的存活时间为 $currentTime + timeToLive$，我们在进行查询存活数量时，只需要检查当前时间是否小于存活时间即可</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// int[] life = &#123;live -&gt; dead&#125;</span></span><br><span class="line">    <span class="keyword">int</span> liveTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthenticationManager</span><span class="params">(<span class="keyword">int</span> timeToLive)</span> </span>&#123;</span><br><span class="line">        liveTime = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        map.put(tokenId, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;currentTime, currentTime + liveTime&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(String tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(tokenId)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] life = map.get(tokenId);</span><br><span class="line">        <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">            <span class="comment">// 还没死</span></span><br><span class="line">            life[<span class="number">0</span>] = currentTime;</span><br><span class="line">            life[<span class="number">1</span>] = currentTime + liveTime;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(tokenId, life);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, <span class="keyword">int</span>[]&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] life = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (life[<span class="number">1</span>] &gt; currentTime) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N)$，其中 $N$ 为 $Map$ 中所有 $tokenId$ 的数量</p>
<ul>
<li><code>AuthenticationManager#generate</code> 操作时间复杂度为 $O(1)$</li>
<li><code>AuthenticationManager#renew</code> 操作时间复杂度为 $O(1)$</li>
<li><code>AuthenticationManager#countUnexpiredTokens</code> 操作时间复杂度为 $O(N)$，我们需要遍历 $Map$ 集合。</li>
</ul>
<p>空间复杂度：$O(N)$</p>
<h1 id="T3：你能构造出连续值的最大数目"><a href="#T3：你能构造出连续值的最大数目" class="headerlink" title="T3：你能构造出连续值的最大数目"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-number-of-consecutive-values-you-can-make/">你能构造出连续值的最大数目</a></h1><h2 id="方法一：数学推导"><a href="#方法一：数学推导" class="headerlink" title="方法一：数学推导"></a>方法一：数学推导</h2><p>我们对数组进行排序，使得我们选择下一个元素时，尽可能的接近。</p>
<p>子问题：</p>
<p>假如连续整数为 $[0, 0]$ ，那么下一个元素必须满足为 $coins[0] \le 1$ ，才能保证整数连续。</p>
<p>归纳：</p>
<ul>
<li>对于连续整数 $[0, 1]$，那么 $coins[1] \le 2$ 使得整数为 $[0, 1 + coins[1]]$才能保证整数连续。</li>
<li>对于连续整数 $[0, x]$，那么 $coins[i] \le x + 1$ 使得整数为 $[0, x + coins[i]]$ 才能保证整数连续。</li>
</ul>
<p>证明：</p>
<p>假设前 $i$ 个元素已经构成连续整数 $[0, n]$ ，且下一个数为 $m$ 时：</p>
<p>若 $m &gt; n + 1$ 时，此时可以构成的整数分别为 $[0, n]$ ， $[m, m + n + 1]$ 。存在 $m \gt n + 1 \gt n$。则整数不连续。</p>
<p>因此要想整数连续递增，必须保证 $m \le n + 1$，使得整数连续为 $[0, n + m + 1]$。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        sort(coins.begin(), coins.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + <span class="number">1</span> &lt; coin) <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">            now += coin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(NlogN)$，其中 $N$ 为数组长度。</p>
<p>空间复杂度：$O(logN)$</p>
<h1 id="T4：N-次操作后的最大分数和"><a href="#T4：N-次操作后的最大分数和" class="headerlink" title="T4：N 次操作后的最大分数和"></a>T4：<a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/">N 次操作后的最大分数和</a></h1><h2 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h2><p>首先看看题目是如何定义第 $i$ 次操作（$i$ 从 <strong>1</strong> 开始）：</p>
<ul>
<li>选择两个元素 $x$ 和 $y$</li>
<li>获得分数 $i \times gcd(x, y)$</li>
<li>删除 $x$ 和 $y$</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>我们也不必再关注 $nums$ 数组本身，因为我们的分数计算实际上是 $ i \times gcd(x,y)$，即与 $x$ 和 $y$ 的<strong>最大公约数和操作次数</strong>有关的。因此，我们可以<strong>预处理</strong> $nums$ 数组所有下标 $i$ 和 $j$ 的组合对应的最大公约数。</p>
<p>我们需要选择任意两个元素，也就是任意两个未使用过的下标，直到用完所有的操作次数。</p>
<p>那么，我们就可以尝试所有可能的起点，并使用一个 $path$ 数组记录我们选择元素对应的最大公约数。</p>
<p>当我们的操作数全部用完时，对选择的最大公约数进行排序处理（因为并没有限制操作的顺序），使得 <strong>较大的操作次数 * 较大的最大公约数</strong> 来获得最大的分数。</p>
<h3 id="具体实现如下："><a href="#具体实现如下：" class="headerlink" title="具体实现如下："></a>具体实现如下：</h3><p>对于任意一次操作 $i$ ，我们有：</p>
<ul>
<li>选择一个从未使用过的下标作为元素 $x$，对应下标为 $s$</li>
<li>再选择一个从未使用过的下标作为元素 $y$，对应下标为 $u$</li>
<li>我们将其对应的最大公约数 $g[s][u]$ 加入到 $path$ 数组</li>
<li>当我们的操作次数使用完毕时，此时 $path$ 数组中已经存在 $n / 2$ 个元素，我们获得分数的理念是 <strong>较大的操作次数 * 较大的最大公约数</strong> 。因此对 $path$ 进行备份，然后排序计算此轮获得的最大分数并更新<strong>历史最大值</strong>。</li>
<li>我们再回溯到选择元素 $y$ 的场景。此时我们将不再选择元素 $y$ ，将下标 $u$ 标记为未使用。如果没有元素可供选择时。</li>
<li>我们再次回溯到选择元素 $x$ 的场景。与选择元素 $y$ 同理。</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1e9</span>; <span class="comment">// 历史最大值</span></span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">20</span>]; <span class="comment">// 标记数组</span></span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">// 预处理 最大公约数</span></span><br><span class="line">    <span class="keyword">int</span> n;			<span class="comment">// 数组长度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q, path; <span class="comment">// q 为 nums 备份，path 为选择路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = path;</span><br><span class="line">            sort(t.begin(), t.end());</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &gt;&gt; <span class="number">1</span>; i ++) &#123;</span><br><span class="line">                res += (i + <span class="number">1</span>) * t[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                s = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        used[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[u]) &#123;</span><br><span class="line">                used[u] = <span class="literal">true</span>;</span><br><span class="line">                path.push_back(g[s][u]);</span><br><span class="line">                dfs(cnt + <span class="number">1</span>);</span><br><span class="line">                used[u] = <span class="literal">false</span>;</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        used[s] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        n = nums.size();</span><br><span class="line">        q = nums;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                g[i][j] = g[j][i] = gcd(nums[i], nums[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q.begin(), q.end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(N^2 + N!)$，其中 $N$ 为数组的长度。</p>
<ul>
<li>我们需要预处理 $nums$ 数组</li>
<li>回溯的时间复杂度大致是这个级别，推测出来的量级</li>
</ul>
<p>空间复杂度：$O(N^2)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>回溯</tag>
        <tag>设计</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>第192场周赛</title>
    <url>/2020/06/07/cku5fjrst003b90v4e06bg1et/</url>
    <content><![CDATA[<p>这一场发挥的不错，AC了三题。一开始做的时候感觉很难，第一题慌慌张张的花了7分钟才AC了，我在c++和java之间换了两次，最后还是c++更容易实现其实用java也是可以的，上来我就在选择语言上飘摇不定了。这也是一个问题，做题的心理问题，看完问题，分析思路完毕后，中途不能再切换语言了，使用一个语言解决它！主要是没有数论的题，一般的数据结构的问题，hard除外，我基本都是可以AC的。</p>
<p>周赛题目考察点：<strong>数组、数组/排序、设计/栈(我的思路是这个，设计类的题目思路很开放)</strong></p>
<a id="more"></a>

<h4 id="5428、重新排列数组"><a href="#5428、重新排列数组" class="headerlink" title="5428、重新排列数组"></a>5428、重新排列数组</h4><p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p>
<p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3</span><br><span class="line">输出：[2,3,5,4,1,7] </span><br><span class="line">解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,4,3,2,1], n &#x3D; 4</span><br><span class="line">输出：[1,4,2,3,3,2,4,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,2], n &#x3D; 2</span><br><span class="line">输出：[1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<pre><code>1 &lt;= n &lt;= 500
nums.length == 2n
1 &lt;= nums[i] &lt;= 10^3
</code></pre>
<h5 id="1、思路分析"><a href="#1、思路分析" class="headerlink" title="1、思路分析"></a>1、思路分析</h5><ul>
<li>不难看出，给出的数据量很小，最大也是1000而已，所以不多想直接暴力</li>
<li><code>[x1,x2,...,xn,y1,y2,...,yn]</code>把数组一分为二，然后归并到新数组中</li>
</ul>
<h5 id="2、Coding"><a href="#2、Coding" class="headerlink" title="2、Coding"></a>2、Coding</h5><p><strong>c++：</strong></p>
<p>下面是我比赛的源码，比赛时的心理是比较紧张的，所以代码质量很差劲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; nums.size()) &#123;</span><br><span class="line">            res.push_back(nums[i++]);</span><br><span class="line">            res.push_back(nums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>赛后优化版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            res.push_back(nums[i+n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的java实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            res[idx++] = nums[i];</span><br><span class="line">            res[idx++] = nums[i+n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的时间复杂度、空间复杂度均为<code>O(n)</code></p>
<h4 id="5429、数组中的k个最强值"><a href="#5429、数组中的k个最强值" class="headerlink" title="5429、数组中的k个最强值"></a>5429、数组中的k个最强值</h4><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code>。</p>
<p>设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code> 的值更强：</p>
<ul>
<li> ``|arr[i] - m| &gt; |arr[j] - m|`</li>
<li><code> |arr[i] - m| == |arr[j] - m|，且 arr[i] &gt; arr[j]</code><br>  请返回由数组中最强的 <code>k</code> 个值组成的列表。答案可以以 <strong>任意顺序</strong> 返回。</li>
</ul>
<p>中位数 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 ((n - 1) / 2) 的元素。</p>
<p>例如 <code>arr = [6, -3, 7, 2, 11]</code>，<code>n = 5</code>：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11] </code>，数组的中间位置为 <code>m = ((5 - 1) / 2) = 2</code> ，中位数 <code>arr[m]</code> 的值为 6 。<br>例如 <code>arr = [-7, 22, 17, 3]</code>，<code>n = 4</code>：数组排序后得到 <code>arr = [-7, 3, 17, 22] </code>，数组的中间位置为 <code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m] </code>的值为 3 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">解释：中位数为 <span class="number">3</span>，按从强到弱顺序排序后，数组变为 [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]。最强的两个元素是 [<span class="number">5</span>, <span class="number">1</span>]。[<span class="number">1</span>, <span class="number">5</span>] 也是正确答案。</span><br><span class="line">注意，尽管 |<span class="number">5</span> - <span class="number">3</span>| == |<span class="number">1</span> - <span class="number">3</span>| ，但是 <span class="number">5</span> 比 <span class="number">1</span> 更强，因为 <span class="number">5</span> &gt; <span class="number">1</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">解释：中位数为 <span class="number">3</span>, 按从强到弱顺序排序后，数组变为 [<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]。最强的两个元素是 [<span class="number">5</span>, <span class="number">5</span>]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>], k = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">解释：中位数为 <span class="number">7</span>, 按从强到弱顺序排序后，数组变为 [<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>]。</span><br><span class="line">[<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>] 的任何排列都是正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">6</span>,-<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">11</span>], k = <span class="number">3</span></span><br><span class="line">输出：[-<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [-<span class="number">7</span>,<span class="number">22</span>,<span class="number">17</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">22</span>,<span class="number">17</span>]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-10^5 &lt;= arr[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= arr.length</code></li>
</ul>
<h5 id="1、思路分析-1"><a href="#1、思路分析-1" class="headerlink" title="1、思路分析"></a>1、思路分析</h5><ul>
<li>先读题，了解题目让我们做什么，看测试用例是，题目希望我们按照他给出的两个规则来重新排序数组并且返回前<code>k</code>个数据组成的列表，答案可以任意顺序</li>
<li>中位数的概念，我们一定要按照题目给出的要求来，不同于以往的中位数</li>
<li>然后就是两次排序，看数据量<code>10e5</code>，达到这个量之后，任何大于O(n2)的排序算法，基本上是无法通过的，所以你即使没有想到调库，也要写快排这种<code>O(nlogn)</code>或者更快的排序算法</li>
</ul>
<h5 id="2、Coding-1"><a href="#2、Coding-1" class="headerlink" title="2、Coding"></a>2、Coding</h5><p>这个代码的时间复杂度非常高，虽然是<code>O(nlogn)</code>但是两次排序也难顶，在使用宏定义时，无法通过。另外关于<code>lambda表达式</code>，<code>cmp函数</code>必须定义在外部，即让他成为<code>全局变量</code>里定义，不然无法访问到<code>m</code>。感谢技术分享！<a href="https://www.cnblogs.com/gqtcgq/p/9939651.html">@gqtc</a></p>
<p><strong>c++:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">abs</span>(x-m) &gt; <span class="built_in">abs</span>(y-m)) || (<span class="built_in">abs</span>(x-m) == <span class="built_in">abs</span>(y-m) &amp;&amp; x &gt; y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getStrongest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        m = arr[(arr.size()<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        sort(arr.begin(), arr.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            res.push_back(arr[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>java：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getStrongest(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> m = arr[(arr.length-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// java8新特性中，要把基本数据类型转化为对象，才能使用lambda表达式</span></span><br><span class="line">        <span class="comment">// 也算是踩了一个天坑吧，竟然输在了java上，也是让我很意外啊，哈哈哈哈哈~~</span></span><br><span class="line">        Integer[] num = Arrays.stream(arr).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.sort(num, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(a-m) &gt; Math.abs(b-m)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((Math.abs(a-m) == Math.abs(b-m)) &amp;&amp; a &gt; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比赛源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">abs</span>(x-m) &gt; <span class="built_in">abs</span>(y-m)) || (<span class="built_in">abs</span>(x-m) == <span class="built_in">abs</span>(y-m) &amp;&amp; x &gt; y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getStrongest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        m = arr[(arr.size()<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        sort(arr.begin(), arr.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            res.push_back(arr[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5430、设计浏览器历史记录"><a href="#5430、设计浏览器历史记录" class="headerlink" title="5430、设计浏览器历史记录"></a>5430、设计浏览器历史记录</h4><p>你有一个只支持单个标签页的 <strong>浏览器</strong> ，最开始你浏览的网页是 <code>homepage</code> ，你可以访问其他的网站 <code>url </code>，也可以在浏览历史中后退 <code>steps</code> 步或前进 <code>steps</code> 步。</p>
<p>请你实现 <code>BrowserHistory</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BrowserHistory(string homepage) ，用 homepage 初始化浏览器类。</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(string url)</span> 从当前页跳转访问 url 对应的页面  。执行此操作会把浏览历史前进的记录全部删除。</span></span><br><span class="line"><span class="function">string <span class="title">back</span><span class="params">(<span class="keyword">int</span> steps)</span> 在浏览历史中后退 steps 步。如果你只能在浏览历史中后退至多 x 步且 steps &gt; x ，那么你只后退 x 步。请返回后退 至多 steps 步以后的 url 。</span></span><br><span class="line"><span class="function">string <span class="title">forward</span><span class="params">(<span class="keyword">int</span> steps)</span> 在浏览历史中前进 steps 步。如果你只能在浏览历史中前进至多 x 步且 steps &gt; x ，那么你只前进 x 步。请返回前进 至多 steps步以后的 url 。</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;BrowserHistory&quot;</span>,<span class="string">&quot;visit&quot;</span>,<span class="string">&quot;visit&quot;</span>,<span class="string">&quot;visit&quot;</span>,<span class="string">&quot;back&quot;</span>,<span class="string">&quot;back&quot;</span>,<span class="string">&quot;forward&quot;</span>,<span class="string">&quot;visit&quot;</span>,<span class="string">&quot;forward&quot;</span>,<span class="string">&quot;back&quot;</span>,<span class="string">&quot;back&quot;</span>]</span><br><span class="line">[[<span class="string">&quot;leetcode.com&quot;</span>],[<span class="string">&quot;google.com&quot;</span>],[<span class="string">&quot;facebook.com&quot;</span>],[<span class="string">&quot;youtube.com&quot;</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="string">&quot;linkedin.com&quot;</span>],[<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">7</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">&quot;facebook.com&quot;</span>,<span class="string">&quot;google.com&quot;</span>,<span class="string">&quot;facebook.com&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;linkedin.com&quot;</span>,<span class="string">&quot;google.com&quot;</span>,<span class="string">&quot;leetcode.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">BrowserHistory browserHistory = <span class="keyword">new</span> BrowserHistory(<span class="string">&quot;leetcode.com&quot;</span>);</span><br><span class="line">browserHistory.visit(<span class="string">&quot;google.com&quot;</span>);       <span class="comment">// 你原本在浏览 &quot;leetcode.com&quot; 。访问 &quot;google.com&quot;</span></span><br><span class="line">browserHistory.visit(<span class="string">&quot;facebook.com&quot;</span>);     <span class="comment">// 你原本在浏览 &quot;google.com&quot; 。访问 &quot;facebook.com&quot;</span></span><br><span class="line">browserHistory.visit(<span class="string">&quot;youtube.com&quot;</span>);      <span class="comment">// 你原本在浏览 &quot;facebook.com&quot; 。访问 &quot;youtube.com&quot;</span></span><br><span class="line">browserHistory.back(<span class="number">1</span>);                   <span class="comment">// 你原本在浏览 &quot;youtube.com&quot; ，后退到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;</span></span><br><span class="line">browserHistory.back(<span class="number">1</span>);                   <span class="comment">// 你原本在浏览 &quot;facebook.com&quot; ，后退到 &quot;google.com&quot; 并返回 &quot;google.com&quot;</span></span><br><span class="line">browserHistory.forward(<span class="number">1</span>);                <span class="comment">// 你原本在浏览 &quot;google.com&quot; ，前进到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;</span></span><br><span class="line">browserHistory.visit(<span class="string">&quot;linkedin.com&quot;</span>);     <span class="comment">// 你原本在浏览 &quot;facebook.com&quot; 。 访问 &quot;linkedin.com&quot;</span></span><br><span class="line">browserHistory.forward(<span class="number">2</span>);                <span class="comment">// 你原本在浏览 &quot;linkedin.com&quot; ，你无法前进任何步数。</span></span><br><span class="line">browserHistory.back(<span class="number">2</span>);                   <span class="comment">// 你原本在浏览 &quot;linkedin.com&quot; ，后退两步依次先到 &quot;facebook.com&quot; ，然后到 &quot;google.com&quot; ，并返回 &quot;google.com&quot;</span></span><br><span class="line">browserHistory.back(<span class="number">7</span>);                   <span class="comment">// 你原本在浏览 &quot;google.com&quot;， 你只能后退一步到 &quot;leetcode.com&quot; ，并返回 &quot;leetcode.com&quot;</span></span><br></pre></td></tr></table></figure>


<p>提示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= homepage.length &lt;= <span class="number">20</span></span><br><span class="line"><span class="number">1</span> &lt;= url.length &lt;= <span class="number">20</span></span><br><span class="line"><span class="number">1</span> &lt;= steps &lt;= <span class="number">100</span></span><br><span class="line">homepage 和 url 都只包含 <span class="string">&#x27;.&#x27;</span> 或者小写英文字母。</span><br><span class="line">最多调用 <span class="number">5000</span> 次 visit， back 和 forward 函数。</span><br></pre></td></tr></table></figure>
<h5 id="1、思路分析-2"><a href="#1、思路分析-2" class="headerlink" title="1、思路分析"></a>1、思路分析</h5><ul>
<li>这个题目看起来很复杂，实际上就是平时使用浏览器时的操作。浏览器会记录历史浏览状态，以及前进和后退等功能，想象一下浏览器的功能就可以解决这个问题</li>
<li>我的思路是借助两个栈来实现该功能，一个<code>history</code>栈，一个<code>forward</code>栈</li>
</ul>
<p>具体看图：</p>
<p>在<code>visit</code>操作完成后，栈内元素的情况。</p>
<p><img src="https://pic.downk.cc/item/5edc939dc2a9a83be51681ac.png"></p>
<p>经过两次<code>back(1)</code>后，栈内元素的情况。</p>
<p><img src="https://pic.downk.cc/item/5edc93fcc2a9a83be517623b.png"></p>
<p>经过<code>forward(1)</code>后，栈内元素情况。</p>
<p><img src="https://pic.downk.cc/item/5edc9444c2a9a83be5180e99.png"></p>
<p>经过<code>visit</code>操作后，会导致forward栈被清空。此时栈内元素的情况。</p>
<p><img src="https://pic.downk.cc/item/5edc9492c2a9a83be518c42b.png"></p>
<p>经过<code>forward(2)</code>操作，此时forward栈空，无法前进</p>
<p>经过<code>back(2)</code>操作后</p>
<p><img src="https://pic.downk.cc/item/5edc94fac2a9a83be519b69d.png"></p>
<p>经过<code>back(7)</code>操作后</p>
<p><img src="https://pic.downk.cc/item/5edc9506c2a9a83be519d121.png"></p>
<h5 id="2、Coding-2"><a href="#2、Coding-2" class="headerlink" title="2、Coding"></a>2、Coding</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;String&gt; history;</span><br><span class="line">    Stack&lt;String&gt; forward;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrowserHistory</span><span class="params">(String homepage)</span> </span>&#123;</span><br><span class="line">        history = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        forward = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        history.push(homepage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        history.push(url);</span><br><span class="line">        <span class="keyword">while</span> (!forward.isEmpty()) &#123;</span><br><span class="line">            forward.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">back</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!history.isEmpty() &amp;&amp; steps != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (history.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            forward.push(history.pop());</span><br><span class="line">            steps--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> history.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">forward</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!forward.isEmpty() &amp;&amp; steps != <span class="number">0</span>) &#123;</span><br><span class="line">            history.push(forward.pop());</span><br><span class="line">            steps--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> history.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BrowserHistory object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BrowserHistory obj = new BrowserHistory(homepage);</span></span><br><span class="line"><span class="comment"> * obj.visit(url);</span></span><br><span class="line"><span class="comment"> * String param_2 = obj.back(steps);</span></span><br><span class="line"><span class="comment"> * String param_3 = obj.forward(steps);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="5431、给房子涂色-III"><a href="#5431、给房子涂色-III" class="headerlink" title="5431、给房子涂色 III"></a>5431、给房子涂色 III</h4><p>暂时没有思路，又是<code>dp</code>问题，周赛最后一题稳稳的<code>dp</code>问题</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>设计</tag>
        <tag>力扣</tag>
        <tag>周赛</tag>
        <tag>题解</tag>
        <tag>解题思路</tag>
        <tag>栈</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第197场周赛</title>
    <url>/2020/07/13/cku5fjrst003d90v43jvhgask/</url>
    <content><![CDATA[<p>字节又来了，感觉自己把第三题想的太复杂了。第四题是否有些超纲呢？</p>
<a id="more"></a>

<h4 id="题目一：好数对的数目"><a href="#题目一：好数对的数目" class="headerlink" title="题目一：好数对的数目"></a>题目一：<a href="https://leetcode-cn.com/problems/number-of-good-pairs/">好数对的数目</a></h4><p>题解：略</p>
<p>暴力法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j &amp;&amp; nums[i] == nums[j]) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2)$</p>
<p>如果数据量很大的话，就要考虑空间换时间了。</p>
<p>优化：</p>
<p>先计数后，两个相同的数，下标一定是不相同的。所有我们只需要统计 <code>i &lt; j</code> 的情况，即对于某个数 <code>num</code> ，好数对存在 ${2 \choose n}$ 个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = map.get(key);</span><br><span class="line">            res += cnt * (cnt-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$ O(n) $</p>
<h4 id="题目二：仅含1的字串数"><a href="#题目二：仅含1的字串数" class="headerlink" title="题目二：仅含1的字串数"></a>题目二：<a href="https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/">仅含1的字串数</a></h4><p>首先暴力回溯肯定是超时的解法。因为时间复杂度达到了 $ O(n^{n}) $  </p>
<p>我们观察用例，可以发现当连续的字串数量为 3 时，它贡献的字串数量为 $  3 * (3 + 1) \over 2 $ ，由此可以推广至当连续的字串数量为 n 时，它贡献的字串数量为 $  n * (n + 1) \over 2 $ </p>
<p>代码：</p>
<p>注意点：类型溢出，<code>int</code> 肯定是装不下的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSub</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> cur = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                res += cur * (cur+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                res %= mod;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以 1 结尾的字串</span></span><br><span class="line">        res += cur * (cur+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        res %= mod;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目三：概率最大的路径"><a href="#题目三：概率最大的路径" class="headerlink" title="题目三：概率最大的路径"></a>题目三：<a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">概率最大的路径</a></h4><p>大师，我终于悟了！其实这个题是比较基本的迪杰特斯拉算法，在遍历所有的路径，加权衡量要遍历哪个节点时，让概率最大的节点在对头。在BFS的过程中，加入贪心的思想，每次总是走概率最大的那条路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">double</span> weight;</span><br><span class="line">        Node() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node(<span class="keyword">int</span> _id, <span class="keyword">double</span> _weight) &#123;</span><br><span class="line">            id = _id;</span><br><span class="line">            weight = _weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">double</span>[] succProb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;Node&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> weight = succProb[i];</span><br><span class="line">            graph[from].add(<span class="keyword">new</span> Node(to, weight));</span><br><span class="line">            graph[to].add(<span class="keyword">new</span> Node(from, weight));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用一个大根堆代替普通的队列，让概念大的总是在对头</span></span><br><span class="line">        PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; Double.compare(b.weight, a.weight));</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Node(start, <span class="number">1</span>));</span><br><span class="line">        visited[start] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.id == end) <span class="keyword">return</span> node.weight;</span><br><span class="line">            visited[node.id] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node ne : graph[node.id]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[ne.id]) &#123;</span><br><span class="line">                    Node next = <span class="keyword">new</span> Node(ne.id, ne.weight*node.weight);</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0D</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迪杰特斯拉基本模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借助 Node 类来模拟节点信息 属性根据情况进行更改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">double</span> weight;</span><br><span class="line">        Node() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node(<span class="keyword">int</span> _id, <span class="keyword">double</span> _weight) &#123;</span><br><span class="line">            id = _id;</span><br><span class="line">            weight = _weight;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 	List&lt;Node&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建图时，要注意有向图和无向图，无向图是双向的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 优先队列，根据情况决定大根堆还是小根堆</span></span><br><span class="line">    PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">	<span class="comment">// 访问数组，必不可少</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">	<span class="comment">// 加入起始节点</span></span><br><span class="line">    queue.offer(<span class="keyword">new</span> Node(start, <span class="number">1</span>));</span><br><span class="line">    visited[start] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 下面都是固定的格式</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 从对头取数据</span></span><br><span class="line">        <span class="comment">// 判断是否结束</span></span><br><span class="line">        <span class="comment">// 标记访问</span></span><br><span class="line">        <span class="keyword">for</span> () &#123;</span><br><span class="line">            <span class="comment">// 循环访问，从对头取出节点的邻接点，注意访问标记，否则会死循环</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题目四：<a href="https://leetcode-cn.com/problems/best-position-for-a-service-centre/comments/">服务中心的最佳位置</a></p>
<p>感觉有些超纲了，加上我数学本身不是很擅长，留个坑。以后再填。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>力扣</tag>
        <tag>图</tag>
        <tag>数学</tag>
        <tag>周赛</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>第199场周赛</title>
    <url>/2020/07/27/cku5fjrsu003h90v4ghna9lo6/</url>
    <content><![CDATA[<p>题目标题即原题地址，点击查看原题。</p>
<a id="more"></a>

<h3 id="T1：重新排列字符串"><a href="#T1：重新排列字符串" class="headerlink" title="T1：重新排列字符串"></a>T1：<a href="https://leetcode-cn.com/problems/shuffle-string/">重新排列字符串</a></h3><p>思路：略</p>
<p>一个稍微复杂点的解法就是，构造一个Map =&gt; $indices[i]:s[i]$ 然后根据<code>key</code>进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">restoreString</span><span class="params">(String s, <span class="keyword">int</span>[] indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            chs[indices[i]] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p1, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; ve;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indices.size(); i++) &#123;</span><br><span class="line">            ve.push_back(&#123;indices[i], s[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ve.begin(), ve.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : ve) &#123;</span><br><span class="line">            res.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="T2：灯泡开关-IV"><a href="#T2：灯泡开关-IV" class="headerlink" title="T2：灯泡开关 IV"></a>T2：<a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">灯泡开关 IV</a></h3><p>对于 n 个连续的灯泡。我们可以有一下操作，反转 <code>i</code> 到 <code>n-1</code> 个连续的灯泡</p>
<p>所以对于连续的1或者0，我们只有一次操作即可。统计相邻灯泡状态不同的个数即为反转次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlips</span>(<span class="params">self, target: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        s = <span class="string">&quot;0&quot;</span> + target</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[i-<span class="number">1</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="T3：好叶子节点对的数量"><a href="#T3：好叶子节点对的数量" class="headerlink" title="T3：好叶子节点对的数量"></a>T3：<a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量</a></h3><p>本质上是LCA，但是数据量很弱，所以直接暴力循环即可。统计<strong>当前节点</strong>下，所有的叶子节点。然后再循环处理，小于等于<code>distance</code>的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; left = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root.left, <span class="number">0</span>, left);</span><br><span class="line">        List&lt;Integer&gt; right = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root.right, <span class="number">0</span>, right);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer l : left) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer r : right) &#123;</span><br><span class="line">                <span class="comment">// 自身算一</span></span><br><span class="line">                <span class="keyword">if</span> (l + r + <span class="number">2</span> &lt;= distance) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是到根节点，md</span></span><br><span class="line">        res += countPairs(root.left, distance);</span><br><span class="line">        res += countPairs(root.right, distance);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLeaf(root)) &#123;</span><br><span class="line">            list.add(depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, depth + <span class="number">1</span>, list);</span><br><span class="line">        dfs(root.right, depth + <span class="number">1</span>, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T4：<a href="https://leetcode-cn.com/problems/string-compression-ii/">压缩字符串 II</a></p>
<p>暂时不会。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>DP</tag>
        <tag>排序</tag>
        <tag>树， DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>第201场周赛</title>
    <url>/2020/08/11/cku5fjrsv003j90v40nh7hcvx/</url>
    <content><![CDATA[<p>题目标题即原题地址，点击查看原题。代码主要为Java和cpp，部分tricky题目会使用py来解决</p>
<a id="more"></a>

<h4 id="T1：整理字符串"><a href="#T1：整理字符串" class="headerlink" title="T1：整理字符串"></a>T1：<a href="https://leetcode-cn.com/problems/make-the-string-great/comments/">整理字符串</a></h4><p>思路一：根据题意循环模拟即可</p>
<p><strong>JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sb.charAt(i) - sb.charAt(i + <span class="number">1</span>)) == <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    sb.delete(i, i + <span class="number">2</span>);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路二：栈，假设栈顶元素与即将入栈的元素相同且一个是大写，一个是小写。那么出栈即可。否则入栈，整个字符串遍历完毕后，出栈反转即可。</p>
<p><strong>JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(stack.peek() - c) == <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : stack) &#123;</span><br><span class="line">            res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="T2：找出第N个二进制字符串中的第K位"><a href="#T2：找出第N个二进制字符串中的第K位" class="headerlink" title="T2：找出第N个二进制字符串中的第K位"></a>T2：<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/">找出第N个二进制字符串中的第K位</a></h4><p>tricky题目，按照题目即可。</p>
<p><strong>Python3</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">invert</span>(<span class="params">string</span>):</span></span><br><span class="line">            res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    res += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">            t = s + <span class="string">&#x27;1&#x27;</span> + invert(s)[::-<span class="number">1</span>]</span><br><span class="line">            s = t</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(s)</span></span><br><span class="line">        <span class="keyword">return</span> s[k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="T3：和为目标值的最大数目不重叠非空子数组数目"><a href="#T3：和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="T3：和为目标值的最大数目不重叠非空子数组数目"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/">和为目标值的最大数目不重叠非空子数组数目</a></h4><p>一开始想到了滑动窗口，但是滑动窗口存在一个问题，数组中是存在负数的。因为在滑动过程中，就会存在收缩和扩张的不确定性。这种不确定性在极端情况下，可以会导致反复的收缩和扩张，导致耗时过多而最终超时。</p>
<p>思路：存储当前所有数据的前缀和。当出现符合<code>target</code>的值时，即说明找到一个子数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            curSum += num;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(curSum - target)) &#123;</span><br><span class="line">                set.clear();</span><br><span class="line">                set.add(<span class="number">0</span>);</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
        <tag>栈</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>第217场周赛</title>
    <url>/2020/11/30/cku5fjrsw003o90v44bvoas1f/</url>
    <content><![CDATA[<h3 id="T1：最富有客户的资产总量"><a href="#T1：最富有客户的资产总量" class="headerlink" title="T1：最富有客户的资产总量"></a>T1：<a href="https://leetcode-cn.com/problems/richest-customer-wealth/">最富有客户的资产总量</a></h3><p>思路：暴力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumWealth</span><span class="params">(<span class="keyword">int</span>[][] accounts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] account : accounts) &#123;</span><br><span class="line">            res = Math.max(res, Arrays.stream(account).sum());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>空间复杂度：$O(1)$</p>
<a id="more"></a>

<h3 id="T2：找出最具竞争力的子序列"><a href="#T2：找出最具竞争力的子序列" class="headerlink" title="T2：找出最具竞争力的子序列"></a>T2：<a href="https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/">找出最具竞争力的子序列</a></h3><p>思路：</p>
<ul>
<li>重新翻译一下题目，就是在数组中找出一个长度为<code>k</code>，且自然序列是最小的一个子序列。</li>
<li>如<code>[1, 3, 4]</code> 和 <code>[1, 3, 5]</code> ，由于 <code>4</code> 在自然序列上小于 <code>5</code> 所以，前者更具竞争力。</li>
<li>我们借助栈这一特殊结构来找出这个子序列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] mostCompetitive(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> a = nums.length - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; a &gt; <span class="number">0</span> &amp;&amp; stack.peekLast() &gt; num) &#123;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                a--;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.offerLast(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; k) &#123;</span><br><span class="line">            stack.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) res[i] = stack.pollLast();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(N^2)$最差为$O(N^2)$</p>
<p>空间复杂度：$O(n)$</p>
<h3 id="T3：使数组互补的最少操作次数"><a href="#T3：使数组互补的最少操作次数" class="headerlink" title="T3：使数组互补的最少操作次数"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/">使数组互补的最少操作次数</a></h3><p>思路：</p>
<p>差分数组  详细可见：<a href="https://oi-wiki.org/basic/prefix-sum/">https://oi-wiki.org/basic/prefix-sum/</a></p>
<p>差分数组是为了区间更新和区间修改问题的，如果数据量很小的话，可以直接通过暴力循环去解决，可是数据量一旦达到一定的量，而且常数足够大时，暴力不再是最好的解决办法。例如 <code>1&lt;=n&lt;=1e5</code>, <code>1&lt;=nums[i]&lt;=1e5</code>时。</p>
<p>假设一次操作中，要修改(加上或减去)闭区间内<code>[left, right]</code>的值，即对其左右边界进行操作即可<br>m 为操作数， left ,right 为左右边界， change 为改变值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right &gt;&gt; change;</span><br><span class="line">	arr[left] += change;</span><br><span class="line">	arr[right+<span class="number">1</span>] -= change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到本题中，</p>
<p>假设 <code>res[x]</code> 为 <code>nums[i] + nums[n-1-i]</code>和为 <code>x</code> 需要的操作数。</p>
<p>由于 <code>1 &lt;= nums[i] &lt;= limit</code>， 所以 <code>x</code> 的取值范围为 <code>[2, 2*limit]</code>，但由于差分数组的端点操作，所以我们需要申请 <code>2*limit+2</code>长度的数组。</p>
<p>根据题意，我们每次操作，都可以改变一个数为<code>[1, limit]</code>之间的数。</p>
<p>那么假设 <code>nums[i] = A</code>, <code>nums[n-1-i] = B</code></p>
<ol>
<li>如果修改后两数的和是A+B，那么表示A,B都没有修改</li>
<li>如果修改后和在 <code>[1+min(A,B), limit+max(A,B)]</code> 的范围，说明值修改了一个数</li>
<li>如果在<code>[2, 2limit]</code> 说明修改了两个数</li>
</ol>
<p>算法过程为：</p>
<ul>
<li>差分数组 <code>f[0 ... x]</code> 的和，表示最终数组互补的数字为 x 所需的操作</li>
<li>对于A， B<ul>
<li>我们将 <code>[2, 2*limit]</code> 范围内的操作数 +2。</li>
<li>对于 <code>[1+min(A,B), limit+max(A,B)]</code> 范围内的操作数 - 1。</li>
<li>对于 A+B，操作数 -1。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*limit + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> A = nums[i], B = nums[n-<span class="number">1</span>-i];</span><br><span class="line">            <span class="comment">// [2, 2*limit] 范围操作数 +2</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">2</span>, r = <span class="number">2</span>*limit;</span><br><span class="line">            f[l] += <span class="number">2</span>;</span><br><span class="line">            f[r+<span class="number">1</span>] -= <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// [1+min(A,B), limit+max(A,B)] 范围操作数 +1，实际-1</span></span><br><span class="line">            l = <span class="number">1</span>+Math.min(A, B);r = limit+Math.max(A, B);</span><br><span class="line">            f[l] += -<span class="number">1</span>;</span><br><span class="line">            f[r+<span class="number">1</span>] -= -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// A+B 范围操作数 0，实际-1  (2-1-1)</span></span><br><span class="line">            l = A+B;r = A+B;</span><br><span class="line">            f[l] += -<span class="number">1</span>;</span><br><span class="line">            f[r+<span class="number">1</span>] -= -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span>*limit; i++) &#123;</span><br><span class="line">            sum += f[i];</span><br><span class="line">            res = Math.min(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<h3 id="T4：数组的最小偏移量"><a href="#T4：数组的最小偏移量" class="headerlink" title="T4：数组的最小偏移量"></a>T4：<a href="https://leetcode-cn.com/problems/minimize-deviation-in-array/">数组的最小偏移量</a></h3><p>思路：</p>
<ul>
<li>将数组中的数变成可变范围内的最大值</li>
<li>理解上面那句话，即根据规则，将奇数全部乘以2即可</li>
<li>然后剩下的操作就只剩把数据缩小即可，每次取出最大值。借助<code>TreeSet</code>或者<code>PriorityQueue</code>来实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeviation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num%<span class="number">2</span>==<span class="number">0</span>?num : num*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = set.last() - set.first();</span><br><span class="line">        <span class="keyword">while</span> (res &gt; <span class="number">0</span> &amp;&amp; set.last()%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = set.last();</span><br><span class="line">            set.remove(num);</span><br><span class="line">            set.add(num/<span class="number">2</span>);</span><br><span class="line">            res = Math.min(res, set.last() - set.first());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(NlogN)$</p>
<p>空间复杂度：$O(N)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>OrderedMap</tag>
      </tags>
  </entry>
  <entry>
    <title>第218场周赛</title>
    <url>/2020/12/06/cku5fjrsw003r90v4258y6mqt/</url>
    <content><![CDATA[<h3 id="T1：设计-Goal-解析器"><a href="#T1：设计-Goal-解析器" class="headerlink" title="T1：设计 Goal 解析器"></a>T1：<a href="https://leetcode-cn.com/problems/goal-parser-interpretation/">设计 Goal 解析器</a></h3><p><strong>方法一：</strong> 利用API</p>
<p>利用语言自带的API，进行替换操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">interpret</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> command.replace(<span class="string">&quot;()&quot;</span>, <span class="string">&quot;o&quot;</span>).replace(<span class="string">&quot;(al)&quot;</span>, <span class="string">&quot;al&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><strong>方法二：</strong> 枚举替换</p>
<p>一次遍历替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">interpret</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; command.length();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;G&quot;</span>);i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;(&#x27;</span> &amp;&amp; command.charAt(i+<span class="number">1</span>)==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;al&quot;</span>);</span><br><span class="line">                i+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(N)$</p>
<p>空间复杂度：$O(N)$</p>
<h3 id="T2：K-和数对的最大数目"><a href="#T2：K-和数对的最大数目" class="headerlink" title="T2：K 和数对的最大数目"></a>T2：<a href="https://leetcode-cn.com/problems/max-number-of-k-sum-pairs/">K 和数对的最大数目</a></h3><p><strong>方法一：</strong> 哈希表</p>
<p>利用哈希表来 $fre$ 来映射整数于出现次数。</p>
<p>具体做法，我们遍历数组时，先计算$k - nums_i$ 的差值 $x$</p>
<ul>
<li>如果在哈希表 $fre$ 种能够找到差值 $x$ ，说明我们找到了一对需要移除的一个数对。此时，我们需要更新一下哈希表中差值个数。如果差值为0时，说明这个数在数组中已经使用完了，此时需要移除该整数来实现去重的效果。</li>
<li>如果 $fre$ 中不存在差值，插入即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxOperations</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; fre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = k - num;</span><br><span class="line">            <span class="keyword">if</span> (fre.containsKey(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fre.get(x) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    fre.put(x, fre.get(x) - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fre.remove(x);</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fre.put(num, fre.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T3：连接连续二进制数字"><a href="#T3：连接连续二进制数字" class="headerlink" title="T3：连接连续二进制数字"></a>T3：<a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">连接连续二进制数字</a></h3><p><strong>方法一：</strong>模拟</p>
<p>可能是python的int函数优化实在是太好了，所以暴力可过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">concatenatedBinary</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            b = <span class="built_in">bin</span>(i)[<span class="number">2</span>:]</span><br><span class="line">            res += b</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(res, <span class="number">2</span>) % mod</span><br></pre></td></tr></table></figure>
<h3 id="T4：最小不兼容性"><a href="#T4：最小不兼容性" class="headerlink" title="T4：最小不兼容性"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-incompatibility/">最小不兼容性</a></h3><p>暂无思路。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>回溯</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>第219场周赛</title>
    <url>/2020/12/13/cku5fjrsx003w90v4dp6i82ti/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/">比赛中的配对次数</a></li>
<li> <a href="https://leetcode-cn.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/">十-二进制数的最少数目</a></li>
<li> <a href="https://leetcode-cn.com/problems/stone-game-vii/">石子游戏 VII</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-height-by-stacking-cuboids/">堆叠长方体的最大高度</a></li>
</ul>
<a id="more"></a>

<h3 id="T1：比赛中的配对次数"><a href="#T1：比赛中的配对次数" class="headerlink" title="T1：比赛中的配对次数"></a>T1：<a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/">比赛中的配对次数</a></h3><p><strong>方法一</strong>：模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMatches</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res += n/<span class="number">2</span>;</span><br><span class="line">                n /= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (n-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                n = (n-<span class="number">1</span>)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<p>时间复杂度：$O(logN)$</p>
<p>空间复杂度：$O(1)$</p>
<h3 id="T2：十-二进制数的最少数目"><a href="#T2：十-二进制数的最少数目" class="headerlink" title="T2：十-二进制数的最少数目"></a>T2：<a href="https://leetcode-cn.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/">十-二进制数的最少数目</a></h3><p><strong>开头</strong></p>
<p>对于 n = “123”</p>
<p><img src="https://pic.downk.cc/item/5fd5f3b23ffa7d37b375d1eb.png"></p>
<p>可以发现，最少也需要 <code>k = 3</code> 个，二进制串。<code>123 = 111 + 11 + 1</code></p>
<p>由于 n 是十进制数，所以 k 最大值为 9。即 $0 \le k \le 9$</p>
<p>我们还可以发现，这几个二进制串之间是独立的，不存在进位的情况，所以对于任意一个十进制数，我们只需要找到其中的最大值即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPartitions</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : n.toCharArray()) res = Math.max(res, c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(1)$</p>
<h3 id="T3：石子游戏-VII"><a href="#T3：石子游戏-VII" class="headerlink" title="T3：石子游戏 VII"></a>T3：<a href="https://leetcode-cn.com/problems/stone-game-vii/">石子游戏 VII</a></h3><p><strong>开头</strong></p>
<p>首先，仍然是 Alice 先手。</p>
<p>这次的游戏规则是</p>
<ul>
<li>对这排石子，两人只能 <strong>移除</strong> 最左边或者最右边的石头。</li>
<li>得分是计算 <strong>剩余所有石子的值</strong>。</li>
<li>Alice 的目标是 <strong>最大的扩大得分</strong>， Bob 的目标是 <strong>尽可能的减少得分的差距</strong></li>
</ul>
<p>如何理解<strong>尽可能的减少得分的差距</strong>，例如 <code>stones=[4,3,5]</code></p>
<p>在 Alice 操作的情况下</p>
<ul>
<li>第一步移除 <code>4</code>，得分 5+ 3 = 8，此时 <code>stones=[5,3]</code></li>
<li>Bob 操作时，Bob 会移除 <code>3</code> ，所以 Bob 得分 5，此时 <code>stones=[5]</code></li>
<li>第二步移除 <code>5</code>，得分 0</li>
</ul>
<p>所以在 Alice 的操作下，最大得分为 8，Bob 得分 5。此时的得分差距是 3</p>
<p><strong>方法一</strong>：动态规划</p>
<p>这是属于 <strong>博弈DP</strong> 的一种，博弈中决策的出发点：就是在最坏的情况中选择最好的结果</p>
<p>定义 $f[i][j]$ 为区间 $[i, j]$ 先手减去后手的最大差值。</p>
<p>定义 $s[i]$ 为区间 $[0, i]$之间的区间和。</p>
<p>下面开始推状态转移方程：</p>
<p>从 Alice 视角开始出发，当 Alice 面对的局面时 $[i, j]$ 时</p>
<ul>
<li>当 Alice 移除最左边的元素时，此时 Alice 的得分 $Sum[i, j]$，而下一手对于 Bob 而言，他面对的情况就是 $[i+1, j]$ </li>
<li>当 Alice 移除最右边的元素时，此时 Alice 的得分是 $Sum[i-1, j-1]$，而下一手对于 Bob 而言，他面对的情况就是 $[i, j-1]$</li>
<li>Alice 面对的最坏的情况就是留给 Bob 的最好的情况，我们需要选取两者中最高的得分。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stoneGameVII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =  stones.length;</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i-<span class="number">1</span>] + stones[i-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="comment">// 左右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                f[i][j] = Math.max(s[j]-s[i]-f[i+<span class="number">1</span>][j], s[j-<span class="number">1</span>]-s[i-<span class="number">1</span>]-f[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<p>时间复杂度：$O(n^2)$</p>
<p>空间复杂度：$O(n^2)$</p>
<h3 id="T4：堆叠长方体的最大高度"><a href="#T4：堆叠长方体的最大高度" class="headerlink" title="T4：堆叠长方体的最大高度"></a>T4：<a href="https://leetcode-cn.com/problems/maximum-height-by-stacking-cuboids/">堆叠长方体的最大高度</a></h3><p><strong>开头</strong></p>
<p>任意一个长方体是可以随意沿着 <code>x, y, z</code> 进行旋转操作的，我们必须要实现，从最底层开始长方体的高是逐渐递减的。</p>
<p><strong>方法一</strong>：动态规划</p>
<p>先把每个长方体的长宽高升序排序，然后再以第一个元素，第二个元素，第三个元素优先级升序排序。</p>
<p><strong>代码</strong></p>
<p>cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxHeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : w) sort(x.begin(), x.end());</span><br><span class="line">        sort(w.begin(), w.end(), greater&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">        <span class="keyword">int</span> n = w.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = w[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[j][<span class="number">0</span>] &gt;= w[i][<span class="number">0</span>] &amp;&amp; w[j][<span class="number">1</span>] &gt;= w[i][<span class="number">1</span>] &amp;&amp; w[j][<span class="number">2</span>] &gt;= w[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                    f[i] = max(f[i], f[j]+w[i][<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxHeight</span><span class="params">(<span class="keyword">int</span>[][] cuboids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] x : cuboids) &#123;</span><br><span class="line">            Arrays.sort(x);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(cuboids, ((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">1</span>] == o2[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o2[<span class="number">2</span>] - o1[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o2[<span class="number">0</span>] - o1[<span class="number">0</span>];</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">//  for (int[] ints : cuboids) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(Arrays.toString(ints));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> n = cuboids.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = cuboids[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cuboids[j][<span class="number">0</span>] &gt;= cuboids[i][<span class="number">0</span>] &amp;&amp; cuboids[j][<span class="number">1</span>] &gt;= cuboids[i][<span class="number">1</span>] </span><br><span class="line">                &amp;&amp; cuboids[j][<span class="number">2</span>] &gt;= cuboids[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                    f[i] = Math.max(f[i], f[j] + cuboids[i][<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(f[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：$O(N^2logN)$</p>
<p>空间复杂度：$O(N)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>回溯</tag>
        <tag>DP</tag>
        <tag>动态规划</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第220场周赛</title>
    <url>/2020/12/20/cku5fjrsy003y90v47p8987i8/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/reformat-phone-number/">重新格式化电话号码</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-erasure-value/">删除子数组的最大得分</a></li>
<li><a href="https://leetcode-cn.com/problems/jump-game-vi/">跳跃游戏 VI</a></li>
<li><a href="https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/"> 检查边长度限制的路径是否存在</a></li>
</ul>
<p>示例代码：c++</p>
<a id="more"></a>

<h3 id="T1：重新格式化电话号码"><a href="#T1：重新格式化电话号码" class="headerlink" title="T1：重新格式化电话号码"></a>T1：<a href="https://leetcode-cn.com/problems/reformat-phone-number/">重新格式化电话号码</a></h3><p>方法一：模拟</p>
<p>我们先去掉所有的“-” 和 “ ” 。尽可能的每次取三个数，然后直到仅剩下4个数时，停止取数，然后根据分块规则进行格式化即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reformatNumber</span><span class="params">(<span class="built_in">string</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : number)</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> &amp;&amp; c != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                s += c;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.size(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.size() - i &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                res += s.substr(i, <span class="number">3</span>);</span><br><span class="line">                i += <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> k = s.size() - i;</span><br><span class="line">                <span class="keyword">if</span> (k &lt;= <span class="number">3</span>) res += s.substr(i, k);</span><br><span class="line">                <span class="keyword">else</span> res += s.substr(i, <span class="number">2</span>) + <span class="string">&quot;-&quot;</span> + s.substr(i+<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">                i += <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<h3 id="T2：删除子数组的最大得分"><a href="#T2：删除子数组的最大得分" class="headerlink" title="T2：删除子数组的最大得分"></a>T2：<a href="https://leetcode-cn.com/problems/maximum-erasure-value/">删除子数组的最大得分</a></h3><p><strong>开头</strong></p>
<p>我们需要删除一个含有 <strong>若干个不同元素</strong> 的子数组，也就是说我们要找出数组和最大的无重复元素的连续子数。而且看数据范围提示， $nums[i]$ 全部都是正数，因此这个不重复子数组只要足够长，那么它就是最大得分。</p>
<p>方法一：双指针</p>
<p>移动规则：</p>
<ul>
<li>右指针是不断向右边扩展的，此时需要记录当前区间的和</li>
<li>当遇到重复的元素时，左指针再收缩</li>
<li>关于去重，我们可以使用哈希表来记录</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumUniqueSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">// 无序 hash表，效果类似于 Java中的HashMap</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res=  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, s=  <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x=  nums[i];</span><br><span class="line">            hash[x]++;</span><br><span class="line">            s += x;</span><br><span class="line">            <span class="keyword">while</span> (hash[x] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                s -= nums[j];</span><br><span class="line">                hash[nums[j++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<p>方法二：前缀和+哈希表</p>
<p>思路：</p>
<p>提前计算好前缀和，再借助哈希表来记录上一次元素的出现位置，依次计算当前位置与上一次出现位置的区间和。</p>
<p>算法表述图如下</p>
<p><img src="https://pic.downk.cc/item/5fdf29783ffa7d37b38e5345.png"></p>
<p>假设某一个元素的当前位置为 $i$，那么在区间 $[0, i]$ 之间存在一个位置 $j$，$j$ 对应的元素等于当前位置 ，此时计算出区间和 $Sum_{i+1} - Sum_{j+1}$ ，其中 $Sum$ 为前缀和。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumUniqueSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i];</span><br><span class="line">             <span class="keyword">if</span> (f.find(nums[i]) != f.end() &amp;&amp; j &lt;= f[nums[i]]) &#123;</span><br><span class="line">                j = f[nums[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = max(res, s[i+<span class="number">1</span>] - s[j]);</span><br><span class="line">            f[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<h3 id="T3：跳跃游戏-VI"><a href="#T3：跳跃游戏-VI" class="headerlink" title="T3：跳跃游戏 VI"></a>T3：<a href="https://leetcode-cn.com/problems/jump-game-vi/">跳跃游戏 VI</a></h3><p>方法一：动态规划（可能TLE）</p>
<p>我们设置 $f[i]$ 为从 0 到 $i$ 能拿到的最大得分。</p>
<p>那么假设，此时我们在任意一点 $i$ 处时，此时方案一共有  $i - j = k$  个</p>
<p><img src="https://pic.downk.cc/item/5fdf2e243ffa7d37b391dde9.png"></p>
<p>那么不难推出动态转移方程为：<br>$$<br>f[i] = max{f[k]} + nums[i]，其中 i \le k \le j \ \<br>f[0] = nums[0]，第一个元素是必选的<br>$$<br>那么根据数据规模的 $10^5$ 来看，我们的这个方程式对应的算法时间复杂度为 $O(n*k)$ 。所以此方法是可能会 TLE 的。</p>
<p>方法二：动态规划+单调队列 优化</p>
<p>根据上述的公式，可以发现在状态转移的过程中，最耗时的部分就是在区间 $[j, i]$，找出最大值。</p>
<p>这个动作，我们可以借助单调队列来实现 $O(1)$ ，以此来进行时间上的优化，相对于原本的 $O(k)$ 而言是绝对可以通过的。</p>
<p><strong>单调队列</strong></p>
<p>我们可以借助 <strong>双端队列(Deque)</strong> 实现，假设区间长度为 $k$ 时：</p>
<ul>
<li>当遍历当前元素位置大于区间长度 $k$ 时，我们清理掉所有小于 $i - k$  位置的元素</li>
<li>然后再计算对头最大元素即对应方程中 $max{f[k]}, i \le k \le j$</li>
<li>删除所有小于等于 $f[i]$ 的元素，保证 $deque$ 的递减性</li>
<li>再把 $i$ 加入到 $deque$</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q.front()&lt; i - k) q.pop_front();</span><br><span class="line">            f[i] = f[q.front()] + nums[i];</span><br><span class="line">            <span class="keyword">while</span> (q.size() &amp;&amp; f[q.back()] &lt;= f[i]) q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<h3 id="T4：检查边长度限制的路径是否存在"><a href="#T4：检查边长度限制的路径是否存在" class="headerlink" title="T4：检查边长度限制的路径是否存在"></a>T4：<a href="https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/">检查边长度限制的路径是否存在</a></h3><p>方法一：排序 + 并查集</p>
<p><strong>开头</strong></p>
<p>题目要求，给出一个无向图的边集，然后提前给出多组查询条件（可以理解为<strong>离线</strong>）。也就是说，可以不必按照特定的顺序进行查询。我们进行排序操作后，对时间复杂度有一定的把握。</p>
<p>与 <strong>离线</strong> 对应的 <strong>在线</strong>，即一次只给出一组查询，必须按照给出顺序进行查询。这样的操作会使时间复杂度无法确定。</p>
<p>思路：</p>
<p>本题是给出了所有的查询要求，所以基于 “缓存” 的思想，我们可以按照 $queries$ 的 $limit_j$ 来进行排序。</p>
<p>同样的，我们可以对边长 $edgeList$ 的 $dis_i$ 进行排序。</p>
<p>我们处理所有的询问时，借助并查集维护图的连通性，对于 $queries_i = (p_i, q_i, limit_i)$ 时，我们需要不断的向并查集中添加 $edgeList_j$ $dis_j \le limit_i$ 的边，然后再验证 $p_i 和 q_i$ 连通性。   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="comment">// a -&gt; 起点；b -&gt; 终点；c -&gt; dis；d -&gt; 原 queries_i 位置</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="comment">// 重载 &lt; 为了方便排序操作，如果不重载，请传入 lambda表达式 或者 cmp 函数</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[N], q[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != f[x]) f[x] = find(f[x]);</span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">distanceLimitedPathsExist</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ee, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; qq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = ee.size(), k = qq.size();</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">            e[i] = &#123;ee[i][<span class="number">0</span>], ee[i][<span class="number">1</span>], ee[i][<span class="number">2</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">            q[i] = &#123;qq[i][<span class="number">0</span>], qq[i][<span class="number">1</span>], qq[i][<span class="number">2</span>], i&#125;;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sort(e, e + m), sort(q, q + k);</span><br><span class="line">        <span class="comment">// 初始化 并查集 </span></span><br><span class="line">        f.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[i] = i;</span><br><span class="line">        <span class="comment">// 结果数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 不断的添加边 直到 dis_j &gt;= limit_i</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; e[j].c &lt; q[i].c) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = e[j].a, b = e[j].b;</span><br><span class="line">                f[find(a)] = find(b);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 验证连接性</span></span><br><span class="line">            res[q[i].d] = is_connected(q[i].a, q[i].b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(NlogN)$</p>
<p>空间复杂度：$O(n)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>排序</tag>
        <tag>单调队列</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>第221场周赛</title>
    <url>/2020/12/29/cku5fjrt2004390v4d1apchs3/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/determine-if-string-halves-are-alike/">判断字符串的两半是否相似</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">吃苹果的最大数目</a></li>
<li> <a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/">球会落何处</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">与数组中元素的最大异或值</a></li>
</ul>
<a id="more"></a>

<h4 id="T1：判断字符串的两半是否相似"><a href="#T1：判断字符串的两半是否相似" class="headerlink" title="T1：判断字符串的两半是否相似"></a>T1：<a href="https://leetcode-cn.com/problems/determine-if-string-halves-are-alike/">判断字符串的两半是否相似</a></h4><p>方法一：模拟</p>
<p>同时遍历，字符串的前一部分和后一部分，统计出现的元音字符，然后判断相等即可</p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">halvesAreAlike</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="title">ss</span><span class="params">(&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">            <span class="keyword">char</span> c2 = <span class="built_in">tolower</span>(s[n<span class="number">-1</span>-i]);</span><br><span class="line">            <span class="keyword">if</span> (ss.count(c1)) s1++;</span><br><span class="line">            <span class="keyword">if</span> (ss.count(c2)) s2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1 == s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(1)$，<code>unordered_set</code>  空间是固定大小</p>
<h4 id="T2：吃苹果的最大数目"><a href="#T2：吃苹果的最大数目" class="headerlink" title="T2：吃苹果的最大数目"></a>T2：<a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">吃苹果的最大数目</a></h4><p>方法一：贪心 + 优先队列</p>
<p><strong>开头</strong></p>
<p>观察数据范围，可以发现是 $10^4$ 级别的。$1 \le n \le 2 * 10^4$ ，$0 \le days[i] \le 2 * 10^4$，所以我们最多可以吃掉 $4 * 10^4$ 个苹果。算法时间复杂度得保证为 $O(NlogN) $ 或者 $O(N)$。</p>
<p><strong>思路</strong></p>
<p>贪心策略：对于任意一天 <code>i</code> ，我们都应该选择 <strong>吃最先要过期的苹果</strong> 。</p>
<p>那么如何证明贪心解是符合最优解呢？将贪心解替换为最优解</p>
<p>假设在某一天 <code>i</code> 时，</p>
<p><img src="https://pic.downk.cc/item/5fea7fc13ffa7d37b3aa6bda.png"></p>
<p>对于贪心解，我们选择吃掉的是 $T_i $ 天要过期的苹果，而最优解吃掉的是 $T_j$ 天要过期的苹果。对于贪心解我们的策略是吃掉要过期的苹果，因此可以假设 $T_i \le T_j$ ，把贪心解替换为 $T_j$，由于此时的 $T_i \le T_j$ 的，所以贪心是符合的。所以 $T_j$ 替换 $T_j$ 是可行的，因此贪心是符合最优解的。</p>
<p>在构思代码时，需要借助优先队列这一数据结构实现每次<strong>吃最先要过期的苹果</strong>，以此降低时间复杂度。</p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eatenApples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; apples, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;</span><br><span class="line">        <span class="keyword">int</span> n = apples.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 本题目，最多可以吃 40000 个苹果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 今天有长出的新苹果，加入优先队列</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; n &amp;&amp; apples[i] &gt; <span class="number">0</span>) </span><br><span class="line">                heap.push(&#123;i + days[i] - <span class="number">1</span>, apples[i]&#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把过期的苹果都扔掉</span></span><br><span class="line">            <span class="keyword">while</span> (heap.size() &amp;&amp; heap.top().first &lt; i) heap.pop();</span><br><span class="line">            <span class="keyword">if</span> (heap.empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 今天有苹果可以吃</span></span><br><span class="line">            <span class="keyword">auto</span> top = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="comment">// 如果未过期就加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (--top.second)</span><br><span class="line">                heap.push(top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(NlogN)$，优先队列调整子节点，时间复杂度为 $O(logN)$，一共有 $N = 40000$次。</p>
<p>空间复杂度：$O(N)$</p>
<h4 id="T3：球会落何处"><a href="#T3：球会落何处" class="headerlink" title="T3：球会落何处"></a>T3：<a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/">球会落何处</a></h4><p>方法一：模拟</p>
<p>对于网格的任意一栏 $column_i$，我们在第一行的所有列都放下一个球，然后记录从该 $column_i$栏放下球后，球的最终出口位置 $column_j$。如果不能到达最后一行，则返回 -1。</p>
<p>那么分析之后，球在下落的过程中，有以下几种情况：</p>
<ol>
<li><p>这种情况下，球会被卡死，我们记录为 -1</p>
<p> <img src="https://pic.downk.cc/item/5fea85473ffa7d37b3b0ba96.png"></p>
</li>
<li><p>在边界的情况下，球也会被卡死</p>
<p> <img src="https://pic.downk.cc/item/5fea85b63ffa7d37b3b15871.png"></p>
<p> <img src="https://pic.downk.cc/item/5fea85e13ffa7d37b3b19492.png"></p>
</li>
</ol>
<p>在以上三种情况下，球才会卡死。我们在模拟下落时，避开这三种情况即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findBall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = i;</span><br><span class="line">            <span class="keyword">while</span> (x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (y == n <span class="number">-1</span> || grid[x][y+<span class="number">1</span>] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> x++, y++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (y == <span class="number">0</span> || grid[x][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> x++, y--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m) res[i] = y;</span><br><span class="line">            <span class="keyword">else</span> res[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N^2)$</p>
<p>空间复杂度：$O(N)$</p>
<h4 id="T4：与数组中元素的最大异或值"><a href="#T4：与数组中元素的最大异或值" class="headerlink" title="T4：与数组中元素的最大异或值"></a>T4：<a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">与数组中元素的最大异或值</a></h4><p><strong>开头</strong></p>
<p>观察数据的规模，确认是 $10^5$ 级别的数据量。因此任何 $O(N^2)$ 的算法，都不可能通过本题。但是，这里仍然给出 $TLE$ 代码，然后再后续优化算法。</p>
<p>方法一：暴力（TLE）</p>
<p>直接暴力循环，枚举所有的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maximizeXor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = queries.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> query = queries[i];</span><br><span class="line">            <span class="keyword">int</span> x = query[<span class="number">0</span>], m = query[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> res = INT_MIN, f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt;= m) &#123;</span><br><span class="line">                    f = <span class="number">1</span>;</span><br><span class="line">                    res = max(res, nums[j] ^ x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = f ? res : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N^2)$</p>
<p>空间复杂度：$O(N)$</p>
<p>方法二：贪心 + 前缀树（Trie）</p>
<p><strong>开头</strong></p>
<p><strong>异或规则</strong>：相同为0，不同为1。</p>
<p>本题 $0 \le nums[i] \le 10^9$，所以二进制数一共有 <strong>31</strong> 位。本题的前缀树和经典的前缀树不同，该题中要构造的前缀树的子节点仅含 <code>0</code> 和 <code>1</code>，是一个数从最高位开始，向下延申。因此对于 $10^5$ 且 数据本身为 $10^9$ 的数据量，我们需要构造的字典树大小为 <code>3100000 * 2</code> 这是最为保险的估计量。</p>
<p>在本题，我们需要计算出在不大于 $queries[i][1]$ 的情况下，计算每一个查询中$max \{ queries[i][0] \ \ XOR \ \ nums[j] \}$。那么根据<strong>异或规则</strong>，我们要尽可能的让每一位都不同，这样才能让结果产生更多的1，那么结果就更大。</p>
<p>比如$A = 101010101 …. 101$ 时，假设 $A$ 为某一个 31 位二进制数，我要尽可能在不大于 $queries[i][1]$ 的集合中，找出这样一个数<br>$$<br>A = 101010101 …. 101 \\<br>B = 010101010 …. 010 \\<br>res = 111111111 …. 111<br>$$<br>在理想情况下，我们可以找到一个 $B$ 满足恰好每一位都与 $A$ 都是相反的，得到的 $res$ 所有位全为 <code>1</code>。</p>
<p>现实情况是，我们要尽可能找到一个 $B$ ，使得 $B$ 中有更多位满足上述情况。这是贪心策略的体现。</p>
<p>对于前缀树，对于任何一位上的 <code>0</code> 或者 <code>1</code>，我们的选择树如下：</p>
<p><img src="https://pic.downk.cc/item/5fea956b3ffa7d37b3c8d80d.png"></p>
<p>root 表示为 查询数 $X$ 的某一位，如果 $root == 1$ ，在子树 <code>0</code> 存在的下，我们将会抛弃子树 <code>1</code>  来剪枝。那么对于原本的集合，我们将会去掉 <code>1</code> 那部分。</p>
<p><img src="https://pic.downk.cc/item/5fea95d53ffa7d37b3c989bd.png"></p>
<p>对于集合的另一部分，<code>0</code> 也是同理，不断缩小集合范围，最终找到最大的 $XOR$ 值。</p>
<p>值得注意的是，本题中是<strong>已经给出了所有的查询</strong>，因此查询本身的顺序并不重要，所以我们可以对查询进行预处理。</p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, m, k;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node&amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m &lt; t.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">3100000</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从最高位 开始插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数据本身 最高31 位，因此移动30位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 不存在路径，就创建</span></span><br><span class="line">            <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 路径不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!idx) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i--) &#123;</span><br><span class="line">            <span class="comment">// 取反去最高位</span></span><br><span class="line">            <span class="keyword">int</span> u = !(x &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 该位 贡献一个1</span></span><br><span class="line">            <span class="keyword">if</span> (son[p][u]) p = son[p][u], res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="comment">// 相反的数，不存在，只能去相同的路径</span></span><br><span class="line">            <span class="keyword">else</span> p = son[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maximizeXor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span> son);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = queries.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            q[i] = &#123;queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        sort(q, q+m);</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] &lt;= q[j].m) insert(nums[i++]);</span><br><span class="line">            res[q[j].k] = search(q[j].x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(NlogN) + O(MlogM)$，其中 N 为数组长度， M 为查询次数。</p>
<p>空间复杂度：$O(31<em>2</em>N + M)$，其中<code>31</code>表示 <code>int</code> 范围内，二进制数的位数。<code>M</code> 为查询次数</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>位运算</tag>
        <tag>动态规划</tag>
        <tag>堆</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>第222场周赛</title>
    <url>/2021/01/03/cku5fjrt2004590v4fzs60q98/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/maximum-units-on-a-truck/">卡车上的最大单元数</a></li>
<li> <a href="https://leetcode-cn.com/problems/count-good-meals/">大餐计数</a></li>
<li> <a href="https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/">将数组分成三个子数组的方案数</a></li>
<li> <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">得到子序列的最少操作次数</a></li>
</ul>
<a id="more"></a>

<h4 id="T1：卡车上的最大单元数"><a href="#T1：卡车上的最大单元数" class="headerlink" title="T1：卡车上的最大单元数"></a>T1：<a href="https://leetcode-cn.com/problems/maximum-units-on-a-truck/">卡车上的最大单元数</a></h4><p>方法一：贪心算法</p>
<p>贪心策略：我们优先装载单元数量最多的箱子。</p>
<p>如何证明贪心是最优解？</p>
<p>因为卡车只能装载 $truckSize$ 个箱子，也就是说我们只能选择固定数量的箱子，而每一个箱子装载的单元格数量是不同的，因此我们只要先装载单元格多的箱子，就可以装载最大总数的单元格。</p>
<p><strong>代码</strong></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumUnits</span><span class="params">(<span class="keyword">int</span>[][] boxTypes, <span class="keyword">int</span> truckSize)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(boxTypes, (o1, o2) -&gt; o2[<span class="number">1</span>] - o1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] box : boxTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (truckSize &lt; box[<span class="number">0</span>]) &#123;</span><br><span class="line">                res += truckSize * box[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res +=  box[<span class="number">0</span>] * box[<span class="number">1</span>];</span><br><span class="line">            truckSize -= box[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(NlogN)$</p>
<p>空间复杂度：$O(1)$</p>
<h4 id="T2：大餐计数"><a href="#T2：大餐计数" class="headerlink" title="T2：大餐计数"></a>T2：<a href="https://leetcode-cn.com/problems/count-good-meals/">大餐计数</a></h4><p><strong>开头</strong></p>
<p><strong>大餐</strong>的定义：数组中两个数的和恰好是 <code>2</code> 的幂。假设数组中存在两个数 <code>2</code> 和 <code>6</code> ，它们下标不同，<code>2 + 6 = 8</code> 这就是一个<strong>大餐</strong>。 </p>
<p>注意观察数据量，数组长度为 $10^5$ 且 数组中的值最大为 $2^{20}$。那么也就是说，两数之和的最大值为 $2^{21}$ 。</p>
<p>方法一：哈希表</p>
<p>假设在数组中要找出 $x + t = 2^k$ ，那么我们直接枚举 $[0, k], 0 \le k \le 21$ ，反过来寻找 $t = 2^k - x$ 。我们还需要统计每一个 $t$  的出现次数，找到了就直接加上出现次数。</p>
<p><img src="https://pic.downk.cc/item/5ff1b9c03ffa7d37b3cf951f.jpg"></p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : d) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">22</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (<span class="number">1</span> &lt;&lt; k) - x;</span><br><span class="line">                <span class="keyword">if</span> (hash.count(t)) res = (res + hash[t]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(22*N)$</p>
<p>空间复杂度：$O(N)$</p>
<h4 id="T3：将数组分成三个子数组的方案数"><a href="#T3：将数组分成三个子数组的方案数" class="headerlink" title="T3：将数组分成三个子数组的方案数"></a>T3：<a href="https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/">将数组分成三个子数组的方案数</a></h4><p>方法一：前缀和 + 双指针</p>
<p><strong>开头</strong></p>
<p>我们需要把数组划分为三个部分，分别为 $[0, left], [left+1, mid], [mid+1, right]$ ，使得 $Sum[0, left] &lt;= Sum[left+1, mid] \ &amp; \ Sum[left+1, mid] \le Sum[mid+1, right] $。$Sum$ 表示区间和。</p>
<p>在 快速求得连续区间的和，我们可以借助前缀和在 $O(1)$ 时间实现，剩下的事情就是如何划分区间的问题。</p>
<p>假设存在如下一种划分情况，区间 $A \le B \le C$</p>
<p><img src="https://pic.downk.cc/item/5ff1bc8a3ffa7d37b3d3f8a3.jpg"></p>
<p>如下图，存在一种分割方案$A = Sum[0, x-1], B = Sum[x, i-1], C = Sum[i, n-1]$</p>
<p><img src="https://pic.downk.cc/item/5ff1bd263ffa7d37b3d4d511.jpg"></p>
<p>此时是满足 $A \le B \le C$，对于某一个位置 $i$ 而言，存在一个合理的分割方案 $x$ ，我们可以找出 $x$ 的下界 $j$ 。换句话就是，$x$ 的最小范围取值可以是多少。对于 $k$ 也是同理，我们可以找出 $x$ 的最大范围可以取多少。</p>
<p>由于数组中都是非负整数，因此存在单调性。</p>
<p>不难发现，当 $j$ 向左边移动时， $A$ 是不断减少的，即 $B$ 是在不断增加的。我们要保证 $B \le C$。那么相反的，我们让 $j$ 不断向右移动，$B$ 是不断减少的，当 $B \le C$ 时我们就可以停止。</p>
<p>对于 $k$ 来说，当 $k$ 不断向右移动时，此时的 $A$ 是不断增加的，$B$ 是不断减小的，因此我们要保证 $A \le B$ 。</p>
<p>找出对于固定的 $i$  来说，存在一个 $x$ ，我们只要找出其上下界 $[j, k]$ ，那么在 $i$ 贡献的分割方案为 $k - j + 1$。</p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToSplit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">2</span>, k = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 B &gt; C 向右移动，减小 B</span></span><br><span class="line">            <span class="keyword">while</span> (s[n] - s[i<span class="number">-1</span>] &lt; s[i<span class="number">-1</span>] - s[j<span class="number">-1</span>]) j++;</span><br><span class="line">            <span class="comment">// 如果 A &lt;= B 的情况下，k 最大能到哪个位置 </span></span><br><span class="line">            <span class="keyword">while</span> (k + <span class="number">1</span> &lt; i &amp;&amp; s[k] &lt;= s[i<span class="number">-1</span>] - s[k]) k++;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= k &amp;&amp; s[k<span class="number">-1</span>] &lt;= s[i<span class="number">-1</span>] - s[j<span class="number">-1</span>] &amp;&amp; s[i<span class="number">-1</span>] - s[j<span class="number">-1</span>] &lt;= s[n] - s[i<span class="number">-1</span>]) </span><br><span class="line">                res = (res + k - j + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$</p>
<p>空间复杂度：$O(N)$</p>
<h4 id="T4：得到子序列的最少操作次数"><a href="#T4：得到子序列的最少操作次数" class="headerlink" title="T4：得到子序列的最少操作次数"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">得到子序列的最少操作次数</a></h4><p>方法一：动态规划 + 二分</p>
<p><strong>开头</strong></p>
<p>在 $arr$ 中插入若干个整数后，可以在 $arr$ 中找到 $target$ 子序列。简而言之，就是去除掉 $target$ 和 $arr$ 的公共部分后，$target$ 中还剩下多少个元素的问题。</p>
<p>那么问题就可以转换为，$arr$ 和 $target$ 的最长公共子序列问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">target = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">		  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="comment">// arr 下标为 target 中的下标</span></span><br><span class="line">arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">	   <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>	<span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  </span><br><span class="line">		  </span><br></pre></td></tr></table></figure>
<p>可以发现，$target$ 子序列的出现位置，在 $arr$ 中仍然是递增的特性。那么反过来，相应的，假如在 $target$ 中存在$arr$ 的子序列，$[1, 3]$ ，那么其对应下标在 $arr$ 中也仍然是递增的。 </p>
<p>那么求两个数组的最长公共子序列，该算法的时间复杂度为 $O(N^2)$ 的，显然是不能通过代码。</p>
<p>定义：$q[i]$ 为长度为 $i$ 的最长上升子序列，$q[i]$ 是严格递增的。</p>
<p>对于 $target[i]$ ，如果出现在 $arr$ 中，则统计其下标。</p>
<p>那么对于任意一个 $a[i]$ 来说，我们在 $q[i]$ 中二分找出比 $a[i]$ 大的下标，如果不存在就把 $a[i]$ 加入末尾元素。</p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.size(); i++) pos[target[i]] = i;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos.count(x)) a.push_back(pos[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// len 为最长上升子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : a) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">            <span class="comment">// 尝试在 a[i] 中寻找比 q[len-1] 大的数</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>)&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt; x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在末尾更新</span></span><br><span class="line">            len = max(len, r + <span class="number">1</span>);</span><br><span class="line">            q[r+<span class="number">1</span>] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// len 为最长公共子序列的长度，要插入数据为 target.size() - len</span></span><br><span class="line">        <span class="keyword">return</span> target.size() - len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(NlogN)$</p>
<p>空间复杂度：$O(N)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>第224场周赛</title>
    <url>/2021/01/17/cku5fjrt3004a90v4d93b05qs/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">可以形成最大正方形的矩形数目</a></li>
<li> <a href="https://leetcode-cn.com/problems/tuple-with-same-product/">同积元组</a></li>
<li> <a href="https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/">重新排列后的最大子矩阵</a></li>
<li> <a href="https://leetcode-cn.com/problems/cat-and-mouse-ii/">猫和老鼠 II</a></li>
</ul>
<a id="more"></a>

<h4 id="T1：可以形成最大正方形的矩形数目"><a href="#T1：可以形成最大正方形的矩形数目" class="headerlink" title="T1：可以形成最大正方形的矩形数目"></a>T1：<a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">可以形成最大正方形的矩形数目</a></h4><p>思路：</p>
<p>对于 $v[i] = min(rectangles[i][0], rectangles[i][1]$ ，我们需要记录 $maxLen = max{v[i]}$，然后再统计 $v[i] \ge maxLen$ 的个数。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodRectangles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = r.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) v[i]=min(r[i][<span class="number">0</span>],r[i][<span class="number">1</span>]),ma=max(ma,v[i]);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : v) <span class="keyword">if</span> (x &gt;= ma) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>时间复杂度：$O(N)$</p>
<p>空间复杂度：$O(N)$</p>
<h4 id="T2：同积元组"><a href="#T2：同积元组" class="headerlink" title="T2：同积元组"></a>T2：<a href="https://leetcode-cn.com/problems/tuple-with-same-product/">同积元组</a></h4><p>思路：</p>
<p>根据题意中 $nums = [2,3,4,6]$，可知 $(a,b,c,d)$ 为一个元组，假设 $(a,b)=[3,4], (c,d)=[2,6]$</p>
<p>可以发现，扩展一下 $(b,a)$ 和 $(d,c)$ ，每一对内部互换的话，仍可以满足要求。$(c,d)$ 和 $(a,b)$ 互换也是符合要求的，所以每一次互换提供 2 个满足的元组，那么一对 $(a,b,c,d)$ 可以贡献 $2^3$ 个元组。</p>
<p>我们只需要记录下， $a*b，a \ne b$ 的元素个数即可。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tupleSameProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j  = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                res += <span class="number">8</span> * hash[nums[i]*nums[j]];</span><br><span class="line">                hash[nums[i] * nums[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>时间复杂度：$O(N^2)$</p>
<p>空间复杂度：$O(N^2)$</p>
<h4 id="T3：重新排列后的最大子矩阵"><a href="#T3：重新排列后的最大子矩阵" class="headerlink" title="T3：重新排列后的最大子矩阵"></a>T3：<a href="https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/">重新排列后的最大子矩阵</a></h4><p>思路：</p>
<p>定义：$matrix[i][j]$ 为以 $(i,j)$ 为结尾向上连续1的最大长度。</p>
<p>对于这个问题，我们可以问题转化为，求柱状图的最大面积来做。</p>
<p><strong>具体做法</strong>：</p>
<p>我们需要预处理原数组，计算出每一行的”高”，即在点 $(i,j)$ 处，以 <code>1</code> 结尾的可以向上连续1的最大长度。</p>
<p>由于我们可以按照 <code>列</code> 任意顺序重新排列，那么我们对”高”进行排序，从最高点开始枚举。</p>
<p>为了方便理解，假设一个情况下，预处理完毕后的某一行数组的高度如下：</p>
<p><img src="https://img.imgdb.cn/item/6003fad63ffa7d37b381c53a.jpg"></p>
<p>由于我们任意的交换列，所以我们可以对进行降序排序，然后再计算最大面积</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSubmatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = w.size(), m = w[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                <span class="keyword">if</span> (w[i][j]) w[i][j]+= w[i<span class="number">-1</span>][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) q[j] = w[i][j];</span><br><span class="line">            <span class="comment">// 降序排序</span></span><br><span class="line">            sort(q.begin(), q.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 枚举所有的高 * 宽</span></span><br><span class="line">                res = max(res, q[j] * (j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：$O(N * MlogM)$</p>
<p>空间复杂度：$O(1)$</p>
<h4 id="T4：猫和老鼠-II"><a href="#T4：猫和老鼠-II" class="headerlink" title="T4：猫和老鼠 II"></a>T4：<a href="https://leetcode-cn.com/problems/cat-and-mouse-ii/">猫和老鼠 II</a></h4><p>暂无思路</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第228场周赛</title>
    <url>/2021/02/14/w228/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>比赛链接：<a href="https://leetcode-cn.com/contest/weekly-contest-228/">第 228 场周赛</a></p>
<p>题目单：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/">生成交替二进制字符串的最少操作数</a></li>
<li><a href="https://leetcode-cn.com/problems/count-number-of-homogenous-substrings/">统计同构子字符串的数目</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/"> 袋子里最少数目的球</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/"> 一个图中连通三元组的最小度数</a></li>
</ul>
<h1 id="T1：生成交替二进制字符串的最少操作数"><a href="#T1：生成交替二进制字符串的最少操作数" class="headerlink" title="T1：生成交替二进制字符串的最少操作数"></a>T1：<a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/">生成交替二进制字符串的最少操作数</a></h1><p>由交替字符串的定义，我们可以知道像 $010101…$ 和 $101010…$ 这种字符串是<strong>交替二进制字符串</strong>。</p>
<p>那么， 我们的标准只有两个，要么是变成 $0101$ 交替组成的字符串，要么是变成 $1010$ 交替组成的字符串。</p>
<p>因此，我们同时变换成两种标准的交替二进制字符串，然后取最小值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>其中 $n1$ 代表的是 $1010…$ ，$n2$ 代表的是 $0101…$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="comment">// 010101  101010</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                n2 += s[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                n1 += s[i] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n2 += s[i] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                n1 += s[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中$N$ 为字符串的长度。我们只会遍历一次字符串。</p>
<p>空间复杂度：$O(1)$</p>
<h1 id="T2：统计同构子字符串的数目"><a href="#T2：统计同构子字符串的数目" class="headerlink" title="T2：统计同构子字符串的数目"></a>T2：<a href="https://leetcode-cn.com/problems/count-number-of-homogenous-substrings/">统计同构子字符串的数目</a></h1><blockquote>
<p>​    同构字符串：如果一个字符串种的所有字符都相同，那么该字符串就是同构字符串</p>
</blockquote>
<p>观察用例 <code>s = abbcccaa</code></p>
<p><code>c</code> 出现 $3$ 次，<code>cc</code> 出现 $2$ 次，<code>ccc</code> 出现 $1$ 次。</p>
<p>假设 <code>ccc....c</code> 存在 $n$ 个连续的字串，那么：</p>
<ol>
<li>$n$ 个 <code>c</code></li>
<li>$n-1$ 个 <code>cc</code></li>
<li>$n - 2$ 个 <code>ccc</code></li>
<li>…..</li>
<li>$1$ 个 <code>ccc....c</code></li>
</ol>
<p>所以，这段连续 $n$ 个 <code>ccc....c</code> 一共贡献了<br>$$<br>1 + 2 + 3 + 4 + … +n = \frac{n \times (n + 1)}{2}<br>$$<br>$\frac{n \times (n + 1)}{2}$ 个同构字符串。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>注意了，假设用例中存在全是同一个字符的情况下，那么 $10 ^ 5 \times (10 ^ 5 + 1)$，此时会爆 <code>int</code>。所以需要用 <code>long long</code>，64位的整数变量。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHomogenous</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; s[i] == s[j]) j++;</span><br><span class="line">            LL count = j - i;</span><br><span class="line">            ans += count * (count + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            ans %= mod;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。我们至多只有遍历一次字符串。</p>
<p>空间复杂度：$O(1)$</p>
<h1 id="T3：袋子里最少数目的球"><a href="#T3：袋子里最少数目的球" class="headerlink" title="T3：袋子里最少数目的球"></a>T3：<a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/">袋子里最少数目的球</a></h1><p>我们可以转换一下问题。</p>
<blockquote>
<p>​    在不超过 $maxOperations$ 的操作次数下，使得每个袋子里球的<strong>最大数目</strong>不超过 $y$  个。</p>
</blockquote>
<p>当 $y$ 增加时，我们的操作次数就会减少，那么 $y$ 的大小就具有单调性。因此可以二分进行查找。</p>
<p>假设对于单个袋子里的 $x$ 个球：</p>
<ul>
<li>如果 $x \ mod  \ y = 0$，此时可以整除 $y$ 时，可以进行 $\frac{x}{y}$ 操作。</li>
<li>如果 $x \ mod \ y \ne 0$，此时不能整除 $y$ 时，我们直接下取整 $\lfloor \frac{x}{y} \rfloor$</li>
</ul>
<p>那么，分类讨论后，我们可以发现 $\lfloor \frac{x - 1}{y} \rfloor$ 和上述讨论的结果实际上是等价的。</p>
<p>因此，对于数组中的 $N$ 个袋子，我们都有上述的操作方案。那么：<br>$$<br>\sum_{x \ \in \ nums} \lfloor \frac{x - 1}{y} \rfloor \le maxOperations<br>$$</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> y, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : nums) &#123;</span><br><span class="line">            count += (x - <span class="number">1</span>) / y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= maxOperations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, y, maxOperations)) right = y;</span><br><span class="line">            <span class="keyword">else</span> left = y + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N logC)$，其中 $N$ 为数组的长度，$C$ 为 $max(nums)$ 数组中的最大值，$C$ 不超过 $10^9$。</p>
<ul>
<li><p>我们会进行 $logC$ 次二分查找。</p>
</li>
<li><p>每一次二分查找，我们需要遍历数组验证操作数是否超过 $maxOperations$的次数。时间复杂度$O(N)$。</p>
</li>
</ul>
<p>空间复杂度：$O(1)$</p>
<h1 id="T4：一个图中连通三元组的最小度数"><a href="#T4：一个图中连通三元组的最小度数" class="headerlink" title="T4：一个图中连通三元组的最小度数"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/">一个图中连通三元组的最小度数</a></h1><blockquote>
<p>​    三元组：是指三个点组成的集合，且三个点之间是两两存在边的</p>
<p>​    联通三元组的度数：是指将这个三元组的集合视作一个“点” 。然后这个“点“ 和其他点的度数之和（无向图只要某个点存在一条边，那么这个点的度数就可以 +2），集合内部点的度数则不参与计算。</p>
</blockquote>
<p>先了解上述概念后，在看看数据范围，实际上才 $400$ 个点<del>（看不起谁呢？[doge]）</del>。 我们的算法很暴力，差不多是$400^3$，这个计算出来是 6400万，因此在力扣是完全够用的。</p>
<p>我们直接暴力枚举三个点，检查一下是否构成三元组，然后再计算出最小的度数。</p>
<p>值得注意的是，三元组可能是不存在的，因此我们需要特判一下。</p>
<p>我们的算法时间复杂度很高，这么做纯粹是这题数据很弱，正确的做法尚待学习！</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>三元组的度数，不包含内部之间的入度和出度。因此需要减去 $6$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edge[<span class="number">0</span>], b = edge[<span class="number">1</span>];</span><br><span class="line">            graph[a][b] = graph[b][a] = <span class="number">1</span>;</span><br><span class="line">            degree[a] ++ , degree[b] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= n; k ++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (graph[j][k] &amp;&amp; graph[i][k]) &#123;</span><br><span class="line">                            ans = min(ans, degree[i] + degree[j] + degree[k] - <span class="number">6</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N^3)$ ，其中 $N$ 是图中点的数量。我们会枚举所有可能的三元组。</p>
<p>空间复杂度：$O(N^2)$，我们需要存储所有的边，以及每个点的入度和出度之和。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>第30场双周赛</title>
    <url>/2020/07/13/cku5fjrt4004e90v486hw4ptt/</url>
    <content><![CDATA[<p>这场比赛的题目不是很难，即使第一次接触的话，AC前两题应该也是没有问题的。废话不多说，看代码。</p>
<h4 id="题目一：转变日期格式"><a href="#题目一：转变日期格式" class="headerlink" title="题目一：转变日期格式"></a>题目一：<a href="https://leetcode-cn.com/problems/reformat-date/">转变日期格式</a></h4><p>这个题，我是不知道有什么API可以调用，但是看它给出的<code>YYYY-MM-DD</code>的格式，其实稍微想想还是硬解析的。无脑暴力即可。注意日期和月份小于10时，需要补0；</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reformatDate</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        String[] months = &#123;<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>, <span class="string">&quot;Jul&quot;</span>, <span class="string">&quot;Aug&quot;</span>, <span class="string">&quot;Sep&quot;</span>, <span class="string">&quot;Oct&quot;</span>, <span class="string">&quot;Nov&quot;</span>, <span class="string">&quot;Dec&quot;</span>&#125;;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] data = date.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 看格式 按空格划分</span></span><br><span class="line">        String year = data[<span class="number">2</span>], month = data[<span class="number">1</span>], day = data[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 年份直接加入</span></span><br><span class="line">        sb.append(year).append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="comment">// 月份查表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; months.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (months[i].equals(month)) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m &lt; <span class="number">10</span>) &#123; <span class="comment">// 小于10， 要补0</span></span><br><span class="line">                    sb.append(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(m).append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找第一个字母的下标</span></span><br><span class="line">        <span class="keyword">char</span>[] days = day.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; days.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(days[i])) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到下标，转数字</span></span><br><span class="line">        <span class="keyword">int</span> d = Integer.parseInt(data[<span class="number">0</span>].substring(<span class="number">0</span>, idx));</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">10</span>) &#123; <span class="comment">// 小于10 补0</span></span><br><span class="line">            sb.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$</p>
<h4 id="题目二：子数组和排序后的区间和"><a href="#题目二：子数组和排序后的区间和" class="headerlink" title="题目二：子数组和排序后的区间和"></a>题目二：<a href="https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums/">子数组和排序后的区间和</a></h4><p>按照题目要求即可。要注意给出的区间 <code>left</code>和<code>right</code>。在数组的范围其实是<code>[left-1, right-1]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 模拟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                arr.add(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(arr);</span><br><span class="line">        <span class="comment">// 求区间和，  [left-1, right-1]</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left - <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            res = (res + arr.get(i)) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2\log n)$</p>
<h4 id="题目三：三次操作后最大值于最小值的最小差"><a href="#题目三：三次操作后最大值于最小值的最小差" class="headerlink" title="题目三：三次操作后最大值于最小值的最小差"></a>题目三：<a href="https://leetcode-cn.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/">三次操作后最大值于最小值的最小差</a></h4><p>这是一个脑经急转弯题。最大值于最小值的差，实际上于中间值并没有关系。我们排序后，其实找最大值和最小值，进行比较即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifference</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 由于我们只能修改三次，所以要么修改最大值，要么修改最小值</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = Math.min(nums[n-<span class="number">1</span>] - nums[<span class="number">3</span>], nums[n-<span class="number">2</span>] - nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> b = Math.min(nums[n-<span class="number">3</span>] - nums[<span class="number">1</span>], nums[n-<span class="number">4</span>] - nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.min(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n\log n)$</p>
<h4 id="题目四：石子游戏-IV"><a href="#题目四：石子游戏-IV" class="headerlink" title="题目四：石子游戏 IV"></a>题目四：<a href="https://leetcode-cn.com/problems/stone-game-iv/">石子游戏 IV</a></h4><p>这是一个博弈DP问题。对于任意个 $ 1 \le i \le n$ ，我们从 $ 1 \le j \le \sqrt i $ ，列举二人拿石子的输赢情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">winnerSquareGame</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i] 表示有i个石子，先手是否可以赢</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dp[i -j*j]) &#123;<span class="comment">// 假设Alice选完平方数个石子后，对手不能赢，那么就是Alice赢了</span></span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2)$</p>
<p>对应的给出记忆化DFS搜索代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">winnerSquareGame</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dfs(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i*i &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(n- i*i)) &#123; <span class="comment">// 枚举出所有 拿平方数的情况，假设 bob不能赢，那么Alice就赢了</span></span><br><span class="line">                map.put(n, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记忆化结果</span></span><br><span class="line">        map.put(n, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2 \log n)$</p>
]]></content>
      <categories>
        <category>周赛</category>
        <category>力扣</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>力扣</tag>
        <tag>动态规划</tag>
        <tag>周赛</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第31场双周赛</title>
    <url>/2020/07/27/cku5fjrt5004h90v465lz1rgp/</url>
    <content><![CDATA[<p>题目标题即原题地址，点击查看原题。</p>
<a id="more"></a>

<h3 id="T1：在区间范围内统计奇数数目"><a href="#T1：在区间范围内统计奇数数目" class="headerlink" title="T1：在区间范围内统计奇数数目"></a>T1：<a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range/">在区间范围内统计奇数数目</a></h3><p>这个题暴力肯定要超时的，因为数据范围是 $0 \le low \le 10^9$ ，一亿规模，加上数据本身很大的话，比赛中$O(N)$也是不允许的。</p>
<p>由于区间是连续的，我们直接计算区间内数目的差即可。$\frac{high * low}{2}$</p>
<p>有一点为奇数时，计算要加1（自行论证）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOdds</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l%<span class="number">2</span>==<span class="number">1</span> || r%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r-l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T2：和为奇数的子数组数目"><a href="#T2：和为奇数的子数组数目" class="headerlink" title="T2：和为奇数的子数组数目"></a>T2：<a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum/">和为奇数的子数组数目</a></h3><p>奇数 = 偶数 + 奇数，奇数 = 奇数 + 偶数</p>
<p>要注意，子数组的连续的子数组。所以我们分别计算前缀和，根据前缀和的奇偶性来添加子数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前缀和是偶数，就加一个奇数，前缀和是奇数，就加一个偶数</span></span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>, even = <span class="number">1</span>, res =<span class="number">0</span>, all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            all += num;</span><br><span class="line">            <span class="keyword">if</span> (all % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 前缀和为偶数，添加奇数</span></span><br><span class="line">                res = (res + odd) % mod;</span><br><span class="line">                even++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之</span></span><br><span class="line">                res = (res + even) % mod;</span><br><span class="line">                odd++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T3：字符串的好分割数目"><a href="#T3：字符串的好分割数目" class="headerlink" title="T3：字符串的好分割数目"></a>T3：<a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string/">字符串的好分割数目</a></h3><p>我们注意到，遍历字符串对下标 $0 \le i \le n$，分别进行切割，然后统计字符数目即可。这个思路是可行的。但是很遗憾，数据规模不允许这个算法通过。因为 $1 \le n \le 10^5$ ，10万的数据量，我们的算法时间复杂度至少要有$N^2\log N$ 或者 $N$ 最好。</p>
<p>当对字符串进行切割时，实际上只是左右两个字串中字符的增加和减少而已。所以对于两个字串的数据，我们可以只用固定的空间存储，然后对其进行增删即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSplits</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] lCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>], rCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 只记录一次</span></span><br><span class="line">            <span class="keyword">if</span> (rCnt[c - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span>) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">// 模拟分割字符串 左边增加，右边减少。统计数量</span></span><br><span class="line">          	<span class="comment">// 对于任意一个字串，我们只统计一次出现的字符，当左右相同时，就说明左右字串中的字符不同字符的数量一致</span></span><br><span class="line">            <span class="keyword">if</span> (lCnt[c - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">if</span> (--rCnt[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">if</span> (l == r) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T4：形成目标数组的子数组最少增加次数"><a href="#T4：形成目标数组的子数组最少增加次数" class="headerlink" title="T4：形成目标数组的子数组最少增加次数"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/">形成目标数组的子数组最少增加次数</a></h3><p>这个题，贪心就可以做的。我们选择任意的子数组，然后对子数组进行加1。对于递增的相邻的两个数，一定有$nums[i] - nums[i-1]$ 次加1操作​</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOperations</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = target[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target[i] &gt; target[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                res += target[i] - target[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>位运算</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>第40场双周赛</title>
    <url>/2020/11/29/cku5fjrt6004i90v46fb21qyi/</url>
    <content><![CDATA[<p>难度不大，很常规的题目。最后一题动态规划仍需要多练。</p>
<a id="more"></a>

<h3 id="T1：最大重复子字符串"><a href="#T1：最大重复子字符串" class="headerlink" title="T1：最大重复子字符串"></a>T1：<a href="https://leetcode-cn.com/problems/maximum-repeating-substring/">最大重复子字符串</a></h3><p>思路：</p>
<ul>
<li>计算在主串中，可以将字串<code>word</code>重复的最大次数</li>
</ul>
<p><strong>java:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRepeating</span><span class="params">(String sequence, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder(word);</span><br><span class="line">        <span class="keyword">while</span> (sequence.contains(s.toString())) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            s.append(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxRepeating</span>(<span class="params">self, sequence: <span class="built_in">str</span>, word: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        s = word</span><br><span class="line">        <span class="keyword">while</span> s <span class="keyword">in</span> sequence:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            s += word</span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(n*m)$ 其中n为主串的长度，m为字串的长度</p>
<p>空间复杂度：$O(m)$ 其中m为字串的长度</p>
<h3 id="T2：合并两个链表"><a href="#T2：合并两个链表" class="headerlink" title="T2：合并两个链表"></a>T2：<a href="https://leetcode-cn.com/problems/merge-in-between-linked-lists/">合并两个链表</a></h3><p>思路：</p>
<ul>
<li>关于链表删除，最好的建议是引入一个虚拟头节点，来预防头节点的删除。</li>
<li>此题只需要遍历<code>a-1</code>个节点，然后把<code>list2</code>遍历至最后一个节点，再继续遍历<code>list1</code>至第<code>b</code>个节点。然后把<code>a-1</code>链接至<code>list2</code>的头节点，<code>list2</code>的尾节点，连接至<code>b+1</code>个节点。</li>
<li>模拟上述过程即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeInBetween</span><span class="params">(ListNode list1, <span class="keyword">int</span> a, <span class="keyword">int</span> b, ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = list1;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; a) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode c1 = cur;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= b) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode c2 = cur.next;</span><br><span class="line">        ListNode c3 = list2;</span><br><span class="line">        <span class="keyword">while</span> (c3.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c3 = c3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        c3.next = c2;</span><br><span class="line">        c1.next = list2;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(1)$</p>
<h3 id="T3：设计前中后队列"><a href="#T3：设计前中后队列" class="headerlink" title="T3：设计前中后队列"></a>T3：<a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">设计前中后队列</a></h3><p>思路：</p>
<ul>
<li>利用列表模拟队列。</li>
<li>对于中间位置，当队列为奇数个元素时，弹出中间位置的前一个。当队列为偶数个元素时，仍弹出前一个元素。因此借助<code>ArrayList</code>的插入操作可以解决问题。</li>
<li>对于中间元素，需要特别注意的是，中间元素-1。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrontMiddleBackQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrontMiddleBackQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushFront</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            list.add(<span class="number">0</span>, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMiddle</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">            list.add(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = list.size();</span><br><span class="line">            <span class="keyword">if</span> (sz % <span class="number">2</span> != <span class="number">0</span>) sz--;</span><br><span class="line">            <span class="keyword">int</span> t = sz&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            list.add(t, val);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        list.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popMiddle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = list.size()-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = sz&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> list.remove(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(n)$，最好$O(1)$，最差$O(n)$。其中n为列表的长度</p>
<p>空间复杂度：$O(n)$</p>
<h3 id="T4：得到山形数组的最少删除次数"><a href="#T4：得到山形数组的最少删除次数" class="headerlink" title="T4：得到山形数组的最少删除次数"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-number-of-removals-to-make-mountain-array/">得到山形数组的最少删除次数</a></h3><p>思路：</p>
<ul>
<li>根据山形状数组的特性可以发现，从<code>0</code>开始不断上升至最大值，然后从最大值开始，逐渐下降至最小值</li>
<li>那么我们的思路就可以同时寻找最长的上升子序列和最长的下降子序列，取两者相交的最大值。就可以得到最长的山形状数组的长度，然后拿原数组的长度减去山形数组，即表示为要删除的次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMountainRemovals</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 最长升序子序列</span></span><br><span class="line">        <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 最长降序子序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = g[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    f[i] = Math.max(f[i], f[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    g[i] = Math.max(g[i], g[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt; <span class="number">1</span> &amp;&amp; g[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res = Math.max(res, g[i]+f[i]-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// res 为可以得到的最长的山形数组的长度，原数组长度-山形数组长度 = 要删除的次数</span></span><br><span class="line">        <span class="keyword">return</span> n - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>空间复杂度：$O(n)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>DP</tag>
        <tag>设计</tag>
        <tag>链表</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>第41场双周赛</title>
    <url>/2020/12/13/cku5fjrt7004n90v4eiia46hs/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/count-the-number-of-consistent-strings/"> 统计一致字符串的数目</a></li>
<li> <a href="https://leetcode-cn.com/problems/sum-of-absolute-differences-in-a-sorted-array/">有序数组中差绝对值之和</a></li>
<li> <a href="https://leetcode-cn.com/problems/stone-game-vi/">石子游戏 VI</a></li>
<li> <a href="https://leetcode-cn.com/problems/delivering-boxes-from-storage-to-ports/">从仓库到码头运输箱子</a></li>
</ul>
<a id="more"></a>

<h3 id="T1-统计一致字符串的数目"><a href="#T1-统计一致字符串的数目" class="headerlink" title="T1: 统计一致字符串的数目"></a>T1:<a href="https://leetcode-cn.com/problems/count-the-number-of-consistent-strings/"> 统计一致字符串的数目</a></h3><p><strong>方法一</strong>：暴力</p>
<p>题目意思就是给定一个字典单词，再查询单词中是否全部都是由字典单词构成，找出所有这种单词的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countConsistentStrings</span><span class="params">(String allowed, String[] words)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; h = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : allowed.toCharArray()) h.add(c);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> f= <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!h.contains(c)) &#123;</span><br><span class="line">                    f = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间优化，考虑到给定的字符串仅限于小写英文字母。因此可以将 Set 集合改成数组来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countConsistentStrings</span><span class="params">(String allowed, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : allowed.toCharArray()) f[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> g = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[c-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    g = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<p>时间复杂度：$O(n^2)$，其中n为字符串数组的长度</p>
<p>空间复杂度：$O(1)$</p>
<h3 id="T2：有序数组中差绝对值之和"><a href="#T2：有序数组中差绝对值之和" class="headerlink" title="T2：有序数组中差绝对值之和"></a>T2：<a href="https://leetcode-cn.com/problems/sum-of-absolute-differences-in-a-sorted-array/">有序数组中差绝对值之和</a></h3><p>题意：</p>
<p>返回一个数组，数组 $res[i] = nums[i] + abs(nums[i] - others[j]) , 0 \le  j\le nums.length-1 且 i \ne j$</p>
<p>观察数组范围，可以发现时 $10^5$ 级别的，因此暴力是不可能通过的，所以必须把时间复杂度降到 $O(nlogn)$ 甚至是 $O(n)$ 才行。</p>
<p>观察数组，数组为一个 <strong>非递减</strong> 的数组，即递增数组，下面进行公式推导：</p>
<p>对数组中任意一个元素 $nums[i]$  </p>
<p><img src="https://pic.downk.cc/item/5fd5b9363ffa7d37b3359baf.png"></p>
<p>在范围 $0 \le left \le i$ 存在</p>
<p> $(nums[i-1] - nums[0]) + (nums[i-1] - nums[1]) + …+(nums[i-1] - nums[i-2])$ </p>
<p>$ = (nums[i-1] * i) - Sum_i$ ，其中  $Sum $ 为前缀和</p>
<p>在范围 $i \lt right \le n-1$ 存在</p>
<p>$(nums[i-1] - nums[n-1]) + (nums[i-1] - nums[n-2]) +…+(nums[i-1]-nums[i])$</p>
<p>$= Sum_n - Sum_i - (nums[i-1] * (n-i))$</p>
<p>那么对于结果数组 $res[i] = left + right$</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getSumAbsoluteDifferences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = (i * nums[i-<span class="number">1</span>]) - s[i];</span><br><span class="line">            <span class="keyword">int</span> right = s[n] - s[i] - (nums[i-<span class="number">1</span>] * (n-i));</span><br><span class="line">            res[idx++] = left+right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<p>时间复杂度：$O(n)$，其中n为数组长度</p>
<p>空间复杂度：$O(n)$</p>
<h3 id="T3：石子游戏-VI"><a href="#T3：石子游戏-VI" class="headerlink" title="T3：石子游戏 VI"></a>T3：<a href="https://leetcode-cn.com/problems/stone-game-vi/">石子游戏 VI</a></h3><p>题意：</p>
<p>Alice 和 Bob 又在玩一个游戏，Alice先手选择。</p>
<p>在一堆石子里选石头，Alice 和 Bob 对石子的价值观是不同的，每轮一个玩家选出一个石头，当石头全部都取完后，计算各自的价值，如果相等就返回 0，Alice 大就返回1，否则就返回  -1。</p>
<p>这个游戏的精髓就是：每次都拿走对于自己，也对于对手都较大价值的石头，让对手也无路可走。因为两人对石头的估价不同，我每次都拿对自己和别人都大的，可以让自己价值更多，也让对手只能选择较小价值的，这样我就可以获胜。</p>
<p>依据以上的脏心理。进行简略的证明。</p>
<p>对于两块石头进行分析，对于Alice 和 Bob 的价值分别为 $a_1 和 a_2 ，b_1 和 b_2$</p>
<ul>
<li>方案一是Ailce 选石头一，Bob 选石头二，价值为 $c = a_1 - b_2$</li>
<li>方案二是Alice 选石头二，Bob 选石头二，价值为 $c = a_2 - b_1$</li>
</ul>
<p>此时的价值差为 $ c = c_1 - c_2 = (a_1 - b_2) - (a_2 - b_1) = (a_1 + b_1) - (a_2 + b_2)$</p>
<p>分析一下 $c$ </p>
<ul>
<li>如果 c == 0， 那么怎么选都是可以的</li>
<li>c &gt; 0的话， 此时选择方案一</li>
<li>c &lt; 0 的话，选择方案二</li>
</ul>
<p>那么两种方案的优劣就是 $a_1 + b_1$ 与 $a_2 + b_2$ 的优劣了。</p>
<p>对于Bob而言，也是同理的。</p>
<p>对数组进行重构，按照 $a_i + b_i$ 的值从大到小排序，然后分别计算各自的分数。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stoneGameVI</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c[i] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a[i] + b[i], a[i], b[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(c, (o1, o2) -&gt; o2[<span class="number">0</span>] - o1[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// as 为 Alice 得分，bs 为 Bob 得分</span></span><br><span class="line">        <span class="keyword">int</span> as = <span class="number">0</span>, bs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) as += c[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> bs += c[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (as == bs) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (as &gt; bs) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>时间复杂度：$O(NlogN)$，排序$O(NlogN) + O(n)$ </p>
<p>空间复杂度：$O(n)$，虽然是二维数组，但是第二维仅有3个元素</p>
<h3 id="T4：从仓库到码头运输箱子"><a href="#T4：从仓库到码头运输箱子" class="headerlink" title="T4：从仓库到码头运输箱子"></a>T4：<a href="https://leetcode-cn.com/problems/delivering-boxes-from-storage-to-ports/">从仓库到码头运输箱子</a></h3><p>暂无思路。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>第42场双周赛</title>
    <url>/2020/12/28/cku5fjrt7004q90v41k54hhwc/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li><p> <a href="https://leetcode-cn.com/problems/number-of-students-unable-to-eat-lunch/">无法吃午餐的学生数量</a></p>
</li>
<li><p> <a href="https://leetcode-cn.com/problems/average-waiting-time/">平均等待时间</a></p>
</li>
<li><p> <a href="https://leetcode-cn.com/problems/maximum-binary-string-after-change/">修改后的最大二进制字符串</a></p>
</li>
<li><p> <a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/">得到连续 K 个 1 的最少相邻交换次数</a></p>
</li>
</ul>
<a id="more"></a>

<h4 id="T1：-无法吃午餐的学生数量"><a href="#T1：-无法吃午餐的学生数量" class="headerlink" title="T1： 无法吃午餐的学生数量"></a>T1： <a href="https://leetcode-cn.com/problems/number-of-students-unable-to-eat-lunch/">无法吃午餐的学生数量</a></h4><p>方法一：模拟</p>
<p>分别用一个队列模拟学生站队，用一个栈模拟三明治。</p>
<p>当栈顶元素与学生队列的队头元素相同时，那么我们分别取出对头元素和栈顶元素。</p>
<p>否则取出队列的队头元素，放入队尾。如果队列的所有学生都无法取出，此时队列中的所有学生将无法吃午餐。</p>
<p><strong>代码</strong></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countStudents</span><span class="params">(<span class="keyword">int</span>[] students, <span class="keyword">int</span>[] sandwiches)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : sandwiches) stack.addFirst(n);</span><br><span class="line">        LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : students) q.addLast(x);</span><br><span class="line">        <span class="comment">// 记录无法吃午餐的学生人数</span></span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法吃午餐</span></span><br><span class="line">            <span class="keyword">if</span> (!q.peekFirst().equals(stack.peekLast())) &#123;</span><br><span class="line">                q.addLast(q.pollFirst());</span><br><span class="line">                f++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 可以吃午餐，则栈和队列为空时 返回0</span></span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">                q.pollFirst();</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                <span class="keyword">if</span> (q.isEmpty() &amp;&amp; stack.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 队列中的学生无法吃午餐 break </span></span><br><span class="line">            <span class="keyword">if</span> (f == q.size()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回无法吃午餐的学生人数</span></span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n^2)$，其中 n 为学生人数</p>
<p>空间复杂度：$O(n^2)$</p>
<h4 id="T2：平均等待时间"><a href="#T2：平均等待时间" class="headerlink" title="T2：平均等待时间"></a>T2：<a href="https://leetcode-cn.com/problems/average-waiting-time/">平均等待时间</a></h4><p>方法一：模拟</p>
<p>对于顾客数组，我们是需要按顺序遍历的。</p>
<p>我们需要一个记录开始做菜的时间，如果客户来的很早，即 $startTime = min{customer[i][0], t} = t$  时，我们可以立刻给顾客做菜，那么等待时间 $waitTime = customer[i][1] - customer[i][0]$ 。如果非常不幸，顾客来的时候，我们还在给上一位顾客做菜，那么这位顾客就必须等待更长的时间，即 $startTime = min{customer[i][0], t} = cutomer[i][0]$，那么顾客的等待时间就为 $waitTime=t + cutomer[i][1] - cutomer[i][0]$</p>
<p><strong>代码</strong></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">averageWaitingTime</span><span class="params">(<span class="keyword">int</span>[][] customers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = customers.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t  = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            t = Math.max(customers[i][<span class="number">0</span>], t);</span><br><span class="line">            t += customers[i][<span class="number">1</span>];</span><br><span class="line">            res += t - customers[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * <span class="number">1.0</span>/ n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>空间复杂度：$O(n)$</p>
<p>时间复杂度：$O(1)$</p>
<h4 id="T3：修改后的最大二进制字符串"><a href="#T3：修改后的最大二进制字符串" class="headerlink" title="T3：修改后的最大二进制字符串"></a>T3：<a href="https://leetcode-cn.com/problems/maximum-binary-string-after-change/">修改后的最大二进制字符串</a></h4><p>这是一道思维题，如果可以发现规律，则很容易做出来，如果不能发现，那就没办法。</p>
<p>对于任意的二进制串，我们有以下操作：</p>
<ul>
<li>如果包含字串 <code>00</code> ，我们可以用 <code>10</code> 替换</li>
<li>如果包含字串 <code>10</code> ，我们可以用 <code>01</code> 替换</li>
</ul>
<p>那么假设存在一个字符串 <code>01110</code></p>
<p>第一轮变化为 <code>01110</code> –&gt; 011<strong>10</strong>   -&gt; <code>01101</code></p>
<p>第二轮变化为 <code>01101</code> –&gt; 01<strong>10</strong>1   -&gt; <code>01011</code></p>
<p>第三轮变化为 <code>01011</code> –&gt; 0<strong>10</strong>11   -&gt; <code>00111</code></p>
<p>第四轮变化为 <code>00111</code> –&gt; <strong>00</strong>111   -&gt; <code>10111</code></p>
<p>可以发现，对于第一个 <code>0</code> 的位置来说，我们 “献祭” 掉了一个 <code>0</code> 后，自身是向前移动了一位。<code>01110</code> 相对于 <code>10111</code> ，那么推广一下普适性，假如我们每 “献祭” 掉一个 <code>0</code> ，自身就会前进一位。</p>
<p>对于字符串 <code>101100</code></p>
<p>第一轮变化为 <code>101100</code>    -&gt; 101<strong>10</strong>0    -&gt; <code>101010</code></p>
<p>第二轮变化为 <code>101010</code>    -&gt; 10<strong>10</strong>10    -&gt; <code>100110</code></p>
<p>第三轮变化为 <code>100110</code>    -&gt; 1<strong>00</strong>110    -&gt; <code>110110</code></p>
<p>第四轮变化为 <code>110110</code>    -&gt; 1101<strong>10</strong>    -&gt; <code>110101</code></p>
<p>第五轮变化为 <code>110101</code>    -&gt; 110<strong>10</strong>1    -&gt; <code>110011</code></p>
<p>第六轮变化为 <code>110011</code>    -&gt; 11<strong>00</strong>11    -&gt; <code>111011</code></p>
<p>根据我们上述的发现，对于字符串 <code>101100</code> 也同样适用。那么我们可以认为，对于第一个 <code>0</code> 的位置为$k$，$k$ 之后存在 $cnt$ 个 <code>0</code> ，那么最大值的字符串中，这个 <code>0</code> 将会出现  $k + cnt$ 的位置。</p>
<p>另外：对于全是 <code>1</code> 的字符串，我们无需任何改变，直接返回即可。</p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maximumBinaryString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n &amp;&amp; s[k] == <span class="string">&#x27;1&#x27;</span>) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == n) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(n, <span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) cnt++;</span><br><span class="line">        res[k+cnt] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$ </p>
<p>空间复杂度：$O(n)$</p>
<h4 id="T4：得到连续-K-个-1-的最少相邻交换次数"><a href="#T4：得到连续-K-个-1-的最少相邻交换次数" class="headerlink" title="T4：得到连续 K 个 1 的最少相邻交换次数"></a>T4：<a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/">得到连续 K 个 1 的最少相邻交换次数</a></h4><p>方法一：贪心 + 前缀和</p>
<p>题目中说的是，移动 <code>1</code> 和 <code>0</code> ，那么我们在移动过程中是不会移动连续的 <code>1</code> 和 连续的 <code>0</code> ，因此在最终的答案中则说明，<code>k</code> 个连续的 <code>1</code> 它们在数组中的相对顺序是不变的。那么我们就可以考虑  <code>1</code> 位置之间的关系。</p>
<p>假设数组中所有 <code>1</code> 的位置为 $a_1, a_2, a_3, a_4, a_5 \ …\ a_n$  。</p>
<p>那么答案就转换为，将 <code>k</code> 个连续的  $a_1, a_2, a_3 \ … \ a_k$，移动在一起，形成公差为 <code>1</code> 的等差数列。</p>
<p>假设每个元素移动 $x,x+1,x+2,x+3 \ … \ x+k+1$ 次，那么</p>
<p>$|a_1 - x| + |a_2 - (x+1)| + |a_3 - (x+2)| + ··· + |a_k - (x+k+1)|$     <strong>式子 4-1</strong></p>
<p>我们需要求出上述式子的最小值。由于 $a_1, a_2 … a_k$ 为原数组中位置，所以我们需要重新映射一下 <code>1</code> 的位置</p>
<p>假设 $\grave{a_i} = a_i - (i-1)$，那么存在</p>
<p>$\grave{a_1} = a_1$</p>
<p>$\grave{a_2} = a_2 - 1$</p>
<p>$\grave{a_3} = a_3 - 2$</p>
<p>将上式代入 式子4-1。重新整理下式子可得：$|\grave{a_1} - x| + |\grave{a_2} - x| + |\grave{a_3} - x| + … + |\grave{a_k} - x|$   <strong>式子4-2</strong></p>
<p>求出上述<strong>式子4-2</strong>的最小值，当 $x$ 取值为 $\grave{a_1}, \grave{a_2} … \grave{a_k}$ 的中位数时，总和为最小。</p>
<p>对于上述式子，取中位数$mid$ 后，可以有 $ leftSum = (\grave{a_{mid}} - \grave{a_{left}}) + (\grave{a_{mid}} - \grave{a_{left+1}}) + … + (\grave{a_{mid}} - \grave{a_{mid-1}}) + (\grave{a_{mid}} - \grave{a_{mid}})$</p>
<p>$rightSum = (\grave{a_{mid+1}} - \grave{a_{mid}}) + (\grave{a_{mid+2}} - \grave{a_{mid}}) + … + (\grave{a_{right}} - \grave{a_{mid}})$</p>
<p>对于上述式子，显然计算的时间复杂度为 $O(n)$ 的，那么 $k$ 次计算的话，时间复杂度就会达到 $O(n^2)$ 级别，所以上述式子，必须要在 $O(1)$ 时间内计算，才能保证时间复杂度在 $O(n)$。</p>
<p>对 $\ leftSum, rightSum \ $再进一步化简可得</p>
<p>$leftSum = (mid - left) * (\grave{a_{mid}}) - Sum_{mid-1} - Sum_{left-1} $</p>
<p>$rightSum = Sum_{right} - Sum_{mid} - (right-mid)*(\grave{a_mid})$</p>
<p>最终答案就是 $res = min(res, left + right)$</p>
<p><strong>代码</strong></p>
<p>c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">       	<span class="comment">// Ai 映射到 Ai`</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i])</span><br><span class="line">                a.push_back(i - a.size());</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 处理前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i<span class="number">-1</span>] + a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算所有可能的连续 k 个1的情况，取最小值的时候</span></span><br><span class="line">            <span class="comment">// [l, r] 区间大小等于 k</span></span><br><span class="line">            <span class="keyword">int</span> l = i - k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = i;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 前缀和是从1开始的，因此需要减1</span></span><br><span class="line">            <span class="keyword">int</span> x = a[mid- <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> left = (mid - l) * x - (s[mid<span class="number">-1</span>] - s[l<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">int</span> right = (s[r] - s[mid]) - x * (r - mid);</span><br><span class="line">            res = min(res, left + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) a.add(i - a.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + a.get(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i - k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = i;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> x = a.get(mid-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> left =  (mid-l) * x - (s[mid-<span class="number">1</span>] - s[l-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> right = (s[r] - s[mid]) - x * (r- mid);</span><br><span class="line">            res = Math.min(res, left + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>第43场双周赛</title>
    <url>/2021/01/12/cku5fjrt9004v90v472tuayfz/</url>
    <content><![CDATA[<p>题单：</p>
<ul>
<li> <a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">计算力扣银行的钱</a></li>
<li> <a href="https://leetcode-cn.com/problems/maximum-score-from-removing-substrings/">删除子字符串的最大得分</a></li>
<li> <a href="https://leetcode-cn.com/problems/construct-the-lexicographically-largest-valid-sequence/">构建字典序最大的可行序列</a></li>
<li> <a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/">重构一棵树的方案数</a></li>
</ul>
<a id="more"></a>

<h4 id="T1：计算力扣银行的钱"><a href="#T1：计算力扣银行的钱" class="headerlink" title="T1：计算力扣银行的钱"></a>T1：<a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">计算力扣银行的钱</a></h4><p>思路：</p>
<p>第一周：<code>1, 2, 3, 4, 5, 6, 7</code></p>
<p>第二周：<code>2, 3, 4, 5, 6, 7, 8</code></p>
<p>….</p>
<p>根据上述思路模拟即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalMoney</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前日期   计数      上周开头的钱</span></span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">1</span>, idx = <span class="number">1</span>, pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">            res += day++;</span><br><span class="line">            <span class="comment">// 说明要开始下一周了</span></span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= <span class="number">7</span> &amp;&amp; idx % <span class="number">7</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                day = ++pre;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(1)$</p>
<p>空间复杂度：$O(N)$</p>
<h4 id="T2：删除子字符串的最大得分"><a href="#T2：删除子字符串的最大得分" class="headerlink" title="T2：删除子字符串的最大得分"></a>T2：<a href="https://leetcode-cn.com/problems/maximum-score-from-removing-substrings/">删除子字符串的最大得分</a></h4><p>思路：</p>
<p>我们从字符串每删除一个 <code>ab</code> 子串，就可以得到 <code>x</code> 分。每删除一个 <code>ba</code> 子串，就可以得到 <code>y</code> 分。</p>
<p>我们对字符串进行预处理，使得删除 <code>ab</code> 的得分是恒大于 <code>ba</code> 的得分。</p>
<p>那么对于一段连续的仅含有 <code>ab</code> 的子字符串，我们要做的操作就是尽可能删除所有的<code>ab</code>  和 <code>ba</code>对 ，由于我们一定可以删除完毕(恰好删完，或者仅剩一个)，所以我们可以得到：$c * x + (min(a, b) - c) * y$。其中，$c$ 为删除 <code>ab</code> 的操作次数，对应的剩下的$min(a,b)-c$ 就是删除 <code>ba</code>的操作次数。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGain</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">            swap(x, y);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span>) c = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;b&#x27;</span>) c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27;b&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.size() &amp;&amp; (s[j] == <span class="string">&#x27;a&#x27;</span> || s[j] == <span class="string">&#x27;b&#x27;</span>)) j++;</span><br><span class="line">            <span class="comment">// 区间 [i,j] 为仅含 a，b的字符串</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; k &gt;= i; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[k] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                    a ++;</span><br><span class="line">                    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">                        t--;</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    b ++;</span><br><span class="line">                    t ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算这段字符串可以产生的得分</span></span><br><span class="line">            res += x * c + (min(a, b) - c) * y;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N^2)$，其中最差的情况是，字符串中仅含<code>a</code>，<code>b</code></p>
<p>空间复杂度：$O(1)$</p>
<h4 id="T3：构建字典序最大的可行序列"><a href="#T3：构建字典序最大的可行序列" class="headerlink" title="T3：构建字典序最大的可行序列"></a>T3：<a href="https://leetcode-cn.com/problems/construct-the-lexicographically-largest-valid-sequence/">构建字典序最大的可行序列</a></h4><p>思路</p>
<p>我们需要构造一个序列</p>
<ul>
<li><code>1</code> 只出现过一次</li>
<li><code>[2, n]</code> 每个数是出现 两次</li>
<li><code>[2, n]</code>每个数的出现位置间隔为 <code>i</code></li>
</ul>
<p>由于数据范围很小 $1 \le n \le 20$ ，所以我们可以直接暴力枚举</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">2</span>*n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (path[u]) <span class="keyword">return</span> dfs(u + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从最大的数开始，要求字典序最大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i] &amp;&amp; u + i &lt; n*<span class="number">2</span><span class="number">-1</span> &amp;&amp; !path[u + i]) &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                path[u] = path[u + i] = i;</span><br><span class="line">                <span class="keyword">if</span> (dfs(u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">                path[u] = path[u + i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!st[<span class="number">1</span>]) &#123;</span><br><span class="line">            st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            path[u] =  <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            path[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructDistancedSequence</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        st.resize(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        path.resize(n * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N!)$，其中每个位置，我们都要至少检查 $N$ 次</p>
<p>空间复杂度：$O(N)$</p>
<h4 id="T4：重构一棵树的方案数"><a href="#T4：重构一棵树的方案数" class="headerlink" title="T4：重构一棵树的方案数"></a>T4：<a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/">重构一棵树的方案数</a></h4><p>暂无思路！</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>回溯</tag>
        <tag>图</tag>
        <tag>数学</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>第46场双周赛</title>
    <url>/2021/02/22/w46/</url>
    <content><![CDATA[<p>第46场双周赛题解</p>
<p>比赛地址：<a href="https://leetcode-cn.com/contest/biweekly-contest-46/">第 46 场双周赛</a></p>
<h1 id="题目清单："><a href="#题目清单：" class="headerlink" title="题目清单："></a>题目清单：</h1><ul>
<li> <a href="https://leetcode-cn.com/problems/longest-nice-substring/">最长的美好子字符串</a></li>
<li> <a href="https://leetcode-cn.com/problems/form-array-by-concatenating-subarrays-of-another-array/">通过连接另一个数组的子数组得到一个数组</a></li>
<li> <a href="https://leetcode-cn.com/problems/map-of-highest-peak/">地图中的最高点</a></li>
<li> <a href="https://leetcode-cn.com/problems/tree-of-coprimes/">互质树</a></li>
</ul>
<a id="more"></a>

<h1 id="T1：最长的美好子字符串"><a href="#T1：最长的美好子字符串" class="headerlink" title="T1：最长的美好子字符串"></a>T1：<a href="https://leetcode-cn.com/problems/longest-nice-substring/">最长的美好子字符串</a></h1><h2 id="方法一：枚举-哈希表"><a href="#方法一：枚举-哈希表" class="headerlink" title="方法一：枚举+哈希表"></a>方法一：枚举+哈希表</h2><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>题目描述比较长，简单概括一下就是：</p>
<p>在给定的字符中，找到一个连续的、最长的而且是最早出现的 <strong>美好子字符串</strong>。<strong>美好子字符串</strong> 的定义是对于任意一个字符（如 <code>a</code>出现在子串里，那么<code>A</code>就必须要存在），它的大小写形式都必须出现（不论次数）在这个子字符串里。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看看数据范围，给定字符串的长度为 $100$。因此，我们可以枚举出所有可能的子字符串，然后再检查这个子字符串是否为 <strong>美好子字符串</strong>。</p>
<p>枚举所有的子字符串时间复杂度为 $O(N^2)$，再检查子字符串 $O(N)$。所以我们的算法最终时间复杂度为 $O(N^3)$ ，计算量为 $10^6$ 次。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// true 返回大写, false 返回小写</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">return</span> c - <span class="number">32</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; has;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="comment">// 提前存入哈希表，并记录字串以待返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">            has.insert(s[k]);</span><br><span class="line">            ret.push_back(s[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k ++) &#123;</span><br><span class="line">            <span class="comment">// 分别转换为大写和小写形式</span></span><br><span class="line">            <span class="keyword">auto</span> c1 = convert(s[k], <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">auto</span> c2 = convert(s[k], <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 任意一个不存在，即可返回一个空串</span></span><br><span class="line">            <span class="keyword">if</span> (!has.count(c1) || !has.count(c2)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestNiceSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = check(s, i, j);</span><br><span class="line">                <span class="keyword">if</span> (t.size() &gt; ans.size()) </span><br><span class="line">                    ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^3)$，其中 $N$ 表示字符串的长度。</p>
<ul>
<li>我们要枚举出所有可能的字串，时间复杂度$O(N^2)$。</li>
<li>我们枚举出字串后，对于每一个字串，我们都需要遍历一次以验证是否为<strong>美好子字符串</strong>，遍历字符串的时间复杂度为 $O(N)$。</li>
<li>所以我们的算法最终时间复杂度为 $O(N^3)$。</li>
</ul>
<p>空间复杂度：$O(N^3)$，其中 $N$ 表示为子串的长度。</p>
<ul>
<li>我们对于任意一个字串都需要记录其出现的种类以及存储字串的空间，空间复杂度为 $O(N)$。</li>
<li>我们要枚举出来 $N^2$ 个字串，因此空间复杂度为 $O(N^3)$。</li>
</ul>
<h1 id="T2：通过连接另一个数组的子数组得到一个数组"><a href="#T2：通过连接另一个数组的子数组得到一个数组" class="headerlink" title="T2：通过连接另一个数组的子数组得到一个数组"></a>T2：<a href="https://leetcode-cn.com/problems/form-array-by-concatenating-subarrays-of-another-array/">通过连接另一个数组的子数组得到一个数组</a></h1><h2 id="方法一：贪心-双指针（存疑，系本人看错题）"><a href="#方法一：贪心-双指针（存疑，系本人看错题）" class="headerlink" title="方法一：贪心+双指针（存疑，系本人看错题）"></a>方法一：贪心+双指针（存疑，系本人看错题）</h2><h2 id="开头-1"><a href="#开头-1" class="headerlink" title="开头"></a>开头</h2><p>给定一个二维的数组，和一个整数数组。</p>
<p>我们的目标是，把二维数组 $groups$ 的每一个行 $groups[i](0 \le i\le n-1，n为二维数组的行数)$ 都映射到整数数组的子数组 $nums[j, k] (groups[i].length =k-j+1，区间[j,k]的长度是等于 groups[i]行的长度)$  上，且 $groups[i]$ 必须在 $groups[i+1](i \le n -1)$ 之前映射到 $nums$ 上。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>需要好好看看题，这题就是阅读理解。</p>
<p>那么，我们可以这样贪心，对于二维数组的任意一行 $i (0 \le i \le n-2)$ ，我们都必须要完全映射到一维数组 $nums$ 的子数组上，且子数组之间没有重叠冲突。</p>
<p>我们这么做的理由很容易得到证明。题目说了，当 $i (i \gt 0)$ 时，$groups[i-1]$ 行在 $nums$ 中的出现位置一定在第 $i$ 个 $groups[i]$ 行之前。</p>
<p>具体做法如下：</p>
<ul>
<li>我们使用循环遍历二维数组的所有行，对于每一行，我们遍历所有的列，并计算总和</li>
<li>使用一个 $cur$ 指针，表示当前在一维数组的位置。我们希望找到一段与当前行长度一样的区间，也就是总和相等的子数组<ul>
<li>如果找到，那么我们将 $cur$ 指针，移动 $groups[i].length$ 次。表示这段区间我们已经使用。</li>
<li>如果未找到，那么我们将 $cur$ 指针，只移动一次。</li>
<li>在此过程中，如果 $cur$ 指针，不够移动 $groups[i].length$ 次，则表示我们无法将当前行的元素，全部都映射到一位数组上，我们返回 $false$。</li>
</ul>
</li>
<li>如果我们遍历完所有的二维数组，则表示二维数组可以全部映射到一维数组上，我们返回 $true$。</li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canChoose</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; groups, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = groups.size();</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = groups[i].size();</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j ++) sum += groups[i][j];</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur + len &gt; nums.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = cur; k &lt; cur + len; k ++) &#123;</span><br><span class="line">                    t += nums[k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t == sum) &#123;</span><br><span class="line">                    cur += len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur ++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != sum &amp;&amp; cur &lt; nums.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(N^2)$，其中 $N$ 为数组的长度。</p>
<ul>
<li>我们必须要遍历二维数组，时间复杂度为 $O(N^2)$。</li>
<li>在遍历二维数组的第二维时，我们还会遍历一维数组数组，这是同时进行的。时间复杂度为 $O(N)$。</li>
<li>因此，我们的时间复杂度为 $O(N^2)$。</li>
</ul>
<p>空间复杂度：$O(1)$，我们只使用了常数空间。</p>
<h1 id="T3：地图中的最高点"><a href="#T3：地图中的最高点" class="headerlink" title="T3：地图中的最高点"></a>T3：<a href="https://leetcode-cn.com/problems/map-of-highest-peak/">地图中的最高点</a></h1><h2 id="方法一：多源BFS"><a href="#方法一：多源BFS" class="headerlink" title="方法一：多源BFS"></a>方法一：多源BFS</h2><h2 id="开头-2"><a href="#开头-2" class="headerlink" title="开头"></a>开头</h2><p>一个出发点的是一般的 BFS。</p>
<p>多源BFS，说得通俗一点其实就是一开始搜索之前，队列里存放多个<strong>起点</strong>，依次出发遍历。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>我们解读题目为：</p>
<blockquote>
<p>​    从任意一个水域出发，我们可以到达陆地的最大距离。</p>
</blockquote>
<p>直接 BFS ，一层一层的扩散搜索。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; highestPeak(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isWater) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = isWater.size(), n = isWater[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> used[m][n];</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isWater[i][j]) </span><br><span class="line">                    q.push(&#123;i, j&#125;), used[i][j] = <span class="literal">true</span>, isWater[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 步长，即最大距离</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line">            <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front(); </span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> x = p.x, y = p.y;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!used[nx][ny] &amp;&amp; !isWater[nx][ny]) &#123;</span><br><span class="line">                        q.push(&#123;nx, ny&#125;);</span><br><span class="line">                        used[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                        isWater[nx][ny] = step;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(M \times N)$，其中 $M$ 为矩阵的行数，$N$ 为矩阵的列数。我们需要遍历所有的矩阵。</p>
<p>空间复杂度：$O(M \times N)$，在最坏的情况下，整个矩阵都是水域。此时所有的点全部都要进入队列。</p>
<h1 id="T1：互质树"><a href="#T1：互质树" class="headerlink" title="T1：互质树"></a>T1：<a href="https://leetcode-cn.com/problems/tree-of-coprimes/">互质树</a></h1><h1 id="开头-3"><a href="#开头-3" class="headerlink" title="开头"></a>开头</h1><p>题目描述的花里胡哨的，简化一下就是。</p>
<p>对于树上的任意一个节点，找到一个距离此节点最近的祖先节点满足两个节点的值是互质的。</p>
<h1 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h1><p>我们不可能试图去枚举所有的点，因为当树呈现线性的极端情况下，我们的暴力做法时间复杂度为 $O(N^2)$，而我们要枚举 $10^5$ 个点，$10^{10}$ 次计算，一定是超时的。</p>
<p>好在，节点的每个值都是比较小的 $1 \le nums[i] \le 50$，因此我们可以从值出发。</p>
<p>我们记录 $[1,50]$ 之间所有可能互质的两个数，然后对于任意一个节点的值 $x$，我们希望找到一个<strong>互质</strong>且 <strong>“最深”</strong> （深度最大的）的节点的值 $y$。</p>
<p> 具体做法：</p>
<ul>
<li>我们先构建出无向图，然后计算出 $[1,50]$ 之间所有互质的点，然后从第一个点 $0$ 开始向下搜索，定义 $pos$ 数组表示数组对应的节点，定义数组 $depth$ 表示节点的深度。</li>
<li>对于任意一个节点$u$ 和其对应的值 $x$，我们枚举在 $[1,50]$ 之间所有可能互质的数 $y$，再根据 $pos[y]$ 和 $ans[u]$ 的对应深度来更新 $ans[u]$ 的最近祖先。<ul>
<li>我们再暂时将值 $x$ 的设置为指向 $u$，再递归处理循环上述过程，为防止 $stackoverflow$ ，当我们遍历到父亲节点时退出。</li>
</ul>
</li>
</ul>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>注意：在力扣中，c++使用全局遍历必须要初始化！（调了半小时后，我才突然意识到这个问题）</p>
<p>力扣中的c++在判题的过程中，如果使用了全局变量，在使用前不初始化的话，不同用例之间的数据会互相干扰。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; graph[N];</span><br><span class="line"><span class="comment">// pos 数值所在的层数</span></span><br><span class="line"><span class="comment">// depth 指节点的深度</span></span><br><span class="line"><span class="keyword">int</span> depth[N], pos[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w, ans;</span><br><span class="line">    <span class="comment">// 记录互质的数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = w[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;y : g[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[y] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[u] == <span class="number">-1</span> ||  depth[pos[y]] &gt; depth[ans[u]]) &#123;</span><br><span class="line">                    ans[u] = pos[y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = pos[x];</span><br><span class="line">        pos[x] = u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">            depth[j] = depth[u] + <span class="number">1</span>;</span><br><span class="line">            dfs(j, u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getCoprimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        w = nums;</span><br><span class="line">        <span class="comment">// 必须初始化全局变量</span></span><br><span class="line">        <span class="built_in">memset</span>(depth, <span class="number">0</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">        <span class="built_in">memset</span>(pos, <span class="number">-1</span>, <span class="keyword">sizeof</span> pos);</span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span> graph);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        ans.resize(n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>];</span><br><span class="line">            graph[a].push_back(b);</span><br><span class="line">            graph[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd(i, j) == <span class="number">1</span>) &#123;</span><br><span class="line">                    g[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(50 \times N)$，其中 $N$ 为树中点的数量。</p>
<ul>
<li><p>计算 $[1, 50]$ 之间所有可能互质的数，时间复杂度 $O(50^2\times log(50))$。</p>
</li>
<li><p>对于任意一个节点，我们都要枚举出 $[1,50]$ 之间互质的数。时间复杂度 $O(50 \times N)$。</p>
</li>
<li><p>所以时间复杂度为 $O(50 \times N)$。</p>
</li>
</ul>
<p>空间复杂度：$O(N^2)$，其中 $N$ 为树中点的数量。</p>
<ul>
<li>我们需要存储无向图，使用了二维数组。</li>
<li>我们还需要存储每个节点的深度</li>
<li>我们需要存储原 $nums$ 数组，答案数组。</li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>BFS</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>DFS</tag>
        <tag>图</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机类的加载机制</title>
    <url>/2021/03/10/JVM_CHAPTER7/</url>
    <content><![CDATA[<h2 id="【转载】"><a href="#【转载】" class="headerlink" title="【转载】"></a>【转载】</h2><p>本文作者<strong>：</strong><a href="https://www.cnblogs.com/kylinxxx/p/13778513.html">WMS</a><br><strong>本文链接</strong>：<a href="https://www.cnblogs.com/kylinxxx/p/13778513.html">https://www.cnblogs.com/kylinxxx/p/13778513.html</a><br><strong>关于博主</strong>：评论和私信会在第一时间回复。或者<a href="https://msg.cnblogs.com/msg/send/kylinxxx">直接私信</a>我。<br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">BY-NC-SA</a> 许可协议。转载请注明出处！<br><strong>声援博主</strong>：如果您觉得文章对您有帮助，可以点击文章右下角<strong>【<a href="javascript:void(0);">推荐</a>】</strong>一下。您的鼓励是博主的最大动力！</p>
<h1 id="虚拟机类的加载机制"><a href="#虚拟机类的加载机制" class="headerlink" title="虚拟机类的加载机制"></a>虚拟机类的加载机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类的加载机制。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？</p>
<ul>
<li>主动引用<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：<ul>
<li>使用 new 实例化对象；</li>
<li>读取或设置一个类的 static 字段（被 final 修饰的除外）；</li>
<li>调用类的静态方法。</li>
</ul>
</li>
<li>对类进行反射调用；</li>
<li>初始化一个类时，其父类还没初始化（需先初始化父类）；<ul>
<li>这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。</li>
</ul>
</li>
<li>虚拟机启动，先初始化包含 main() 函数的主类；</li>
<li>JDK 1.7 动态语言支持：一个 <code>java.lang.invoke.MethodHandle</code> 的解析结果为 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>。</li>
</ul>
</li>
<li>被动引用<ul>
<li>通过子类引用父类静态字段，不会导致子类初始化；</li>
<li><code>Array[] arr = new Array[10]</code>; 不会触发 Array 类初始化；</li>
<li><code>static final VAR</code> 在编译阶段会存入调用类的常量池，通过 <code>ClassName.VAR</code> 引用不会触发 ClassName 初始化。</li>
</ul>
</li>
</ul>
<p>也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。</p>
<hr>
<blockquote>
<p>类的生命周期</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/reprint/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png"></p>
<hr>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><blockquote>
<p>加载</p>
</blockquote>
<p><strong>加载（Loading）</strong>阶段，虚拟机需要完成以下三件事：</p>
<ul>
<li>通过一个类的全限定名来获取定义这个类对应的二进制字节流</li>
<li>将这个类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这些数据的访问入口。</li>
</ul>
<blockquote>
<blockquote>
<p>分类</p>
</blockquote>
</blockquote>
<ul>
<li>非数组类<ul>
<li>系统提供的引导类加载器</li>
<li>用户自定义的类加载器</li>
</ul>
</li>
<li>数组类<ul>
<li>不通过类加载器，由 Java 虚拟机直接创建</li>
<li>创建动作由 newarray 指令触发，new 实际上触发了 [L全类名 对象的初始化</li>
<li>规则<ul>
<li>数组元素是引用类型<ul>
<li>加载：递归加载其组件</li>
<li>可见性：与引用类型一致</li>
</ul>
</li>
<li>数组元素是非引用类型<ul>
<li>加载：与引导类加载器关联</li>
<li>可见性：public</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<p>类的显式加载和隐式加载</p>
</blockquote>
</blockquote>
<ul>
<li>显示加载：<ul>
<li>调用 <code>ClassLoader#loadClass(className)</code> 或 <code>Class.forName(className)</code>。</li>
<li>两种显示加载 .class 文件的区别：<ul>
<li><code>Class.forName(className)</code> 加载 class 的同时会初始化静态域，<code>ClassLoader#loadClass(className)</code> 不会初始化静态域；</li>
<li><code>Class.forName</code> 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。</li>
</ul>
</li>
</ul>
</li>
<li>隐式加载：<ul>
<li>new 类对象；</li>
<li>使用类的静态域；</li>
<li>创建子类对象；</li>
<li>使用子类的静态域；</li>
<li>其他的隐式加载，在 JVM 启动时：<ul>
<li><code>BootStrapLoader</code> 会加载一些 JVM 自身运行所需的 Class；</li>
<li><code>ExtClassLoader</code> 会加载指定目录下一些特殊的 Class；</li>
<li><code>AppClassLoader</code> 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>验证</p>
</blockquote>
<p>目的： 确保 .class 文件中的字节流信息符合虚拟机的要求。</p>
<p>4 个验证过程：</p>
<ul>
<li>文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” 0xCAFEBABE<ul>
<li>魔数：每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的class文件。</li>
</ul>
</li>
<li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析）</li>
<li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）</li>
<li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验</li>
</ul>
<p>这个操作虽然重要，但不是必要的，可以通过 <code>-Xverify:none</code> 关掉。</p>
<blockquote>
<p>准备</p>
</blockquote>
<p>描述： 为 static 变量在方法区分配内存。</p>
<ul>
<li>static 变量准备后的初始值：<ul>
<li>public static int value = 123;<ul>
<li>准备后为 0，value 的赋值指令 putstatic 会被放在 <code>&lt;clinit&gt;()</code> 方法中，<code>&lt;clinit&gt;()</code>方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。</li>
</ul>
</li>
<li>public static final int value = 123;<ul>
<li>准备后为 123，因为被 static final 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>解析</p>
</blockquote>
<p>描述： 将常量池中的 “符号引用” 替换为 “直接引用”。</p>
<p>在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。</p>
<blockquote>
<blockquote>
<p>什么是 “符号引用” 和 “直接引用” ？</p>
</blockquote>
</blockquote>
<ul>
<li>符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。</li>
<li>直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。</li>
</ul>
<blockquote>
<p>初始化</p>
</blockquote>
<p>描述： 执行类构造器 () 方法的过程。</p>
<ul>
<li><code>&lt;clinit&gt;()</code> 方法<ul>
<li>包含的内容：<ul>
<li>所有 static 的赋值操作；</li>
<li>static 块中的语句；</li>
</ul>
</li>
<li><code>&lt;clinit&gt;()</code> 方法中的语句顺序：<ul>
<li>基本按照语句在源文件中出现的顺序排列；</li>
<li>静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。</li>
</ul>
</li>
<li>与 <code>&lt;init&gt;()</code> 的不同：<ul>
<li>不需要显示调用父类的 <code>&lt;clinit&gt;()</code> 方法；</li>
<li>虚拟机保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法一定执行完毕。也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。</li>
</ul>
</li>
<li>接口与类的不同：<ul>
<li>执行子接口的 <code>&lt;clinit&gt;()</code> 方法前不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法（除非用到了父接口中定义的 public static final 变量）；</li>
</ul>
</li>
<li>执行过程中加锁：<ul>
<li>同一时刻只能有一个线程在执行 <code>&lt;clinit&gt;()</code> 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。</li>
</ul>
</li>
<li>非必要性：<ul>
<li>一个类如果没有任何 static 的内容就不需要执行 () 方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="本小节的补充：-lt-clinit-gt-与-lt-init-gt-方法"><a href="#本小节的补充：-lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="本小节的补充：&lt;clinit&gt; 与 &lt;init&gt; 方法"></a>本小节的补充：<code>&lt;clinit&gt;</code> 与 <code>&lt;init&gt;</code> 方法</h3><p><strong>概述</strong></p>
<p>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法<code>&lt;clinit&gt;</code>, 另一个是实例的初始化方法<code>&lt;init&gt;</code></p>
<p><code>&lt;clinit&gt;</code>：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行</p>
<p><code>&lt;init&gt;</code>:在实例创建出来的时候调用，包括调用new操作符；调用Class或<code>java.lang.reflect.Constructor</code>对象的<code>newInstance()</code>方法；调用任何现有对象的clone()方法；通过<code>java.io.ObjectInputStream</code>类的<code>getObject()</code>方法反序列化。</p>
<h4 id="lt-clinit-gt-方法"><a href="#lt-clinit-gt-方法" class="headerlink" title="&lt;clinit&gt;方法"></a><code>&lt;clinit&gt;</code>方法</h4><blockquote>
<p>先理解 类初始化阶段 的含义: 该阶段负责为类变量赋予正确的初始值, 是一个类或接口被首次使用前的最后一项工作</p>
</blockquote>
<p><code>&lt;clinit&gt;</code>方法的执行时期: 类初始化阶段(该方法只能被jvm调用, 专门承担类变量的初始化工作)</p>
<p><code>&lt;clinit&gt;</code>方法的内容: 所有的类变量初始化语句和类型的静态初始化器</p>
<p>类的初始化时机: 即在java代码中首次主动使用的时候, 包含以下情形:</p>
<ul>
<li>(首次)创建某个类的新实例时–new, 反射, 克隆 或 反序列化;</li>
<li>(首次)调用某个类的静态方法时;</li>
<li>(首次)使用某个类或接口的静态字段或对该字段(final 字段除外)赋值时;</li>
<li>(首次)调用java的某些反射方法时;</li>
<li>(首次)初始化某个类的子类时;</li>
<li>(首次)在虚拟机启动时某个含有 main() 方法的那个启动类</li>
</ul>
<p>注意: 并非所有的类都会拥有一个方法, 满足下列条件之一的类不会拥有方法:</p>
<ol>
<li>该类既没有声明任何类变量，也没有静态初始化语句;</li>
<li>该类声明了类变量，但没有明确使用类变量初始化语句或静态初始化语句初始化;</li>
<li>该类仅包含静态 final 变量的类变量初始化语句，并且类变量初始化语句是编译时常量表达式;</li>
</ol>
<h4 id="lt-init-gt-方法"><a href="#lt-init-gt-方法" class="headerlink" title="&lt;init&gt;方法"></a><code>&lt;init&gt;</code>方法</h4><p><code>&lt;init&gt;</code>方法的执行时期: 对象的初始化阶段</p>
<p>实例化一个类的四种途径:</p>
<ol>
<li>调用 new 操作符</li>
<li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法</li>
<li>调用任何现有对象的clone()方法</li>
<li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载过程中的“通过一个类的全限定名来获取描述这个类的二进制字节流”这个动作是放在Java虚拟机的外部来实现的，以便于让应用程序自己来决定如何去获取所需要的类，实现这个动作的代码模块被称为<strong>“类加载器”</strong>。</p>
<p>类加载器虽然只用于实现类的加载动作，但是它的作用却远远不限于此，比较两个类是否“相等”，不仅仅要确认这两个类是否来源于同一个class文件，还需要加载这两个类的类加载器相同。</p>
<h3 id="如何判断两个类-“相等”"><a href="#如何判断两个类-“相等”" class="headerlink" title="如何判断两个类 “相等”"></a>如何判断两个类 “相等”</h3><ul>
<li>“相等” 的要求<ul>
<li>同一个 .class 文件</li>
<li>被同一个虚拟机加载</li>
<li>被同一个类加载器加载</li>
</ul>
</li>
<li>判断 “相等” 的方法<ul>
<li>instanceof 关键字</li>
<li>Class 对象中的方法：<ul>
<li>equals()</li>
<li>isInstance()</li>
<li>isAssignableFrom()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>站在虚拟机的角度，只存在两种类加载器：</p>
<blockquote>
<p>启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机的一部分<br>其他类加载器，由Java语言实现，独立于虚拟机之外的，全部继承自抽象类 java.lang.ClassLoader</p>
</blockquote>
<p>从开发人员的角度，类加载器可以划分得更细致一些：</p>
<ul>
<li>启动类加载器（Bootstrap）:负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。<code>&lt;JAVA_HOME&gt;/lib``-Xbootclasspath</code> 参数指定的路径</li>
<li>扩展类加载器（Extension）:负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录下的，或者被 <code>java.ext.dir</code> 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<ul>
<li><code>&lt;JAVA_HOME&gt;/lib/ext</code></li>
<li><code>java.ext.dirs</code> 系统变量指定的路径</li>
</ul>
</li>
<li>应用程序类加载器（Application）:负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。<ul>
<li><code>-classpath</code> 参数</li>
</ul>
</li>
</ul>
<p>以上加载器互相配合来加载我们自己的应用程序，如果有必要，我们还可以加入自己定义的加载器。这些加载器之间的关系一般如下图示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qybit/CDN@master/Photo/reprint/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>类加载器的双亲委派模型（Parent Delegation Model）：要求除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器。（注意！这里类加载器之间的父子关系一般不会以继承（Inheritance）来实现，而是使用组合（Composition）来复用父加载器的代码）。这种模型被广泛使用于几乎所有的Java程序中，但是它并不是一个强制性的约束，只是Java设计者推荐给开发者使用的一种类加载器实现方式。</p>
<ul>
<li>工作过程<ul>
<li>当前类加载器收到类加载的请求后，先不自己尝试加载类，而是先将请求委派给父类加载器。因此，所有的类加载请求，都会先被传送到启动类加载器。</li>
<li>只有当父类加载器加载失败时，当前类加载器才会尝试自己去自己负责的区域加载</li>
</ul>
</li>
<li>实现<ul>
<li>检查该类是否已经被加载</li>
<li>将类加载请求委派给父类<ul>
<li>如果父类加载器为 null，默认使用启动类加载器</li>
<li>parent.loadClass(name, false)</li>
</ul>
</li>
<li>当父类加载器加载失败时<ul>
<li>catch ClassNotFoundException 但不做任何处理</li>
<li>调用自己的 findClass() 去加载<ul>
<li>我们在实现自己的类加载器时只需要 extends ClassLoader，然后重写 findClass() 方法而不是 loadClass() 方法，这样就不用重写 loadClass() 中的双亲委派机制了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优点<ul>
<li>自己写的类库同名类不会覆盖类库的类</li>
<li>java类随着它的类加载器一起具备了一种带有优先层级的层次关系，保证了Java程序的稳定运行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术交流</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转载</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Spring IoC 容器</title>
    <url>/2021/04/03/Spring-IoC/</url>
    <content><![CDATA[<p>Spring 中最重要的就是 IoC 和 AOP，我们平时使用 Spring 最多的就是 IoC，那么为啥不去深入了解一下其中的原理呢？本篇作为 Spring IoC 源码探究的文章之一，后续有机会的话将会更新 Spring MVC、MyBatis 等源码探究。</p>
<p>阅读本篇时，请打开 IDE 和我一起深入 IoC 容器内部的工作环境，了解 IoC 的实现细节。</p>
<p>本文的着重点在于 </p>
<ol>
<li><p>Bean 容器的创建；</p>
</li>
<li><p>Bean 的实例化和初始化 </p>
</li>
</ol>
<p>如有不足之处，欢迎讨论。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol>
<li>基本的 Spring 5.3.1 运行环境</li>
<li>支持断点调试的 IDE</li>
<li>本文选择从 xml 配置文件启动</li>
</ol>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开始分析代码之前，先看一下基本的一个架构图</p>
<p><img src="https://img.imgdb.cn/item/5fd4cb8a3ffa7d37b3513ae3.png"></p>
<p>基本的启动代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserController controller = applicationContext.getBean(<span class="string">&quot;userController&quot;</span>, UserController.class);</span><br><span class="line">    controller.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件 （接口或者类，请任意定义一个即可）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.qybit.spring.controller.UserController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>从 <code> ApplicationContext applicationContext = new ClassPathXmlApplicationContext(...);</code> 可以发现，我们是从 xml 文件加载的，而且是可以传入多个配置文件。</p>
<h1 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h1><p>进入 ClassPathXmlApplicationContext 类中，发现定义为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">// 这是我们 Spring 启动的一个核心方法</span></span><br><span class="line">            <span class="comment">// 下面我们会深入其内部，逐个分析各个方法具体做了什么</span></span><br><span class="line">            refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractApplicationContext#refresh 方法，refresh 方法是构建 ApplicatinContext 的，当一个 IoC 容器成功创建后，我们还可以调用 refresh 方法销毁原来的 ApplicationContext，然后进行重建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保证构建当前 ApplicationContext 的完整性，不能有别的线程干扰</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 不是重点，不管它</span></span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备 refresh，记录启动时间，设置激活状态</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是将 配置文件 中定义的 bean 标签，解析成 BeanDefition，然后注册到 BeanFactory</span></span><br><span class="line">        <span class="comment">// 此时仅仅是对 Bean 的定义信息的一个保存，而不是实例化操作</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的类加载，添加 BeanPostProcessor</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">            <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 BeanPostProcessor 的实现类，</span></span><br><span class="line">            <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">            <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是重点，不管它</span></span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i18n 国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 AppplicationContext 事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 钩子函数</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册事件监听器，需要实现 ApplicationListener 接口</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有的 Singleton Bean  lazy-init 除外</span></span><br><span class="line">            <span class="comment">// 核心</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一步，广播事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 日志记录</span></span><br><span class="line">            <span class="comment">// 销毁已经创建的 Bean</span></span><br><span class="line">            <span class="comment">// 撤销状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逐个介绍 refresh() 方法里的重要方法</p>
<h2 id="refresh-的准备工作"><a href="#refresh-的准备工作" class="headerlink" title="refresh 的准备工作"></a>refresh 的准备工作</h2><p>看看代码就可以知道做了哪些事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验配置文件</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-Bean-容器，并注册-Bean"><a href="#创建-Bean-容器，并注册-Bean" class="headerlink" title="创建 Bean 容器，并注册 Bean"></a>创建 Bean 容器，并注册 Bean</h2><p>回到 refresh() 方法中的 obtainFreshBeanFactory() 方法。</p>
<p>这一步是初始化 Bean 容器，并注册保存 Bean 的信息。这也是本文重点讨论的一个方法。注意此步并没有实例化 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果存在过 BeanFactory就先销毁，然后创建新的 BeanFactory，加载 Bean 定义，注册 Bean等</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回新创建的 BeanFactory</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// AbstractRefreshableApplicationContext#refreshBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 假设存在过 BeanFactory，先销毁</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 BeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 设置 序列化 ID</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 自定义 BeanFactory，设置：是否允许 Bean 重写，是否允许循环引用</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载 Bean 定义</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// AbstractRefreshableApplicationContext#customizeBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否允许 Bean 重写</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否允许循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// AbstractXmlApplicationContext#loadBeanDefinitions</p>
<p>加载 Bean 信息</p>
<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还在当前类中，我们已经实例化了 Reader，接下来是要把 xml 文件转换成一颗 DOM 树，用于获取用户定义的 Bean。</p>
<p>// AbstractXmlApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 下面逐个记载所有的配置文件</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 走到下面这一步</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        count += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向下走</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Collections.addAll(actualResources, resources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 320</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ThreadLocal 存放文件资源</span></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正执行的方法</span></span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类 386 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 转换成 DOM 树</span></span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// 开始注册</span></span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        ....</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 508 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 真正执行的方法</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 94 行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前类中 128 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    .......</span><br><span class="line">        <span class="comment">// 钩子函数</span></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">    <span class="comment">// 从 根节点 开始解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 钩子函数</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>经过漫长的寻找，我们找到了 parseBeanDefinitions(root, this.delegate) 最终的解析方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">// 默认的</span></span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他的</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看默认中处理 <code>&lt;bean /&gt;</code> 标签的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前文件 305 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p>
<table>
<thead>
<tr>
<th>Property</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>类的全限定名</td>
</tr>
<tr>
<td>name</td>
<td>可指定 id、name(用逗号、分号、空格分隔)</td>
</tr>
<tr>
<td>scope</td>
<td>作用域</td>
</tr>
<tr>
<td>constructor arguments</td>
<td>指定构造参数</td>
</tr>
<tr>
<td>properties</td>
<td>设置属性的值</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>no(默认值)、byName、byType、 constructor</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td>
</tr>
<tr>
<td>initialization method</td>
<td>bean 属性设置完成后，会调用这个方法</td>
</tr>
<tr>
<td>destruction method</td>
<td>bean 销毁后的回调方法</td>
</tr>
</tbody></table>
<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>
<p>// BeanDefinitionParserDelegate 428</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">    <span class="comment">// 当然，如果不定义 name 属性的话，就是空的了</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                        beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                        !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>
<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们开始说说注册 Bean 吧。</p>
<h2 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h2><p>// BeanDefinitionReaderUtils 158</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">// 注册这个 Bean</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">            <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>
<p>// DefaultListableBeanFactory 976</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// 如果不支持重写，将会报错</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">              <span class="comment">// 	log </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               	<span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            	<span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     	<span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">        <span class="comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">        <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line">            <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">            <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">            <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">            <span class="comment">//registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">            <span class="comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>
<p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p>
<h2 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h2><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p>
<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">        beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略实现下面接口的实现类</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationStartup.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “手动注册的类”</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理。</p>
<h2 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h2><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>
<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>
<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>
<p>// AbstractApplicationContext.java 834</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">    <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 初始化 所有的非懒加载 beans</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                            getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理普通的 bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">    <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.beans.smart-initialize&quot;</span>)</span><br><span class="line">                .tag(<span class="string">&quot;beanName&quot;</span>, beanName);</span><br><span class="line">            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">            smartInitialize.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们将会进入到 getBean(beanName); 方法里了。</p>
<h2 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个 beanName</span></span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经创建过了</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">// log...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是获取 bean,直接返回</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// 已经创建过相同的 bean ，说明陷入了循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否存在 BeanDefintion</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，检查 父容器</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 typeCheckOnly 为 false, 会被放入 alreadyCreated 集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">            .tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">            &#125;</span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">            <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">// 检查是否存在依赖循环</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 先注册依赖的 bean</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取到 bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 重要方法</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">// 执行创建</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查创建的类型</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来就是 createBean(beanName, mbd, args); 方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保 BeanDefintion 中的 class 已经被加载</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备方法重写</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 正式开始要创建 bean 了！！</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-bean"><a href="#创建-bean" class="headerlink" title="创建 bean"></a>创建 bean</h2><p>跨越千山万水，我们终于找到了 doCreateBean 这个方法。请持续保持 debug 状态，我们将继续深入方法内部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 的包装类</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是 bean 包装类中的真正 实例bean</span></span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">// bean 的类型</span></span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要解决 循环依赖 问题，可以了解一下 三级缓存 机制</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 bean ，上面仅仅是 实例化，还没有对属性进行赋值等操作</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化 bean 后的回调函数，比如 init-method 方法的执行</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们就看完了创建 bean 的部分，下面将会重点介绍一下 实例化bean 和 初始化bean 的部分。我们仅仅是稍微瞄一眼即可，再深层次的细节，本人能力有限也分析不动。</p>
<h2 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h2><p>这一步是将之前注册和保存的 beanDefintion 给实例化成对象的过程。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="comment">// 检查访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">    <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="comment">// 构造函数注入</span></span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无参构造函数</span></span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="comment">// 	构造函数注入</span></span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挑个简单的无参构造函数构造实例来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(</span><br><span class="line">                (PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>),</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化</span></span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 包装返回</span></span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的重点在于这一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>这是实例化的地方，我们进去看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                            (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">        <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把这一步走完，我们的bean就算完成了实例化。下面看看初始化的过程</p>
<h2 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h2><p>这一步会对 bean 的属性进行赋值，以及钩子函数(init-method)的执行等操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">            <span class="comment">// 如果没有实例化成功</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口 InstantiationAwareBeanPostProcessors 后，可以在这一步执行</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bean 实例的所有属性都在这</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">        <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过类型匹配</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">            <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值</span></span><br><span class="line">            PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                &#125;</span><br><span class="line">                pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line">        checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h2><p>属性注入完毕后，就开始执行各种回调函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">        <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring 在设计之初，就给我们留下了非常多的可扩展部分，比如 BeanFactoryPostProcessor 可以在注册 BeanDefintion 时，对 BeanDefintion 进行增强或者加入新的 Bean定于。以及 BeanPostProcessor 接口，可以在分别在实例化和初始化后进行执行相应的方法。<br>FactoryBean 在本文就不再继续讨论下去了，感兴趣的可以自行测试。<br>本文的不足之处在于限于个人能力，以及篇幅的限制，很多地方都没有深入展开的进行说明。这也算是给自己挖了个坑，后面有精力再补充。</p>
]]></content>
      <categories>
        <category>技术交流</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
</search>
